<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>“好消息” —— 放弃博客的转移</title>
    <link href="/good-news/"/>
    <url>/good-news/</url>
    
    <content type="html"><![CDATA[<p><strong>简而言之，还是自己太废物了，整不了复杂的“网站”。</strong></p><div class="note note-info">            <p>开始瞎逼逼。</p>          </div><p>再来一次，最近使用过一款<strong>超级简单的文档生成器</strong> —— <a href="https://www.mkdocs.org/">MkDocs</a> —— 一个<strong>快速</strong>、<strong>简单</strong>、<strong>完全华丽</strong>的基于 <code>Python</code> 的静态站点生成器，用于构建项目文档。文档源文件以 <code>Markdown</code> 格式编写，并使用单个 <code>YAML</code> 配置文件进行配置。再配上它的主题 —— <a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a>，整个合起来给人的感觉就是太棒了。用来做文档网站确实很帮，非常的 Nice。</p><p>也有个基于 <code>Rust</code> 的文档生成器，学习 Rust 的时候时常看到 —— <code>Mdbook</code>，简简单单的，但是不符合我颜狗的要求，所以就略过。</p><p>也看到不少的其他的网站生成器，但是基本上也是不太符合自己的要求。</p><p><a href="https://docusaurus.io/zh-CN/docs/">Docusaurus</a> —— 一款静态站点生成器。造的轮子特别特别的多，又有文档功能、还有博客功能，可以用于搭建各种网站 —— 个人网站、产品、博客、营销主页等等。</p><p>我觉得这个网站生成器着实不错 —— 可以做文档网站；可以做博客网站。一站多用，顶。强大归强大，对于颜狗而言，网站不是那么符合我的预期。一番搜索后，发现一位大佬的作品 —— <a href="https://kuizuo.cn/">愧怍的小站</a>，丰富的动态效果、效果不错的主页、还有美化，将文档和博客很好的融合在一起，最最重要的是，他的网站还有导航，收藏着很多的使用的网站，简单地看下来，感觉十分的适合自己，就想着能不能把自己博客网站转移到大佬的网站上 —— 借鉴他的网站，一点点的改成自己的，大佬源码也是开源的，也说了可以酱紫做。</p><p>于是乎，我就开始酱紫做，先试试大佬的网站，结果出师未捷身先死 —— 我 clone 了仓库文件，按照步骤，开始本地的部署。但是直接开始报错，咱也不清楚呀，真不知道前端那一套怎么那么容易报错呢，明明只是重新执行了 <code>yarn start</code> 命令，结果就说什么什么插件可以更新，网站页面也就没法查看了，进行了多次尝试依然还是老样子，What’s Up，真难搞。焦头烂额之际，我甚至去找了大佬，试图通过加大佬的 QQ，直接贴脸开始问问题，不过算是我异想天开了，大佬直接不鸟我涅，即使我表明来意，可能是嫌我麻烦吧，懒得跟我说。没办法捏，暂时没搞，就见到看了看网站的源码，不是很难的样子，嗯，复杂的样子，想必，网站移植起来不是很麻烦吧，当然我实在是太看得起我自己了。</p><p>OK，继续瞎逼逼。</p><p>过了一两天，嘿嘿嘿，我又尝试了一波，嘿嘿，这回就没事了，一切 OK。没有报错涅，看了下，大佬也没有进行修改涅，不知道怎么回事，算了。开整开整。</p><p><strong>经过一番简单的尝试下来，😅，事实证明我非常地高估了自己。</strong></p><p>想着，“先打扫干净再敞开大门”，就先把不需要的文件、设置之类的先删除，再慢慢将自己的东西一点点的加上来，结果删着删着，哈哈，报错了，不知道怎么回事呢，就是自己太废了，摆了摆了，我还是好好学习学习吧，前端框架的东西好多呀，好复杂，完全不太会，摆了。</p><p>我好废呀。呜呜呜。😭😭😭😭😭。</p><p>所以就，还是使用咱这 Hexo 吧，简单呀，真的简单呀。</p><div class="note note-secondary">            <p>颜狗死一死吧。</p><p>现在还是继续用 Hexo。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>瞎逼逼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>瞎逼逼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell 学习</title>
    <link href="/shell-learning/"/>
    <url>/shell-learning/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近一直在做某些重复性的操作，太多机械性的操作，非常的浪费时间，作为一个懒汉，必须得想办法偷懒。</p><p>之前整理博客文章的时候，刚好看到大佬给予的命令：</p><div class="code-wrapper"><pre><code class="hljs bash">grep -r <span class="hljs-string">&quot;date: 2020-&quot;</span> *.md -l | xargs <span class="hljs-built_in">mv</span> -v -t 2020/</code></pre></div><p>之类的。可以快速的、批量的操作文件，比手动点点点的快多了。心想着，我那些机械性重复性操作是不是也可以想办法偷懒，使用某种命令一次性完成所有的操作。于是就询问的神奇海螺看看有没有什么建议，进而发现<strong>可以使用 shell 脚本 —— shell script</strong> 进行批量操作。</p><p>话不多说直接开干。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>一番实践下来，效果显著，偷懒ing。</p><p>下面的实践都是所说的机械性操作。</p><h3 id="读取文件内容批量创建-markdown-文件和文件夹"><a href="#读取文件内容批量创建-markdown-文件和文件夹" class="headerlink" title="读取文件内容批量创建 markdown 文件和文件夹"></a>读取文件内容批量创建 markdown 文件和文件夹</h3><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># 读取目录</span><span class="hljs-built_in">read</span> -r directory &lt; input.txtdirectory=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$directory</span>&quot;</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&#x27;\r&#x27;</span>)<span class="hljs-comment"># 读取文件名并处理回车符</span><span class="hljs-built_in">tail</span> -n +2 input.txt | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&#x27;\r&#x27;</span> | <span class="hljs-keyword">while</span> IFS= <span class="hljs-built_in">read</span> -r file<span class="hljs-keyword">do</span>    <span class="hljs-comment"># 创建文件夹和文件</span>    file=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;line// /_&#125;</span>&quot;</span>    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$directory</span>/images/<span class="hljs-variable">$file</span>&quot;</span>    <span class="hljs-built_in">touch</span> <span class="hljs-string">&quot;<span class="hljs-variable">$directory</span>/<span class="hljs-variable">$file</span>.md&quot;</span><span class="hljs-keyword">done</span></code></pre></div><h3 id="读取两个文件以创建-markdown-文件和文件夹，并输出指定格式内容到文件中"><a href="#读取两个文件以创建-markdown-文件和文件夹，并输出指定格式内容到文件中" class="headerlink" title="读取两个文件以创建 markdown 文件和文件夹，并输出指定格式内容到文件中"></a>读取两个文件以创建 markdown 文件和文件夹，并输出指定格式内容到文件中</h3><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 0 ]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;未提供路径参数&quot;</span>  <span class="hljs-built_in">exit</span> 1<span class="hljs-keyword">fi</span><span class="hljs-comment"># 使用命令行参数作为路径</span>target_path=<span class="hljs-string">&quot;path/<span class="hljs-variable">$1</span>&quot;</span><span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$target_path</span>&quot;</span>&gt;links.yml<span class="hljs-comment"># 指定相对路径的基准路径</span>base_path=<span class="hljs-string">&quot;path&quot;</span><span class="hljs-built_in">touch</span> <span class="hljs-string">&quot;<span class="hljs-variable">$target_path</span>/index.md&quot;</span><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%c <span class="hljs-variable">$1</span>/index.md\n&quot;</span> <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-built_in">tee</span> -a links.yml<span class="hljs-comment"># 逐行读取两个文件的内容，直到文件结束</span><span class="hljs-built_in">paste</span> chinese.txt english.txt | <span class="hljs-keyword">while</span> IFS=$<span class="hljs-string">&#x27;\t&#x27;</span> <span class="hljs-built_in">read</span> -r name path; <span class="hljs-keyword">do</span>  <span class="hljs-comment"># 在这里对行内容进行处理</span>  <span class="hljs-comment"># 将 \r 替换为空格</span>  name=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;name//$&#x27;\r&#x27;/&#125;</span>&quot;</span>  path=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;path//$&#x27;\r&#x27;/&#125;</span>&quot;</span>  path=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;path// /_&#125;</span>&quot;</span>  <span class="hljs-comment"># 创建文件和文件夹</span>  <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$target_path</span>/images/<span class="hljs-variable">$path</span>&quot;</span>  <span class="hljs-built_in">touch</span> <span class="hljs-string">&quot;<span class="hljs-variable">$target_path</span>/<span class="hljs-variable">$path</span>.md&quot;</span>  <span class="hljs-comment"># printf &quot;$target_path/$path.md &amp; $target_path/images/$path 都已创建~\n&quot;</span>  <span class="hljs-comment"># yml 链接</span>  <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%c <span class="hljs-variable">$name</span>: <span class="hljs-variable">$1</span>/<span class="hljs-variable">$path</span>.md\n&quot;</span> <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-built_in">tee</span> -a links.yml<span class="hljs-keyword">done</span>&gt;chinese.txt&gt;english.txt</code></pre></div><h3 id="查找目标路径中的所有-Markdown-文件，并输出相对路径到-output-txt"><a href="#查找目标路径中的所有-Markdown-文件，并输出相对路径到-output-txt" class="headerlink" title="查找目标路径中的所有 Markdown 文件，并输出相对路径到 output.txt"></a>查找目标路径中的所有 Markdown 文件，并输出相对路径到 output.txt</h3><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># 检查是否提供了命令行参数</span><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 0 ]; <span class="hljs-keyword">then</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;未提供路径参数&quot;</span>  <span class="hljs-built_in">exit</span> 1<span class="hljs-keyword">fi</span><span class="hljs-comment"># 使用命令行参数作为路径</span>target_path=<span class="hljs-string">&quot;docs/<span class="hljs-variable">$1</span>&quot;</span><span class="hljs-comment"># 指定相对路径的基准路径</span>base_path=<span class="hljs-string">&quot;docs&quot;</span>&gt; output.txt<span class="hljs-comment"># 查找目标路径中的所有 Markdown 文件，并输出相对路径到 output.txt</span>find <span class="hljs-string">&quot;<span class="hljs-variable">$target_path</span>&quot;</span> -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.md&quot;</span> | <span class="hljs-keyword">while</span> IFS= <span class="hljs-built_in">read</span> -r file<span class="hljs-keyword">do</span>    relative_path=$(<span class="hljs-built_in">realpath</span> --relative-to=<span class="hljs-string">&quot;<span class="hljs-variable">$base_path</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$relative_path</span>&quot;</span> &gt;&gt; output.txt<span class="hljs-keyword">done</span></code></pre></div><h3 id="遍历目标路径中的所有文件夹，并输出相对路径"><a href="#遍历目标路径中的所有文件夹，并输出相对路径" class="headerlink" title="遍历目标路径中的所有文件夹，并输出相对路径"></a>遍历目标路径中的所有文件夹，并输出相对路径</h3><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># 指定要列出文件夹的目录</span>target_path=<span class="hljs-string">&quot;docs&quot;</span><span class="hljs-comment"># 指定相对路径的基准路径</span>base_path=<span class="hljs-string">&quot;docs&quot;</span><span class="hljs-comment"># 清空输出文件</span>&gt; all_path.txt<span class="hljs-comment"># 遍历目标路径中的所有文件夹，并输出相对路径</span>find <span class="hljs-string">&quot;<span class="hljs-variable">$target_path</span>&quot;</span> -<span class="hljs-built_in">type</span> d | <span class="hljs-keyword">while</span> IFS= <span class="hljs-built_in">read</span> -r <span class="hljs-built_in">dir</span><span class="hljs-keyword">do</span>    relative_path=$(<span class="hljs-built_in">realpath</span> --relative-to=<span class="hljs-string">&quot;<span class="hljs-variable">$base_path</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$dir</span>&quot;</span>)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$relative_path</span>&quot;</span> &gt;&gt; all_path.txt<span class="hljs-keyword">done</span></code></pre></div><h3 id="格式化输出-html-的图片链接"><a href="#格式化输出-html-的图片链接" class="headerlink" title="格式化输出 html 的图片链接"></a>格式化输出 html 的图片链接</h3><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">#!/bin/bash</span><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne 3 ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;需要提供 3 个输入参数&quot;</span>    <span class="hljs-built_in">exit</span> 1<span class="hljs-keyword">fi</span><span class="hljs-comment"># 在这里执行操作，使用 $1 和 $2 引用输入参数</span>images_name=<span class="hljs-variable">$2</span>num=<span class="hljs-variable">$3</span><span class="hljs-built_in">fmt</span>=<span class="hljs-variable">$1</span><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$fmt</span> -eq 1 ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">fmt</span>=<span class="hljs-string">&quot;.jpg&quot;</span><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$fmt</span> -eq 2 ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">fmt</span>=<span class="hljs-string">&quot;.png&quot;</span><span class="hljs-keyword">else</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;输入1表示图片格式为jpg，输入2表示图片格式为png，其他输入无效&quot;</span>    <span class="hljs-built_in">exit</span> 1<span class="hljs-keyword">fi</span>&gt; images.txt<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;&lt;div class=\&quot;gallery\&quot;&gt;&lt;div class=\&quot;column\&quot;&gt;\n&quot;</span> | <span class="hljs-built_in">tee</span> -a images.txtcount=0<span class="hljs-keyword">for</span> ((i = <span class="hljs-number">1</span>; i &lt;= num; i += <span class="hljs-number">2</span>)); <span class="hljs-keyword">do</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;&lt;img src=\&quot;./images/%s_%04d<span class="hljs-variable">$fmt</span>\&quot;&gt;&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$images_name</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> | <span class="hljs-built_in">tee</span> -a images.txt    ((count++))    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$count</span> -eq 2 ]; <span class="hljs-keyword">then</span>        count=0        <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\n&quot;</span> | <span class="hljs-built_in">tee</span> -a images.txt    <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$count</span> -eq 1 ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\n&quot;</span> | <span class="hljs-built_in">tee</span> -a images.txt<span class="hljs-keyword">fi</span><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;&lt;/div&gt;&lt;div class=\&quot;column\&quot;&gt;\n&quot;</span> | <span class="hljs-built_in">tee</span> -a images.txtcount=0<span class="hljs-keyword">for</span> ((i = <span class="hljs-number">2</span>; i &lt;= num; i += <span class="hljs-number">2</span>)); <span class="hljs-keyword">do</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;&lt;img src=\&quot;./images/%s_%04d<span class="hljs-variable">$fmt</span>\&quot;&gt;&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$images_name</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> | <span class="hljs-built_in">tee</span> -a images.txt    ((count++))    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$count</span> -eq 2 ]; <span class="hljs-keyword">then</span>        count=0        <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\n&quot;</span> | <span class="hljs-built_in">tee</span> -a images.txt    <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$count</span> -eq 1 ]; <span class="hljs-keyword">then</span>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\n&quot;</span> | <span class="hljs-built_in">tee</span> -a images.txt<span class="hljs-keyword">fi</span><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;&lt;/div&gt;&lt;/div&gt;\n&quot;</span> | <span class="hljs-built_in">tee</span> -a images.txt</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 文章管理：子文件夹管理 + 保留文章永久链接</title>
    <link href="/organize-files/"/>
    <url>/organize-files/</url>
    
    <content type="html"><![CDATA[<p>最近使用 Mkdocs + Material for Mkdocs 编辑文档网站，一顿实践下来，就习惯干净整洁的项目结构，一个个文件都比较容易找到，看着也不乱。</p><p>然后看到许久未更新的博客，就想着过来水一水。结果所有的文章都是堆在 <code>source/_post</code> 下面，像是一团乱麻，而且找起之前的文章也是十分的不方便，就想着能不能整理一下，看着清爽一点。</p><p>于是一番搜索后，发现大佬们有着不错的想法：</p><ul><li><a href="https://prinsss.github.io/hexo-posts-in-subfolder/">使用子文件夹管理 Hexo 文章且不改变文章永久链接 | PRIN BLOG</a></li><li><a href="https://mrseawave.github.io/blogs/articles/2021/06/25/hexo-new-post-path/">如何在 Hexo 中对文章 md 文件分类 | Sea</a></li></ul><p>简单查看后，明白了应该怎么实现简单的文章整理 + 保留文章的永久链接。</p><p>主要修改的文件是：<code>_config.yml</code> —— 主题配置文件。</p><ul><li><code>permalink</code>：用于设置文章的永久链接格式</li><li><code>new_post_name</code>：新文章的文件名称</li></ul><p>需要修改的位置也只是上述两个字段，对于我而言，只需要修改<strong>新文章的文件名称</strong>，永久链接格式，我之前已经修改了 —— 直接使用 <code>url/:name/</code> 的格式，看着直观清爽。</p><p>所以修改一下 <code>new_post_name</code> 为 <code>:year/:title.md</code> ，即，新文章自动创建在年份的文件夹下，如本文 markdown 文件的创建过程：</p><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new post organize-filesINFO  Validating configINFO  Created: ....\blog\<span class="hljs-built_in">source</span>\_posts\2023\organize-files.md</code></pre></div><p>故而 <code>_config.yml</code> 文件修改为：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">permalink:</span> <span class="hljs-string">:name/</span><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:year/:title.md</span></code></pre></div><p>虽然修改了站点配置文件，但是咱们文章的整理还是 “比较” 麻烦，文章太多，创建时间也不是那么好查看，一个个的移动真的挺麻烦。</p><p>不过好在，<a href="https://prinsss.github.io/hexo-posts-in-subfolder/">使用子文件夹管理 Hexo 文章且不改变文章永久链接 | PRIN BLOG</a> 中给了我答案：使用命令行命令批量整理源文件 - <code>grep -r &quot;date: &#39;2015-&quot; *.md -l | xargs mv -v -t 2015/</code>。</p><p>我直接照葫芦画瓢：</p><div class="code-wrapper"><pre><code class="hljs bash">$ grep -r <span class="hljs-string">&quot;date: 2020-&quot;</span> *.md -l | xargs <span class="hljs-built_in">mv</span> -v -t 2020/已重命名 <span class="hljs-string">&#x27;csapp-bomb.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2020/csapp-bomb.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;datalab-handout.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2020/datalab-handout.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;git-password.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2020/git-password.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;hexo-blog-encrypt.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2020/hexo-blog-encrypt.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;using-github-actions.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2020/using-github-actions.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;vscode-env-c-old.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2020/vscode-env-c-old.md&#x27;</span>$ grep -r <span class="hljs-string">&quot;date: 2021-&quot;</span> *.md -l | xargs <span class="hljs-built_in">mv</span> -v -t 2021/已重命名 <span class="hljs-string">&#x27;C-create-link.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2021/C-create-link.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;mean-of-life.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2021/mean-of-life.md&#x27;</span>$ grep -r <span class="hljs-string">&quot;date: 2022-&quot;</span> *.md -l | xargs <span class="hljs-built_in">mv</span> -v -t 2022/已重命名 <span class="hljs-string">&#x27;cannot-display-pictrue.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/cannot-display-pictrue.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;cannot-ssh-connect-with-ps.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/cannot-ssh-connect-with-ps.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;console-lang=en.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/console-lang=en.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;cygwin-installation.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/cygwin-installation.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;discrete-mathematics-basic-concept-graph.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/discrete-mathematics-basic-concept-graph.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;discrete-mathematics-color-graphic.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/discrete-mathematics-color-graphic.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;discrete-mathematics-elatu-hamilton.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/discrete-mathematics-elatu-hamilton.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;discrete-mathematics-graph-connectivity.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/discrete-mathematics-graph-connectivity.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;discrete-mathematics-graph-matrix.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/discrete-mathematics-graph-matrix.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;discrete-mathematics-path-circuit.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/discrete-mathematics-path-circuit.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;discrete-mathematics-plane-map.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/discrete-mathematics-plane-map.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;discrete-mathematics-set-knowledge.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/discrete-mathematics-set-knowledge.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;discrete-mathematics-tree.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/discrete-mathematics-tree.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;git-proxy-error.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/git-proxy-error.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;good-skills-record.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/good-skills-record.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;install-microsoft-store.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/install-microsoft-store.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;linux-gurb-beauty.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/linux-gurb-beauty.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;ml-boston-housing.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/ml-boston-housing.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;ml-decision-tree.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/ml-decision-tree.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;ml-lda.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/ml-lda.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;ml-perceptron.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/ml-perceptron.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;powershell-beauty.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/powershell-beauty.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;scoop-replace-source.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/scoop-replace-source.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;terminal-useing.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/terminal-useing.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;ubuntu-error-unable-to-mkstemp.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/ubuntu-error-unable-to-mkstemp.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;ubuntu-install-colorls.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/ubuntu-install-colorls.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;ubuntu-update-failed.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/ubuntu-update-failed.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;ubuntu-ustc-sources.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/ubuntu-ustc-sources.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;ubuntu-zsh-ohmyzsh.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/ubuntu-zsh-ohmyzsh.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;use-wsl2-ubuntu.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/use-wsl2-ubuntu.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;using-scoop.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/using-scoop.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;vscode-env-c-new.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/vscode-env-c-new.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;vscode-markdown-pdf-math-latex-error.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/vscode-markdown-pdf-math-latex-error.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;vscode-plugins.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/vscode-plugins.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;wsl-error-0x8007019e.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2022/wsl-error-0x8007019e.md&#x27;</span>$ grep -r <span class="hljs-string">&quot;date: 2023-&quot;</span> *.md -l | xargs <span class="hljs-built_in">mv</span> -v -t 2023/已重命名 <span class="hljs-string">&#x27;adb-learning.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/adb-learning.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;arch-kde-plasma.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/arch-kde-plasma.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;archlinux-beauty.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/archlinux-beauty.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;cannot-find-module-css.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/cannot-find-module-css.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;git-learning.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/git-learning.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;git-ssh-authentication.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/git-ssh-authentication.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;install-uninstall-anaconda.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/install-uninstall-anaconda.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;install-uninstall-python.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/install-uninstall-python.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;kex-exchange-identification.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/kex-exchange-identification.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;rename-by-rust.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/rename-by-rust.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;rust-learning.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/rust-learning.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;use-comment-giscus.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/use-comment-giscus.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;vscode-quick-suggestions.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/vscode-quick-suggestions.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;windows10-msys2-installation.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/windows10-msys2-installation.md&#x27;</span>已重命名 <span class="hljs-string">&#x27;yay-instead-pacman.md&#x27;</span> -&gt; <span class="hljs-string">&#x27;2023/yay-instead-pacman.md&#x27;</span></code></pre></div><div class="note note-info">            <div class="code-wrapper"><pre><code class="hljs bash">grep -r <span class="hljs-string">&quot;date: 2020-&quot;</span> *.md -l | xargs <span class="hljs-built_in">mv</span> -v -t 2020/</code></pre></div><p>这个命令的意思是在当前目录下查找所有扩展名为 .md 的文件中包含 “date: ‘2020-“ 的行，并将这些文件移动到名为 2020 的目录中。</p><p>这需要<strong>先创建 2020 目录</strong>。否则：<code>mv: 访问 &#39;2020/&#39; 失败: No such file or directory</code>。</p><p>其次，要确定好 <code>grep</code> 命令查找的文件的内容 —— “date: 2020-“，该部分为每个 md 文件：</p><div class="code-wrapper"><pre><code class="hljs markdown">date: 2023-06-08 17:04:15</code></pre></div><p>的内容，这需要根据自己文件的情况敲命令，不要盲目复制啊，不要学我。</p><p>仔细一点后就没事了。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 主题 fluid：Error：Cannot find module &#39;css&#39;</title>
    <link href="/cannot-find-module-css/"/>
    <url>/cannot-find-module-css/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>许久没有更新博客，心血来潮，再来一次。先去 github 看了看，发现有依赖更新了，于是一顿操作后更新了。</p><p>结果跑持续集成时报错，报错情况如下：</p><div class="code-wrapper"><pre><code class="hljs bash">INFO  Validating configERROR Script load failed: themes\fluid\scripts\events\lib\highlight.jsError: Cannot find module <span class="hljs-string">&#x27;css&#x27;</span>Require stack:......</code></pre></div><p>更新了的依赖为：</p><ul><li>hexo-renderer-stylus</li><li>hexo-blog-encrypt</li><li>hexo-renderer-marked</li></ul><p>查看错误位置：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">const</span> css = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;css&#x27;</span>);<span class="hljs-keyword">const</span> objUtil = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../utils/object&#x27;</span>);<span class="hljs-keyword">const</span> resolveModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../utils/resolve&#x27;</span>);</code></pre></div><p>确实有一部分为 <code>css</code>，不过怎么会找不到涅。不是很明白。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>经过一番操作，如更新依赖，更新主题啥啥啥的，还是无法解决。</p><p>最终在搜索引擎的帮助下，找到了，fluid 主题 github 仓库的 <code>issues</code>，发现有人遇到了同样的问题。</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/issues/952">ERROR Script load failed: themes\fluid\scripts\events\lib\highlight.js</a></p><p>在此中，主题作者<a href="https://github.com/zkqiang">zkqiang</a>解释道：</p><div class="code-wrapper"><pre><code class="hljs txt">This is because the new version of hexo-renderer-stylus no longer includes css module (stylus/stylus@043d404)</code></pre></div><p>即，<strong>新版本的 hexo-renderer-stylus 不再包含 css 模块。</strong>，详见：<a href="https://github.com/stylus/stylus/commit/043d4047031579bf8d1383116cf8f9a38d113d43">stylus&#x2F;stylus@<code>043d404</code></a>。</p><p>有人就提出了解决办法，安装 <code>css</code>：</p><div class="code-wrapper"><pre><code class="hljs bash">npm install css --save</code></pre></div><p>尝试后，成功解决问题，Nice。</p><h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>作者在 <code>develop</code> 分支中进行了修改：</p><ul><li>修改文件：<code>scripts/events/lib/highlight.js</code></li><li>删除代码：<code>const css = require(&#39;css&#39;);</code></li><li>添加代码：  <div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> css;<span class="hljs-keyword">try</span> &#123;    css = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;css&#x27;</span>);&#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">code</span> === <span class="hljs-string">&#x27;MODULE_NOT_FOUND&#x27;</span>) &#123;        css = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@adobe/css-tools&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> error;    &#125;&#125;</code></pre></div></li></ul><p>没升级 hexo-renderer-stylus 就使用 <code>css = require(&#39;css&#39;);</code>，反之，<code>css = require(&#39;@adobe/css-tools&#39;);</code>。</p><p>不过咱这就还是自己安装 css 吧。</p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kex_exchange_identification：远程主机关闭连接</title>
    <link href="/kex-exchange-identification/"/>
    <url>/kex-exchange-identification/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><div class="code-wrapper"><pre><code class="hljs zsh">$ git pushkex_exchange_identification: Connection closed by remote hostConnection closed by xx.xxx.xxx.xxx port 22致命错误：无法读取远程仓库。请确认您有正确的访问权限并且仓库存在。</code></pre></div><p>心血来潮写了点东西到博客，好不容易写完了，推送到 GitHub 时竟然直接报错：<code>kex_exchange_identification: Connection closed by remote host</code>，咱也没有干什么呀，怎么就远程主机关闭连接了。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>搜索了许久之后，也是发现了不少的方法，试来试去还是不太行，不少人都提到 —— 关闭科学上网，虽然我试了，但是还是没有卵用。</p><p>就这般试了好几次，还是不太行，最后还是看到有人的说到与科学上网有关。</p><p>于是乎，就直接操作，最后还是关闭科学上网解决了问题。</p><h3 id="瞎逼逼"><a href="#瞎逼逼" class="headerlink" title="瞎逼逼"></a>瞎逼逼</h3><p>瞎记录点内容，不过好在又让我知道，遇到和 git、GitHub 相关的问题可以去 <a href="https://docs.github.com/zh">GitHub 文档 | 中文</a> 进行查阅。</p><h3 id="再逼逼"><a href="#再逼逼" class="headerlink" title="再逼逼"></a>再逼逼</h3><p>目前使用的 git 为 MSYS2 中下载的 git，听大佬说，该 git 的有些功能有那么些问题，似乎包括 ssh。</p><p>于是乎，果断 <code>pacman -Rns git</code> 卸载 git 相关内容。</p><p>然后使用 Windows 版的 git，并将其加入到 MSYS2 的环境变量中。</p><p>生效后，再将之前的远程仓库地址改为 https：</p><div class="code-wrapper"><pre><code class="hljs zsh">git remote set-url origin https://github.com/muxiner/muxiner.github.io.git</code></pre></div><p>最后，<code>git push</code>。</p><p>可能还需要适当配合科学上网进行使用。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/qq_43431735/article/details/106031021">连接GitHub提示远程主机关闭连接</a></li><li><a href="https://docs.github.com/zh/authentication">身份验证 | GitHub 文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 的安装、配置与卸载</title>
    <link href="/install-uninstall-python/"/>
    <url>/install-uninstall-python/</url>
    
    <content type="html"><![CDATA[<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载地址: <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>.</p><p>根据个人需求下载  Windows, Linux&#x2F;UNIX, macOS, Other 等等不同平台、不同版本、安装版或是稳定版的 python 安装包。然后根据程序指示进行操作，或是将解压内容放在合适的位置。</p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><div class="note note-danger">            <p><strong>To Be Continued:</strong></p><p>还没写完涅。</p>          </div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda 安装、使用和卸载</title>
    <link href="/install-uninstall-anaconda/"/>
    <url>/install-uninstall-anaconda/</url>
    
    <content type="html"><![CDATA[<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>先进入 <a href="https://www.anaconda.com/products/distribution#Downloads">DownLoad | Anaconda</a> 下载界面，选择 Windows 版的 Installer 文件。</p><p>或者直接点击：<a href="https://repo.anaconda.com/archive/Anaconda3-2023.03-Windows-x86_64.exe">Anaconda3-2023.03-Windows-x86_64.exe</a></p><blockquote><p>版本可能不是最新的。</p></blockquote><p>Over，有空再写。</p><h2 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h2><p><del>我 TM 的直接开幕雷击，直接先卸载 Anaconda。</del></p><h2 id="Uninstallation"><a href="#Uninstallation" class="headerlink" title="Uninstallation"></a>Uninstallation</h2><p>首先，按下 <code>Win + R</code> 打开<code>运行</code>窗口，输入: </p><div class="code-wrapper"><pre><code class="hljs">appwiz.cpl</code></pre></div><p>按下回车直接打开 <code>控制面板 &gt; 所有控制面板项 &gt; 程序和功能</code>。</p><p>选择 <code>Anaconda3</code> 右键进行卸载。然后根据 Anaconda 卸载窗口的提示一步步操作即可。</p><p>待卸载完成后，Anaconda3 目录就已经被删除了，接下来需要检查一下是否存在残留：</p><ul><li><p>环境变量：</p><p>按下 <code>Win + R</code> 键入：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">systempropertiesadvanced</span></code></pre></div><p>就会打开<strong>系统属性</strong>，再选择<strong>环境变量</strong>，再选择<strong>用户变量</strong>和<strong>系统变量</strong>中的 <code>path</code>，删除与 <code>Anaconda</code> 相关的所有条目。</p><p>然后一路点击<strong>确定</strong>。</p></li><li><p>用户数据：</p><p>Anaconda 还可能是用户主目录的一部分。在该目录（例如，<code>C:\Users\&lt;your username&gt;</code>）中搜索名为 <code>.anaconda</code> 或 <code>.conda</code> 的目录并删除。</p></li></ul><p>如此 Anaconda 的卸载基本上就已经完成了。</p><div class="note note-danger">            <p><strong>To Be Continued:</strong></p><p>还没写完涅。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
      <tag>conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Rust 的批量文件重命名的命令行工具</title>
    <link href="/rename-by-rust/"/>
    <url>/rename-by-rust/</url>
    
    <content type="html"><![CDATA[<h2 id="项目构想"><a href="#项目构想" class="headerlink" title="项目构想"></a>项目构想</h2><p>个人比骄喜欢搜集画师的作品等等之类的资源，因为含有大量的图片文件需要管理，基于自身的命名习惯以及分类习惯，总是需要对画师的作品进行详细的分类，以满足分门别类的想法，好方便自己浏览画师作品。因而在整理的过程中，根据文件操作的需要而进行不同的操作，总是一些重复性、机械性的操作，想着如果编写出含有这些功能的代码，快速实现操作，那样就可以节省很多的时间。虽然曾经使用 Python 语言简单的编写重命名的工具，但是所实现的内容过于单一，并不能满足所有的需求，因而想使用 Rust 实现一个集成多种操作的命令行工具，一方面能够满足文件操作的使用需要，另一方面还可以对 Rust 语言的学习进行联系，检验一下学习进度。</p><h2 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h2><ol><li>重命名：固定格式</li><li>重命名：以文件夹命名</li><li>重命名：自定义</li><li>文件移动</li></ol><div class="note note-danger">            <p><strong>To Be Continued:</strong></p><p>还没写完涅。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Repo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Hexo-theme-fluid 使用 giscus</title>
    <link href="/use-comment-giscus/"/>
    <url>/use-comment-giscus/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p><strong>To Be Continued:</strong></p><p>还没写完涅。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>hexo-theme-fluid</tag>
      
      <tag>giscus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 语言学习历程</title>
    <link href="/rust-learning/"/>
    <url>/rust-learning/</url>
    
    <content type="html"><![CDATA[<h2 id="Why-记录"><a href="#Why-记录" class="headerlink" title="Why 记录"></a>Why 记录</h2><p>希望有人能够看到吧，避免走弯路。</p><p>毕竟总有些傻逼，没做足功课就直接一股脑扎进 rust 学习呢，学了一段时间后，发现，NM，不太对劲，不是很会用的样子，然后找了下，发现还有更加好的教程，或者说是学习路径，还可以边学边练习，还幽默风趣、生动形象、绘声绘色、妙趣横生……还会鼓励咱们，多好呀。</p><p>嗯，没错，<del>ShaBee is me</del></p><p>暂且说这么多。</p><h2 id="Rust-环境"><a href="#Rust-环境" class="headerlink" title="Rust 环境"></a>Rust 环境</h2><h3 id="vscode-rust-插件"><a href="#vscode-rust-插件" class="headerlink" title="vscode rust 插件"></a>vscode rust 插件</h3><ul><li><code>rust-analyzer</code>：社区驱动的 Rust 语言的插件，就是好用。</li><li><code>Even Better TOML</code>：支持 .toml 文件完整特性</li><li><code>Error Lens</code>：更好的获得错误展示</li><li><code>CodeLLDB</code>：Debugger 程序</li></ul><div class="note note-primary">            <p>test</p>          </div><h2 id="LeetCode-刷题学习-Rust"><a href="#LeetCode-刷题学习-Rust" class="headerlink" title="LeetCode 刷题学习 Rust"></a>LeetCode 刷题学习 Rust</h2><div class="note note-primary">            <p>更新：2023-04-14 18:31:22</p>          </div><h3 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h3><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。示例：</p><div class="code-wrapper"><pre><code class="hljs txt">输入：digits = [4,3,2,1]输出：[4,3,2,2]解释：输入数组表示数字 4321。输入：digits = [1,2,3]输出：[1,2,4]解释：输入数组表示数字 123。输入：digits = [0]输出：[1]1 &lt;= digits.length &lt;= 1000 &lt;= digits[i] &lt;= 9</code></pre></div><p>菜鸟写的，简单直接，有用，但是没啥技巧，我是废物：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_one</span>(digits: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">add</span> = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..digits.<span class="hljs-title function_ invoke__">len</span>() &#123;            <span class="hljs-keyword">if</span> digits[digits.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span> - i] &lt; <span class="hljs-number">9</span> &amp;&amp; add &#123;                result.<span class="hljs-title function_ invoke__">push</span>(digits[digits.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span> - i] + <span class="hljs-number">1</span>);                add = <span class="hljs-literal">false</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> digits[digits.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span> - i] == <span class="hljs-number">9</span> &amp;&amp; add &#123;                result.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">0</span>);                add = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                result.<span class="hljs-title function_ invoke__">push</span>(digits[digits.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span> -i]);                add = <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> add &#123;            result.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">return_vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;= <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();                <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..result.<span class="hljs-title function_ invoke__">len</span>() &#123;            return_vec.<span class="hljs-title function_ invoke__">push</span>(result[result.<span class="hljs-title function_ invoke__">len</span>() - i - <span class="hljs-number">1</span>]);        &#125;        return_vec    &#125;&#125;</code></pre></div><p>简单描述一下想法：</p><p>给咱一个不可变的动态数组 <code>Vec</code> 也需要咱们返回一个动态数组 <code>Vec</code>，所以是需要咱返回一个新的动态数组。</p><p>同时，在过程中发现存在<strong>进位</strong>情况，数组的一个位置只能存 0-9 这十个整数，当尾数 &#x3D; 9 时，就出现进位情况，那么前一位数字也需要做加法，甚至是出现对 [9,…,9] 做加法的情况，返回的数组就是 [1,0,…,0]，比给的数组长度还多一个。这样的话就需要好好讨论一下了：</p><ul><li>不能简单的认为仅仅只需要改变数组最后一位，可能每一位都需要改变</li><li>顺序遍历动态数组可能难以实现<strong>每位数字都加一的情况</strong> —— 不好在数组最前面添加内容（存疑，可能是我太废了）</li><li>那就需要先倒转数组，然后根据情况来<strong>加一</strong>，使用 <code>vec.push()</code> 添加在数组尾部，情况有以下几种：<ol><li>仅加一：<strong>个位部分</strong>根据题目要求 + 1；其他的数字因为前一位的进位，而需要做加法</li><li>加一，进位：数字是 9 时，+ 1 后要进位</li><li>保留，不加一，不进位：<strong>除个位部分</strong>没有进位</li><li>是 9…9 这样全是九时，就需要多一个位数。</li></ol></li></ul><p>所以，我的思路：</p><ol><li>先创建一个空动态数组</li><li>然后将 digits 数组反过来，并根据情况做加法等等</li><li>如果数组全是 9 时，还需要加一位</li><li>最后再创建一个新的数组，等于处理过的数组反过来</li><li>返回结果</li></ol><p>结束。</p><p>屁，想了下，动态数组可以使用 <code>Vec::insert()</code> 函数在任意位置插入元素，那么简单修改一下：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_one</span>(digits: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">add</span> = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = digits.<span class="hljs-title function_ invoke__">len</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; len];        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..len &#123;            <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = len - i - <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> digits[index] == <span class="hljs-number">9</span> &amp;&amp; add &#123;                result[index] = <span class="hljs-number">0</span>;                add = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> digits[index] &lt; <span class="hljs-number">9</span> &amp;&amp; add &#123;                result[index] = digits[index] + <span class="hljs-number">1</span>;                add = <span class="hljs-literal">false</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                result[index] = digits[index];            &#125;        &#125;        <span class="hljs-keyword">if</span> add &#123;            result.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        &#125;        result    &#125;&#125;</code></pre></div><div class="note note-info">            <p>还有这个可以学习。<br>在 Rust 中，.rev()是一个方法，它返回一个反转（reverse）迭代器。该方法可以应用于任何实现了 std::iter::Iterator trait 的对象。调用 .rev() 方法后，将返回一个产生与原始迭代器相同元素，但顺序相反的迭代器。在给定示例代码中，.rev() 用于将索引从大到小遍历。</p><p>在这个例子中，for i in (0..digits.len()).rev() 意味着 i 变量将从 digits 中最后一个元素的索引开始（即 digits.len() - 1），并递减到第一个元素的索引（即 0）。</p><p>有个骚逼炫技，真他妈的骚，代码格式也不好好搞：</p><ul><li>是指除了题目给定的有指令的行数。</li><li>用的是“数 9 法”，先找出从右到左第一个非9的下标i，然后懂的都懂。</li><li>None表示全都是 9！</li><li><code>[a,b,c].concat()</code> 表示将 a, b ,c 三个切片连城一个Vec数组。</li></ul><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_one</span>(digits: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;        <span class="hljs-keyword">match</span> digits            .<span class="hljs-title function_ invoke__">iter</span>()            .<span class="hljs-title function_ invoke__">enumerate</span>()            .<span class="hljs-title function_ invoke__">rev</span>()            .<span class="hljs-title function_ invoke__">skip_while</span>(|(i, &amp;x)| <span class="hljs-number">9</span> == x)            .<span class="hljs-title function_ invoke__">next</span>()        &#123;            <span class="hljs-title function_ invoke__">Some</span>((i, &amp;a)) =&gt; [                digits[..i]                    .<span class="hljs-title function_ invoke__">iter</span>()                    .<span class="hljs-title function_ invoke__">map</span>(|x| x.<span class="hljs-title function_ invoke__">clone</span>())                    .collect::&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;()                    .<span class="hljs-title function_ invoke__">as_slice</span>(),                <span class="hljs-built_in">vec!</span>[digits[i] + <span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">as_slice</span>(),                <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; digits.<span class="hljs-title function_ invoke__">len</span>() - (i + <span class="hljs-number">1</span>)].<span class="hljs-title function_ invoke__">as_slice</span>(),            ]            .<span class="hljs-title function_ invoke__">concat</span>(),            <span class="hljs-literal">None</span> =&gt; [<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">as_slice</span>(), <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; digits.<span class="hljs-title function_ invoke__">len</span>()].<span class="hljs-title function_ invoke__">as_slice</span>()].<span class="hljs-title function_ invoke__">concat</span>(),        &#125;    &#125;&#125;</code></pre></div>          </div><h2 id="Rust-小练习-——-rustlings"><a href="#Rust-小练习-——-rustlings" class="headerlink" title="Rust 小练习 —— rustlings"></a>Rust 小练习 —— rustlings</h2><p>项目地址：<a href="https://github.com/rust-lang/rustlings">rust-lang&#x2F;rustlings: Small exercises to get you used to reading and writing Rust code!</a></p><p>中文项目地址：<a href="https://github.com/rust-lang-cn/rustlings-cn">rust-lang-cn&#x2F;rustlings-cn: Rustlings 非官方中文翻译(Rustlings unofficial chinese verion)。🦀 让你熟悉阅读和编写 Rust 代码的小练习。源仓库：https://github.com/rust-lang/rustlings</a></p><p>项目作用：Rust 小练习，Rust 官方推出的交互式练习工具，边阅读、修改和运行代码，边学习概念。</p><h3 id="简单开始"><a href="#简单开始" class="headerlink" title="简单开始"></a>简单开始</h3><h3 id="难题记录"><a href="#难题记录" class="headerlink" title="难题记录"></a>难题记录</h3><h4 id="exercises-x2F-error-handling-x2F-errors6-rs"><a href="#exercises-x2F-error-handling-x2F-errors6-rs" class="headerlink" title="exercises&#x2F;error_handling&#x2F;errors6.rs"></a>exercises&#x2F;error_handling&#x2F;errors6.rs</h4><p>题目链接：<a href="https://github.com/rust-lang/rustlings/blob/main/exercises/error_handling/errors6.rs">exercises&#x2F;error_handling&#x2F;errors6.rs</a><br>非官方翻译题目链接：<a href="https://github.com/rust-lang-cn/rustlings-cn/blob/main/exercises/error_handling/errors6.rs">exercises&#x2F;error_handling&#x2F;errors6.rs</a></p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// errors6.rs</span><span class="hljs-comment">// 使用能够捕获所有错误的类型，比如说 `Box&lt;dyn error::Error&gt;`，在库代码中是不推荐的，</span><span class="hljs-comment">// 其调用者可能想要基于错误的内容做决定，而不是将错误打印出来或向前传播。</span><span class="hljs-comment">// 这里，我们定义了一个自定义错误类型，使调用者在我们的函数返回错误时做判断成为可能。</span><span class="hljs-comment">// 执行 `rustlings hint errors6` 或在观察模式下使用 `hint` 子命令来获取提示。</span><span class="hljs-comment">// I AM NOT DONE</span><span class="hljs-keyword">use</span> std::num::ParseIntError;<span class="hljs-comment">// 这是一个我们将会在 `parse_pos_nonzero()` 用到的自定义错误类型。</span><span class="hljs-meta">#[derive(PartialEq, Debug)]</span><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ParsePosNonzeroError</span> &#123;    <span class="hljs-title function_ invoke__">Creation</span>(CreationError),    <span class="hljs-title function_ invoke__">ParseInt</span>(ParseIntError),&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">ParsePosNonzeroError</span> &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_creation</span>(err: CreationError) <span class="hljs-punctuation">-&gt;</span> ParsePosNonzeroError &#123;        ParsePosNonzeroError::<span class="hljs-title function_ invoke__">Creation</span>(err)    &#125;    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 在这里添加另一个错误转换函数。</span>    <span class="hljs-comment">// fn from_parseint...</span>&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pos_nonzero</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 改变这里以返回一个适当的错误，而不是在</span>    <span class="hljs-comment">// `parse()` 返回错误时发生 panic。</span>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i64</span> = s.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(x).<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_creation)&#125;<span class="hljs-comment">// 不要改变这行以下的任何东西。</span><span class="hljs-meta">#[derive(PartialEq, Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PositiveNonzeroInteger</span>(<span class="hljs-type">u64</span>);<span class="hljs-meta">#[derive(PartialEq, Debug)]</span><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CreationError</span> &#123;    Negative,    Zero,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">PositiveNonzeroInteger</span> &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, CreationError&gt; &#123;        <span class="hljs-keyword">match</span> value &#123;            x <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(CreationError::Negative),            x <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(CreationError::Zero),            x =&gt; <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">PositiveNonzeroInteger</span>(x <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>)),        &#125;    &#125;&#125;<span class="hljs-meta">#[cfg(test)]</span><span class="hljs-keyword">mod</span> test &#123;    <span class="hljs-keyword">use</span> super::*;    <span class="hljs-meta">#[test]</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_parse_error</span>() &#123;        <span class="hljs-comment">// 我们不能构造一个 ParseIntError，所以只能进行模式匹配。</span>        <span class="hljs-built_in">assert!</span>(matches!(            <span class="hljs-title function_ invoke__">parse_pos_nonzero</span>(<span class="hljs-string">&quot;not a number&quot;</span>),            <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">ParseInt</span>(_))        ));    &#125;    <span class="hljs-meta">#[test]</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_negative</span>() &#123;        <span class="hljs-built_in">assert_eq!</span>(            <span class="hljs-title function_ invoke__">parse_pos_nonzero</span>(<span class="hljs-string">&quot;-555&quot;</span>),            <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">Creation</span>(CreationError::Negative))        );    &#125;    <span class="hljs-meta">#[test]</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_zero</span>() &#123;        <span class="hljs-built_in">assert_eq!</span>(            <span class="hljs-title function_ invoke__">parse_pos_nonzero</span>(<span class="hljs-string">&quot;0&quot;</span>),            <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">Creation</span>(CreationError::Zero))        );    &#125;    <span class="hljs-meta">#[test]</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_positive</span>() &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);        <span class="hljs-built_in">assert!</span>(x.<span class="hljs-title function_ invoke__">is_ok</span>());        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">parse_pos_nonzero</span>(<span class="hljs-string">&quot;42&quot;</span>), <span class="hljs-title function_ invoke__">Ok</span>(x.<span class="hljs-title function_ invoke__">unwrap</span>()));    &#125;&#125;</code></pre></div><p>本题主要修改两处地方，即 <code>TODO</code> ：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ParsePosNonzeroError</span> &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_creation</span>(err: CreationError) <span class="hljs-punctuation">-&gt;</span> ParsePosNonzeroError &#123;        ParsePosNonzeroError::<span class="hljs-title function_ invoke__">Creation</span>(err)    &#125;    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 在这里添加另一个错误转换函数。</span>    <span class="hljs-comment">// fn from_parseint...</span>&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pos_nonzero</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 改变这里以返回一个适当的错误，而不是在</span>    <span class="hljs-comment">// `parse()` 返回错误时发生 panic。</span>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i64</span> = s.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(x).<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_creation)&#125;</code></pre></div><p>解题思路：</p><p>根据测试函数中的内容，调用的 <code>parse_pos_nonzero()</code> 函数，接受一个字符串参数，返回 <code>Ok</code> 或 <code>Err</code> 的情况，且 <code>Err</code> 还有不同的类型，如：</p><ul><li><code>Err(ParsePosNonzeroError::Creation(CreationError::Negative))</code></li><li><code>Err(ParsePosNonzeroError::Creation(CreationError::Zero))</code></li><li><code>Err(ParsePosNonzeroError::ParseInt(_))</code></li></ul><p>共三种类型。</p><p>第一个 <code>TODO</code> 需要实现<strong>另一个错误转换函数</strong> —— <code>from_parseint()</code>，转换为 <code>ParsePosNonzeroError::ParseInt(err)</code> 类型。</p><p>参考前文的 <code>from_creation()</code> 方法:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_creation</span>(err: CreationError) <span class="hljs-punctuation">-&gt;</span> ParsePosNonzeroError &#123;        ParsePosNonzeroError::<span class="hljs-title function_ invoke__">Creation</span>(err)&#125;</code></pre></div><p>照葫芦画瓢即可：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_parseint</span>(err: ParseIntError) <span class="hljs-punctuation">-&gt;</span> ParsePosNonzeroError &#123;    ParsePosNonzeroError::<span class="hljs-title function_ invoke__">ParseIntError</span>(err)&#125;</code></pre></div><p>第二个 <code>TODO</code> 处检查发现是没有返回 <code>Err(ParsePosNonzeroError::ParseInt(_))</code>，即接收 <code>&quot;not a number&quot;</code> 等非数字的字符串时，无法正常转换成整数，需要返回一个错误转换的错误信息。</p><p>而原题中可正常转换 <code>&quot;123&quot;</code>、<code>&quot;0&quot;</code>、<code>&quot;-555&quot;</code> 等正常的整数情况从而返回：</p><ul><li><code>Ok(PositiveNonzeroInteger(u64))</code></li><li><code>Err(ParsePosNonzeroError::Creation(CreationError::Zero))</code></li><li><code>Err(ParsePosNonzeroError::Creation(CreationError::Negative))</code></li></ul><p>三个 <code>Ok</code> 和 <code>Err</code> 的信息。</p><p>未修改的代码的测试结果为：</p><div class="code-wrapper"><pre><code class="hljs rust">thread <span class="hljs-symbol">&#x27;test</span>::test_parse_error&#x27; panicked at <span class="hljs-symbol">&#x27;called</span> `<span class="hljs-type">Result</span>::<span class="hljs-title function_ invoke__">unwrap</span>()` on an `<span class="hljs-literal">Err</span>` value: ParseIntError &#123; kind: InvalidDigit &#125;&#x27;,</code></pre></div><p>解释为：测试函数 <code>test_parse_error</code> 调用 <code>parse_pos_nonzero</code> 函数时，字符串转换出错 —— 调用 <code>Result::unwrap()</code> 函数时接收了一个 <code>Err(ParseIntError::InvalidDigit)</code>，这就出错了:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_parse_error</span>() &#123;    <span class="hljs-built_in">assert!</span>(matches!(        <span class="hljs-title function_ invoke__">parse_pos_nonzero</span>(<span class="hljs-string">&quot;not a number&quot;</span>),        <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">ParseInt</span>(_))    ));&#125;</code></pre></div><p>查阅 Rust 官方标准库 —— <code>Struct std::num::ParseIntError</code>，地址：<a href="https://rustwiki.org/zh-CN/std/num/struct.ParseIntError.html">Struct std::num::ParseIntError | 中文</a>，并查看其<a href="https://rustwiki.org/zh-CN/src/core/num/error.rs.html#69-71">源码内容</a>，可知 <code>ParseIntError::InvalidDigit</code> 表示<strong>在其上下文中包含无效数字</strong> —— 除其他原因外，当解析包含非 ASCII 字符的字符串时，将创建这个变体。当 <code>+</code> 或 <code>-</code> 单独放置在字符串中或放置在数字中间时，也会创建此变体。</p><p>而 <code>std::result::Result</code> 的 <code>unwrap()</code> 方法是返回包含 <code>self</code> 值的包含的 <code>Ok</code> 值:</p><div class="code-wrapper"><pre><code class="hljs txt">返回包含 self 值的包含的 Ok 值。由于此函数可能为 panic，因此通常不建议使用该函数。 相反，更喜欢使用模式匹配并显式处理 Err 大小写，或者调用 unwrap_or，unwrap_or_else 或 unwrap_or_default。Panics如果该值为 Err，就会出现 Panics，并由 Err 的值提供 panic 消息。</code></pre></div><p>所以，不应当使用 <code>unwrap()</code> 方法了。可以使用<strong>匹配</strong>或者 <code>map_err()</code> 方法进行处理。</p><div class="code-wrapper"><pre><code class="hljs txt">pub fn map_err&lt;F, O&gt;(self, op: O) -&gt; Result&lt;T, F&gt;通过对包含的 Err 值应用函数，将 Ok 值 Maps 转换为 Result&lt;T, F&gt;，而保持 Ok 值不变。此函数可用于在处理错误时传递成功的结果。</code></pre></div><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><p>故而对于 <code>parse_pos_error()</code> 函数的修改方案有如下几种：</p><p><strong>分情况进行嵌套匹配</strong></p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pos_nonzero</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;    <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">parse</span>() &#123;        <span class="hljs-title function_ invoke__">Ok</span>(x) =&gt; &#123;            <span class="hljs-keyword">match</span> PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(x) &#123;                <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">PositiveNonzeroInteger</span>(x)) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">PositiveNonzeroInteger</span>(x)),                <span class="hljs-title function_ invoke__">Err</span>(CreationError::Zero) =&gt; <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">from_creation</span>(CreationError::Zero)),                <span class="hljs-title function_ invoke__">Err</span>(CreationError::Negative) =&gt; <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">from_creation</span>(CreationError::Negative)),            &#125;        &#125;,        <span class="hljs-title function_ invoke__">Err</span>(ParseIntError) =&gt; <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">from_parseint</span>(ParseIntError)),    &#125;&#125;</code></pre></div><p>或者稍微简化一下代码 —— 使用 <code>message</code> 表示 <code>Ok</code> 或 <code>Err</code> 中的内容：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pos_nonzero</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;    <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">parse</span>() &#123;        <span class="hljs-title function_ invoke__">Ok</span>(x) =&gt; &#123;            <span class="hljs-keyword">match</span> PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(x) &#123;                <span class="hljs-title function_ invoke__">Ok</span>(message) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(message),                <span class="hljs-title function_ invoke__">Err</span>(message) =&gt; <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">from_creation</span>(message)),            &#125;        &#125;,        <span class="hljs-title function_ invoke__">Err</span>(message) =&gt; <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">from_parseint</span>(message)),    &#125;&#125;</code></pre></div><p><strong>使用 <code>map_err()</code> 和 嵌套匹配</strong></p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pos_nonzero</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;    <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">parse</span>() &#123;        <span class="hljs-title function_ invoke__">Ok</span>(x) =&gt; PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(x).<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_creation),        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">from_parseint</span>(err)),    &#125;&#125;</code></pre></div><p>或者是直接返回 <code>Err(ParsePosNonzeroError::ParseInt(err))</code>:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pos_nonzero</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;    <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">parse</span>() &#123;        <span class="hljs-title function_ invoke__">Ok</span>(x) =&gt; PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(x).<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_creation),        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-title function_ invoke__">Err</span>(ParsePosNonzeroError::<span class="hljs-title function_ invoke__">ParseInt</span>(err)),    &#125;&#125;</code></pre></div><p><strong>第三种方法，使用 <code>?</code> 操作符使函数提前返回和使用 <code>map_err()</code> 方法</strong></p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pos_nonzero</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i64</span> = s.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_parseint)?;    PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(x).<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_creation)&#125;</code></pre></div><p>简单说就是，当时转换失败时，使用 map_err() 方法处理 <code>ParsePosNonzeroError::ParseInt(err)</code> 并使用 <code>?</code> 操作符提前返回；正常转换后，再使用 <code>PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)</code> 处理正常的结果。</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux 桌面环境的一些设置</title>
    <link href="/arch-kde-plasma/"/>
    <url>/arch-kde-plasma/</url>
    
    <content type="html"><![CDATA[<h3 id="discover"><a href="#discover" class="headerlink" title="discover"></a>discover</h3><p>Arch Linux 安装 kde 桌面环境后，Discover 软件商店虽然能够打开应用，但是没有软件信息，无法在其中安装软件，这是因为少了一些软件包。</p><blockquote><p>Discover 是 KDE 桌面环境中的软件包管理器，可以方便地搜索、安装和卸载软件包。</p></blockquote><p>打开终端，安装包：</p><div class="code-wrapper"><pre><code class="hljs zsh">sudo pacman -S archlinux-appstream-data packagekit-qt5 packagekit flatpak fwupd# yay -S archlinux-appstream-data packagekit-qt5 packagekit flatpak fwupd</code></pre></div><p><code>ackagekit-qt5</code> —— 安装以解决 Discover 不显示任何程序的问题。</p><p>KDE Discover 中已实现了新的 fwupd 后端以进行固件更新。</p><p><code>fwupd</code> 是一个进行设备固件更新的简单守护程序，虽然是为桌面计算机设计，但是同样也支持手机和服务器。</p><p><code>flatpak</code> —— 是一个用来管理应用和应用所使用的运行时的工具。</p><p>在 Flatpak 模型中，应用的构建和分发不依赖其主系统，并且它们在运行时一定程度上独立于主系统（’沙箱化’）。Flatpak 使用 OSTree 以分发和部署数据。它使用的仓库是 OSTree 仓库并且可以用 ostree 的工具来操作。已安装的运行时和应用都已经过 OSTree 检出。</p><h3 id="bluetooth"><a href="#bluetooth" class="headerlink" title="bluetooth"></a>bluetooth</h3><p>如果安装完 Arch Linux 想听歌，带着自己酷炫的蓝牙耳机听歌，但是仔细一看，蓝牙怎么没有，这时就需要将蓝牙服务安装过来。</p><p>首先先安装蓝牙并启动蓝牙服务：</p><div class="code-wrapper"><pre><code class="hljs zsh">sudo pacman -S bluez bluez-utils# yay -S bluez bluez-utils</code></pre></div><p>两个软件包，前者提供蓝牙协议栈，后者提供 <code>bluetoothctl</code> 实用程序。</p><p><code>bluetoothctl</code> — 在 shell 中配对设备是最简单可靠的方法之一。</p><p>启动服务：</p><div class="code-wrapper"><pre><code class="hljs zsh">sudo systemctl start bluetooth#sudo systemctl start bluetooth.service</code></pre></div><p>并设计开机自启：</p><div class="code-wrapper"><pre><code class="hljs zsh">sudo systemctl enable bluetooth# sudo systemctl enable bluetooth.service</code></pre></div><p>检查蓝牙服务状态：</p><div class="code-wrapper"><pre><code class="hljs zsh">systemctl status bluetooth# systemctl statss bluetooth.service</code></pre></div><p>还可以安装蓝牙图形化界面 — <code>Bluedevil</code> — KDE 的蓝牙工具。如果 Dolphin 和系统托盘里没有蓝牙图标，就在系统托盘选项里启用，或者添加一个挂件。点击图标或在 KDE 系统设置里都可以配置蓝牙:</p><div class="code-wrapper"><pre><code class="hljs zsh">sudo pacman -S bluedevil# yay -S bluedevil</code></pre></div><p>至此之后，只要是不出问题，就可以直接在系统设置中连接蓝牙，并进行使用。</p><p>至于还有其他的问题，我之前遇到过，但是没有及时记录下来，如今想进行记录，但是记不清了。</p><div class="note note-danger">            <p><strong>To Be Continued:</strong></p><p>还没写完涅。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch Linux</tag>
      
      <tag>KDE</tag>
      
      <tag>Plasma</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Yay 替换 Pacman 作为更加好使的包管理器</title>
    <link href="/yay-instead-pacman/"/>
    <url>/yay-instead-pacman/</url>
    
    <content type="html"><![CDATA[<h2 id="What-is-Yay"><a href="#What-is-Yay" class="headerlink" title="What is Yay"></a>What is Yay</h2><p>Yay 是一个基于 Arch Linux 的 AUR (Arch User Repository) 前端，它提供了一些额外的功能和用户友好的界面，使用户可以更方便地管理和安装软件包。与 Arch Linux 的默认包管理器 Pacman 不同，Yay 支持 AUR 软件包的构建和安装，这些软件包通常由社区维护，可以在 Arch Linux 官方软件源之外找到。</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><h3 id="Install-git"><a href="#Install-git" class="headerlink" title="Install git"></a>Install git</h3><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S git</span></code></pre></div><h3 id="Install-yay"><a href="#Install-yay" class="headerlink" title="Install yay"></a>Install yay</h3><h4 id="clone-yay-repo"><a href="#clone-yay-repo" class="headerlink" title="clone yay repo"></a>clone yay repo</h4><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://aur.archlinux.org/yay.git</code></pre></div><h4 id="build-yay"><a href="#build-yay" class="headerlink" title="build yay"></a>build yay</h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> yaymakepkg -sri</code></pre></div><div class="note note-info">            <p><strong>可能出现的错误</strong>：</p><h4 id="缺少-strip"><a href="#缺少-strip" class="headerlink" title="缺少 strip"></a>缺少 strip</h4><div class="code-wrapper"><pre><code class="hljs bash">$ makepkg -sri==&gt; 错误： Cannot find the strip binary required <span class="hljs-keyword">for</span> object file stripping.</code></pre></div><p>这个错误提示是由于在执行 <code>makepkg</code> 编译时缺少 <code>strip</code> 命令，<code>strip</code> 是一个用于剥离二进制文件中不必要的调试信息的工具，用于减小可执行文件的体积。</p><p>要解决这个问题，你需要安装 <code>binutils</code> 包，这个包里包含了 <code>strip</code> 工具。可以使用以下命令安装：</p><p>对于 <code>Arch Linux</code> 或者 <code>Manjaro</code> 等基于 <code>Arch Linux</code> 的发行版：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -S binutils</span></code></pre></div><p>安装完成后，重新执行 <code>makepkg</code> 命令应该就可以成功了。</p><h4 id="没有-go"><a href="#没有-go" class="headerlink" title="没有 go"></a>没有 go</h4><div class="code-wrapper"><pre><code class="hljs bash">$ makepkg -sri==&gt; 正在创建软件包：yay 11.3.2-1 (2023年03月13日 21:44:13)==&gt; 正在检查运行时依赖关系...==&gt; 正在检查编译时依赖关系==&gt; 正在安装缺失的依赖关系...错误：未找到目标：go&gt;=1.17==&gt; 错误： <span class="hljs-string">&#x27;pacman&#x27;</span> 无法安装缺失的依赖关系。==&gt; 缺失依赖关系：  -&gt; go&gt;=1.17==&gt; 错误： 无法解决所有的依赖关系。</code></pre></div><p>这个错误是提示缺少 go 编译器的版本大于等于 <code>1.17</code>。需要先安装 go 编译器，然后再编译 yay。</p><p>可以尝试使用 <code>pacman</code> 命令安装 go，例如：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo pacman -S go</code></pre></div><p>查看 go 版本；</p><div class="code-wrapper"><pre><code class="hljs bash">go version</code></pre></div>          </div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch Linux</tag>
      
      <tag>Yay</tag>
      
      <tag>Pacman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows10 安装 MSYS2</title>
    <link href="/windows10-msys2-installation/"/>
    <url>/windows10-msys2-installation/</url>
    
    <content type="html"><![CDATA[<h2 id="1-MSYS2-是什么"><a href="#1-MSYS2-是什么" class="headerlink" title="1. MSYS2 是什么"></a>1. MSYS2 是什么</h2><p><strong><a href="https://www.msys2.org/">MSYS2</a></strong> 是一个工具和库的集合，为用户提供一个易于使用的环境来构建、安装和运行本机 Windows 软件。</p><p>它包括一个名为 <a href="https://mintty.github.io/">mintty</a> 的<code>命令行终端</code>、<code>bash</code>、<code>版本控制系统</code>如 <code>git</code> 和 <code>subversion</code>、<code>工具</code>如 <code>tar</code> 和 <code>awk</code>，甚至构建系统如 <code>autotools</code>，都是基于修改版的 <a href="https://cygwin.com/">Cygwin</a> 实现的。尽管其中一些核心部分基于 <code>Cygwin</code>，但 <code>MSYS2</code> 的主要重点是为本机 <code>Windows</code> 软件提供构建环境，<code>Cygwin</code> 使用的部分被保持在最小限度。</p><p>为了提供易于安装软件包的方式以及保持其更新，MSYS2 提供了一个的包管理系统 —— <a href="https://wiki.archlinux.org/index.php/pacman">Pacman</a>。</p><p><strong><a href="https://www.msys2.org/">MSYS2</a></strong> 提供了最新的 <code>GCC</code>、<code>mingw-w64</code>、<code>CPython</code>、<code>CMake</code>、<code>Meson</code>、<code>OpenSSL</code>、<code>FFmpeg</code>、<code>Rust</code>、<code>Ruby</code> 等本地构建工具。</p><div class="note note-info">            <p><strong>MSYS2 官方网站介绍</strong>：</p><p><strong><a href="https://www.msys2.org/">MSYS2</a></strong> is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software.</p><p>It consists of a command line terminal called <a href="https://mintty.github.io/">mintty</a>, bash, version control systems like git and subversion, tools like tar and awk and even build systems like autotools, all based on a modified version of Cygwin. Despite some of these central parts being based on <a href="https://cygwin.com/">Cygwin</a>, the main focus of MSYS2 is to provide a build environment for native Windows software and the Cygwin-using parts are kept at a minimum. MSYS2 provides up-to-date native builds for GCC, mingw-w64, CPython, CMake, Meson, OpenSSL, FFmpeg, Rust, Ruby, just to name a few.</p><p>To provide easy installation of packages and a way to keep them updated it features a package management system called <a href="https://wiki.archlinux.org/index.php/pacman">Pacman</a>, which should be familiar to Arch Linux users. It brings many powerful features such as dependency resolution and simple complete system upgrades, as well as straight-forward and reproducible package building. Our package repository contains <a href="https://packages.msys2.org/base">more than 2800 pre-built packages</a> ready to install.</p><p>For more details see ‘<a href="https://www.msys2.org/docs/what-is-msys2/">What is MSYS2?</a>‘ which also compares MSYS2 to other software distributions and development environments like <a href="https://cygwin.com/">Cygwin</a>, <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>, <a href="https://chocolatey.org/">Chocolatey</a>, <a href="https://scoop.sh/">Scoop</a>, … and ‘<a href="https://www.msys2.org/docs/who-is-using-msys2/">Who Is Using MSYS2?</a>‘ to see which projects are using MSYS2 and what for.</p>          </div><h2 id="2-MSYS2-的安装"><a href="#2-MSYS2-的安装" class="headerlink" title="2. MSYS2 的安装"></a>2. MSYS2 的安装</h2><p>就直接下载文件 —— <a href="https://github.com/msys2/msys2-installer/releases/download/2023-01-27/msys2-x86_64-20230127.exe">msys2-x86_64-20230127.exe</a>。</p><blockquote><p>上面链接可能不是最新的，建议去 MSYS2 官网下载 —— 指个路 —— <a href="https://www.msys2.org/#installation">MSYS2 Installation</a></p><p>建议使用魔法下载，不然容易出问题 —— 指下不下来。</p></blockquote><p>下载完成后，点击运行，然后一路点击，需要修改设置的话，自行注意界面就行了。</p><p>安装完成后，启动 <code>MSYS2</code> 会是一个单独的 <code>terminal</code>，我们可以将其使用 <code>Windows Terminal</code> 打开 <code>MSYS2</code>。</p><h2 id="3-pacman-更换源"><a href="#3-pacman-更换源" class="headerlink" title="3. pacman 更换源"></a>3. pacman 更换源</h2><p>一般的，pacman 的镜像源文件位置位于 <code>/etc/pacman.d/</code>，所以咱直接去看：</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /etc/pacman.dgnupg               mirrorlist.clang64  mirrorlist.mingw32  mirrorlist.msysmirrorlist.clang32  mirrorlist.mingw    mirrorlist.mingw64  mirrorlist.ucrt64</code></pre></div><p>哈哈，镜像源文件还挺多，对应着不同的环境。</p><p>以 <code>mirrorlist.ucrt64</code> 为例，进行修改，<strong>咱主要使用清华源和科大源，主要是网速问题，那个快哪个好</strong>：</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /etc/pacman.d/mirrorlist.ucrt64<span class="hljs-comment"># See https://www.msys2.org/dev/mirrors</span><span class="hljs-comment">## Primary</span>Server = https://mirror.msys2.org/mingw/ucrt64/Server = https://repo.msys2.org/mingw/ucrt64/<span class="hljs-comment">## Tier 1</span>Server = https://mirror.umd.edu/msys2/mingw/ucrt64/Server = https://mirror.yandex.ru/mirrors/msys2/mingw/ucrt64/Server = https://download.nus.edu.sg/mirror/msys2/mingw/ucrt64/Server = https://ftp.acc.umu.se/mirror/msys2.org/mingw/ucrt64/Server = https://ftp.nluug.nl/pub/os/windows/msys2/builds/mingw/ucrt64/Server = https://ftp.osuosl.org/pub/msys2/mingw/ucrt64/Server = https://mirror.internet.asn.au/pub/msys2/mingw/ucrt64/Server = https://mirror.selfnet.de/msys2/mingw/ucrt64/Server = https://mirror.ufro.cl/msys2/mingw/ucrt64/Server = https://mirrors.dotsrc.org/msys2/mingw/ucrt64/Server = https://mirrors.bfsu.edu.cn/msys2/mingw/ucrt64/Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/ucrt64/Server = https://mirrors.ustc.edu.cn/msys2/mingw/ucrt64/Server = https://mirror.nju.edu.cn/msys2/mingw/ucrt64/Server = https://repo.extreme-ix.org/msys2/mingw/ucrt64/Server = https://mirrors.hit.edu.cn/msys2/mingw/ucrt64/Server = https://mirror.clarkson.edu/msys2/mingw/ucrt64/Server = https://quantum-mirror.hu/mirrors/pub/msys2/mingw/ucrt64/Server = https://mirror2.sandyriver.net/pub/software/msys2/mingw/ucrt64/Server = https://mirror.archlinux.tw/MSYS2/mingw/ucrt64/<span class="hljs-comment">## Tier 2</span>Server = https://fastmirror.pp.ua/msys2/mingw/ucrt64/Server = https://ftp.cc.uoc.gr/mirrors/msys2/mingw/ucrt64/Server = https://mirror.jmu.edu/pub/msys2/mingw/ucrt64/Server = https://mirrors.piconets.webwerks.in/msys2-mirror/mingw/ucrt64/Server = https://www2.futureware.at/~nickoe/msys2-mirror/mingw/ucrt64/Server = https://mirrors.sjtug.sjtu.edu.cn/msys2/mingw/ucrt64/Server = https://mirrors.bit.edu.cn/msys2/mingw/ucrt64/Server = https://repo.casualgamer.ca/mingw/ucrt64/Server = https://mirrors.aliyun.com/msys2/mingw/ucrt64/Server = https://mirror.iscas.ac.cn/msys2/mingw/ucrt64/Server = https://mirrors.tencent.com/msys2/mingw/ucrt64/</code></pre></div><p>基本上所有镜像源都有，不过弱水三千咱只取一瓢，就选<strong>科大源</strong>吧，原因呀。就是快：</p><p>把除科大源的都给注释掉就行：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># See https://www.msys2.org/dev/mirrors</span><span class="hljs-comment">## Primary</span><span class="hljs-comment"># Server = https://mirror.msys2.org/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://repo.msys2.org/mingw/ucrt64/</span><span class="hljs-comment">## Tier 1</span><span class="hljs-comment"># # Server = https://mirror.umd.edu/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirror.yandex.ru/mirrors/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://download.nus.edu.sg/mirror/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://ftp.acc.umu.se/mirror/msys2.org/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://ftp.nluug.nl/pub/os/windows/msys2/builds/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://ftp.osuosl.org/pub/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirror.internet.asn.au/pub/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirror.selfnet.de/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirror.ufro.cl/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirrors.dotsrc.org/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirrors.bfsu.edu.cn/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/ucrt64/</span>Server = https://mirrors.ustc.edu.cn/msys2/mingw/ucrt64/<span class="hljs-comment"># Server = https://mirror.nju.edu.cn/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://repo.extreme-ix.org/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirrors.hit.edu.cn/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirror.clarkson.edu/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://quantum-mirror.hu/mirrors/pub/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirror2.sandyriver.net/pub/software/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirror.archlinux.tw/MSYS2/mingw/ucrt64/</span><span class="hljs-comment">## Tier 2</span><span class="hljs-comment"># Server = https://fastmirror.pp.ua/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://ftp.cc.uoc.gr/mirrors/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirror.jmu.edu/pub/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirrors.piconets.webwerks.in/msys2-mirror/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://www2.futureware.at/~nickoe/msys2-mirror/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirrors.sjtug.sjtu.edu.cn/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirrors.bit.edu.cn/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://repo.casualgamer.ca/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirrors.aliyun.com/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirror.iscas.ac.cn/msys2/mingw/ucrt64/</span><span class="hljs-comment"># Server = https://mirrors.tencent.com/msys2/mingw/ucrt64/</span></code></pre></div><p>其他的镜像源文件以此重复上述注释就行，因为无论在哪个环境模式下执行 <code>pacman -Syyu</code> 等等之类的命令都是同步更新所有环境的软件包数据库。</p><p>所以所以，统统换源。</p><p>然后：</p><div class="code-wrapper"><pre><code class="hljs bash">pacman -Syyu</code></pre></div><h2 id="4-MSYS2-中的环境"><a href="#4-MSYS2-中的环境" class="headerlink" title="4. MSYS2 中的环境"></a>4. MSYS2 中的环境</h2><p>当咱们安装完 MSYS2 后就发现好几个应用，MSYS2 带有不同的后缀如 <code>CLANG64</code>、<code>CLANG32</code>、<code>CLANGARM64</code>、<code>MINGW32</code>、<code>MINGW64</code>、<code>MSYS</code>、<code>UCRT64</code>等。</p><p>都是些啥，区别是什么。</p><p>MSYS2 提供了不同的<strong>环境&#x2F;子系统</strong>，首先用户需要决定要使用哪个环境。</p><p>这些环境之间的区别主要在于<strong>环境变量</strong>、<strong>默认编译器</strong>&#x2F;<strong>链接器</strong>、<strong>架构</strong>、使用的<strong>系统库</strong>等方面。</p><ul><li><code>environment variables</code>：环境变量</li><li><code>default compilers/linkers</code>：默认编译器&#x2F;链接器</li><li><code>architecture</code>：架构</li><li><code>system libraries used etc</code>：使用的系统库</li></ul><p><strong>如果不确定，建议选择 <code>UCRT64</code> 环境。</strong></p><p>MSYS 环境包含基于类 <code>Unix/cygwin</code> 的工具，存储在 <code>/usr</code> 目录下，并且它是特殊的，因为它始终处于活动状态。</p><p>所有其他环境都继承自 <code>MSYS</code> 环境并在其基础上添加各种功能。</p><p>例如，在 <code>UCRT64</code> 环境中，<code>$PATH</code> 变量以 <code>/ucrt64/bin:/usr/bin</code> 开头，因此可以使用所有 <code>ucrt64</code> 和 <code>msys</code> 工具。</p><p><strong>各环境及其细节的简单展示</strong>：</p><table><thead><tr><th align="center"></th><th align="center">Name</th><th align="center">Prefix</th><th align="center">Toolchain</th><th align="center">Architecture</th><th align="center">C Library</th><th align="center">C++ Library</th></tr></thead><tbody><tr><td align="center"><img src="https://www.msys2.org/docs/msys.png" width="30" height="30"></td><td align="center">MSYS</td><td align="center"><code>/usr</code></td><td align="center">gcc</td><td align="center">x86_64</td><td align="center">cygwin</td><td align="center">libstdc++</td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/ucrt64.png" width="30" height="30"></td><td align="center">UCRT64</td><td align="center"><code>/ucrt64</code></td><td align="center">gcc</td><td align="center">x86_64</td><td align="center">ucrt</td><td align="center">libstdc++</td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/clang64.png" width="30" height="30"></td><td align="center">CLANG64</td><td align="center"><code>/clang64</code></td><td align="center">llvm</td><td align="center">x86_64</td><td align="center">ucrt</td><td align="center">libc++</td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/clang64.png" width="30" height="30"></td><td align="center">CLANGARM64</td><td align="center"><code>/clangarm64</code></td><td align="center">llvm</td><td align="center">aarch64</td><td align="center">ucrt</td><td align="center">libc++</td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/clang32.png" width="30" height="30"></td><td align="center">CLANG32</td><td align="center"><code>/clang32</code></td><td align="center">llvm</td><td align="center">i686</td><td align="center">ucrt</td><td align="center">libc++</td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/mingw64.png" width="30" height="30"></td><td align="center">MINGW64</td><td align="center"><code>/mingw64</code></td><td align="center">gcc</td><td align="center">x86_64</td><td align="center">msvcrt</td><td align="center">libstdc++</td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/mingw32.png" width="30" height="30"></td><td align="center">MINGW32</td><td align="center"><code>/mingw32</code></td><td align="center">gcc</td><td align="center">i686</td><td align="center">msvcrt</td><td align="center">libstdc++</td></tr></tbody></table><p>活动环境是通过 <code>MSYSTEM</code> <strong>环境变量</strong>选择的。</p><h3 id="GCC-vs-LLVM-x2F-Clang"><a href="#GCC-vs-LLVM-x2F-Clang" class="headerlink" title="GCC vs LLVM&#x2F;Clang"></a>GCC vs LLVM&#x2F;Clang</h3><p>GCC、LLVM&#x2F;Clang 都是是默认的编译器&#x2F;工具链，用于在各自的存储库中构建所有软件包。</p><ul><li>基于 GCC 的环境：<ul><li>目前被广泛测试和使用</li><li>支持 <code>Fortran</code></li><li>虽然 <code>MINGW</code> 环境中也存在 <code>Clang</code> 软件包，但该软件包仍使用 <code>GNU</code> 链接器和 <code>GNU C++</code> 库。在某些情况下，例如上游开发者更喜欢 <code>Clang</code> 而不是 <code>GCC</code>，也会使用 <code>Clang</code> 来构建软件包。</li></ul></li><li>基于 LLVM&#x2F;Clang 的环境：<ul><li>仅使用 <code>LLVM</code> 工具，<code>LLD</code> 作为链接器，<code>LIBC++</code> 作为 <code>C++</code> 标准库</li><li><code>Clang</code> 提供 <code>ASAN</code> 支持</li><li>本地支持 <code>TLS</code> —— 线程本地存储（Thread-local storage）</li><li><code>LLD</code> 比 <code>LD</code> 更快，但不支持 <code>LD</code> 支持的所有功能</li><li>某些工具缺乏与等效的 <code>GNU</code> 工具相同的功能</li><li>Microsoft Windows 10 支持 <code>ARM64/AArch64</code> 架构</li></ul></li></ul><h4 id="MSVCRT-vs-UCRT"><a href="#MSVCRT-vs-UCRT" class="headerlink" title="MSVCRT vs UCRT"></a>MSVCRT vs UCRT</h4><p>MSVCRT 和 UCRT 是在 Microsoft Windows 上的 C 标准库变体。</p><ul><li><p><strong>MSVCRT（Microsoft Visual C++ Runtime）</strong> 在所有 Microsoft Windows 版本上默认可用，但由于向后兼容性问题而停留在过去，不兼容 <code>C99</code>，并且缺少一些功能：</p><ul><li>例如，它不兼容 <code>C99</code> 的 <code>printf()</code> 函数族，但是…</li><li><code>mingw-w64</code> 提供了替代函数，在许多情况下使事情兼容 <code>C99</code></li><li>不支持 <code>UTF-8</code> 区域设置</li><li>使用 <code>MSVCRT</code> 链接的二进制文件不应与使用 <code>UCRT</code> 的二进制文件混合使用，因为内部结构和数据类型不同。（更严格地说，针对不同目标构建的对象文件或静态库不应混合使用。构建为不同 CRT 的 DLL 可以混合使用，只要它们不跨 DLL 边界共享 CRT 对象，例如 FILE*。）同样的规则适用于 <code>MSVC</code> 编译的二进制文件，因为 <code>MSVC</code> 默认使用 <code>UCRT</code>（如果未更改）。</li><li>在每个 Microsoft Windows 版本上开箱即用。</li></ul></li><li><p><strong>UCRT（Universal C Runtime）</strong> 是一个较新版本，也是 Microsoft Visual Studio 默认使用的版本。它应该像使用 <code>MSVC</code> 编译代码一样工作和运行。</p><ul><li>在构建时和运行时与 <code>MSVC</code> 的兼容性更好。</li><li>它仅默认在 Windows 10 上提供，对于旧版本，您必须自己提供或取决于安装它的用户。</li></ul></li></ul><h3 id="MSYS2-切换环境"><a href="#MSYS2-切换环境" class="headerlink" title="MSYS2 切换环境"></a>MSYS2 切换环境</h3><div class="note note-info">            <p>想要直接看切换的命令，<a href="#env-change">点击一下，直接跳转</a>。</p>          </div><p>经过一番简单的研究，如果想要在终端直接切换 MSYS2 的<strong>环境</strong>，使用 <code>export MSYSTEM=UCRT64</code> 之类的命令，就只能忽悠自己，该命令只是改变了终端的**提示符(prompt)**处的环境名称：</p><div class="code-wrapper"><pre><code class="hljs bash">Username@Hostname CLANG64 ~$ <span class="hljs-built_in">export</span> MSYSTEM=UCRT64Username@Hostname UCRT64 ~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;\n&#x27;</span>/clang64/bin/usr/local/bin...</code></pre></div><p>你使用 <code>echo $PATH | tr &#39;:&#39; &#39;\n&#39;</code> 命令查看环境变量，你就发现，这还是 <code>CLANG64</code> 的环境变量，说明完全没有切换成功，上述的命令就只是欺骗了你。</p><div class="note note-indo">            <p><code>echo $PATH | tr &#39;:&#39; &#39;\n&#39;</code> 命令是将 <code>echo $PATH</code> 输出的内容碰到 “:” 替换为 “\n”.</p><p><code>tr</code> 命令的<strong>第一个参数</strong>是要替换的字符，<strong>第二个参数</strong>是替换成的字符。</p><p>就是实现了<strong>每个路径一行输出的效果</strong>。</p><p>不然就是：</p><div class="code-wrapper"><pre><code class="hljs bash">Username@Hostname CLANG64 ~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span>/clang64/bin:/usr/local/bin:/usr/bin:/bin:/c/Windows/System32:/c/Windows:/c/Windows/System32/Wbem:/c/Windows/System32/WindowsPowerShell/v1.0/:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl</code></pre></div>          </div><p>回归正题，上述命令效果不明显，咱就去 MSYS2 那找，找到个：</p><blockquote><p>If you need to start a shell correctly, but none of the ways above suit you, devise your own way based on this knowledge:</p><ul><li>set <code>MSYSTEM=...</code> into the environment, with the value of either <code>MSYS</code>, <code>MINGW32</code>, or <code>MINGW64</code></li><li>then run a login shell</li></ul><p>The typical one-liner if your options are limited is <code>C:\\msys64\\usr\\bin\\env MSYSTEM=MSYS /usr/bin/bash -li</code>.</p><p>如果以上提到的方法都不适用于你，你可以根据以下知识自己设计启动 shell 的方法：</p><ul><li>将 <code>MSYSTEM=...</code> 设置为环境变量，并将值设为 <code>MSYS</code>、<code>MINGW32</code> 或 <code>MINGW64</code></li><li>然后启动一个登录 shell</li></ul><p>如果你的选择受限，一种常见的方法是运行以下一行命令：<code>C:\\msys64\\usr\\bin\\env MSYSTEM=MSYS /usr/bin/bash -li</code></p></blockquote><p>简单介绍一下原理，如何自行设计启动 shell —— <strong>先设置 <code>MSYSTEM=...</code> 环境变量，再启动一个登录 shell。</strong></p><p>所以咱们就执行 <code>env MSYSTEM=UCRT64 /usr/bin/bash -li</code>…再 <code>echo $PATH | tr &#39;:&#39; &#39;\n&#39;</code>：</p><div class="code-wrapper"><pre><code class="hljs bash">Username@Hostname CLANG64 ~$ <span class="hljs-built_in">env</span> MSYSTEM=UCRT64 /usr/bin/bash -liUsername@Hostname UCRT64 ~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;\n&#x27;</span>/ucrt64/bin/usr/local/bin...</code></pre></div><p>显然，环境切换成功。</p><p>等等，咱再试试 <code>export MSYSTEM=CLANG64</code>，再执行 <code>/usr/bin/bash -li</code>，最后检查成功否 <code>echo $PATH | tr &#39;:&#39; &#39;\n&#39;</code>：</p><div class="code-wrapper"><pre><code class="hljs bash">Username@Hostname UCRT64 ~$ <span class="hljs-built_in">export</span> MSYSTEM=CLANG64Username@Hostname CLANG64 ~$ /usr/bin/bash -liUsername@Hostname CLANG64 ~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;\n&#x27;</span>/clang64/bin/usr/local/bin</code></pre></div><p>😯 woc，傻逼竟是我自己。</p><p><strong>先设置 <code>MSYSTEM=...</code> 环境变量，再启动一个登录 shell。</strong></p><p>咱没有重新启动 bash。没有使用命令重新启动 bash。</p><p>结束结束，不多BB。</p><div class="note note-info">            <p>再多 BB 一声：</p><p><code>/usr/bin/bash -li</code> 是启动一个 Bash shell 的命令。其中 <code>-l</code> 选项代表要启动一个 <strong>login shell</strong>，这将读取登录 shell 的启动文件（如 <code>/etc/profile</code> 和 <code>~/.bash_profile</code>），并在其后面加上 <code>-i</code> 选项，表示这是一个交互式的 shell，可以接受来自用户的输入。<code>-i</code> 选项通常用于设置别名和环境变量。</p><p>加上 <code>/usr/bin/</code> 是 bash 的路径，其在环境变量里的话，直接 <code>bash -li</code> 就可以。</p>          </div><p><scan id="env-change" style="font-weight: bold;">更换环境的话直接使用：</scan></p><ul><li><p><code>MSYS</code></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> MSYSTEM=MSYS /usr/bin/bash -li</code></pre></div></li><li><p><code>UCRT64</code></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> MSYSTEM=UCRT64 /usr/bin/bash -li</code></pre></div></li><li><p><code>CLANG64</code></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> MSYSTEM=CLANG64 /usr/bin/bash -li</code></pre></div></li><li><p><code>CLANGARM64</code></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> MSYSTEM=CLANGARM64 /usr/bin/bash -li</code></pre></div></li><li><p><code>CLANG32</code></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> MSYSTEM=CLANG32 /usr/bin/bash -li</code></pre></div></li><li><p><code>MINGW64</code></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> MSYSTEM=MINGW64 /usr/bin/bash -li</code></pre></div></li><li><p><code>MINGW32</code></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> MSYSTEM=MINGW32 /usr/bin/bash -li</code></pre></div></li></ul><h2 id="5-MSYS2-terminal-的设置"><a href="#5-MSYS2-terminal-的设置" class="headerlink" title="5. MSYS2 terminal 的设置"></a>5. MSYS2 terminal 的设置</h2><h3 id="Mintty"><a href="#Mintty" class="headerlink" title="Mintty"></a>Mintty</h3><p><code>MSYS2</code> 中<strong>默认的终端应用程序</strong>是 <a href="https://mintty.github.io/">Mintty</a>，并包含在安装程序中。</p><p><code>MSYS2</code> 还通过提供相应的 <code>.ini</code> 配置文件和分别对应的启动器（msys2{.exe,.ini}&#x2F;ucrt64{.exe,.ini}&#x2F;…）提供了一些自定义的 <code>Mintty</code> 集成，因此用户可以轻松地配置的环境并将启动器固定到 <code>Windows</code> 任务栏。</p><p>有关更多详细信息，请参见 <a href="https://github.com/msys2/msys2-launcher">https://github.com/msys2/msys2-launcher</a> 和 <a href="https://mintty.github.io/">https://mintty.github.io</a>。</p><h3 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h3><p><code>Windows Terminal</code> 默认支持 <code>cmd</code>、<code>PowerShell</code> 和 <code>WSL</code>，还可以扩展支持 <code>MSYS2 shell</code>。</p><blockquote><p>Windows Terminal 支持美化，可以让终端更加的好看。</p></blockquote><p>Windows Terminal 的安装，Windows11 是默认安装了的，Windows10 的话可以去 Microsoft Store 进行安装。</p><p>在 Windows Terminal 中添加 MSYS2 有两种方法：</p><div class="note note-danger">            <p>咱先默认 MSYS2 的安装路径是 <code>C:\msys64</code></p>          </div><ol><li><p><strong>通过图形化界面点点点</strong>：</p><p><code>设置 &gt; 添加新配置文件 &gt; 新建空的配置文件</code>，然后就是根据每一行的字段输入内容就行了。</p><p>咱这给予一个示例：</p><ul><li><p><strong>名称</strong>：<code>UCRT64 | MSYS2</code>，下拉列表中配置文件显示的名称。</p></li><li><p><strong>命令行</strong>：<code>C:/msys64/msys2_shell.cmd -defterm -here -no-start -ucrt64</code>，在配置文件中所使用的可执行文件。各参数的含义：</p><ul><li><code>C:/msys64/msys2_shell.cmd</code>: 这是要运行的 <code>MSYS2 shell</code> 脚本的路径。</li><li><code>-defterm</code>: 使用 <strong>Windows 默认终端</strong>作为 shell 的终端，而不是使用 <code>mintty</code> 终端。</li><li><code>-here</code>: 将当前目录设置为 shell 的起始目录。</li><li><code>-no-start</code>: 不启动 shell 窗口。</li><li><code>-ucrt64</code>: 使用 <code>ucrt64.dll</code> 作为 <code>C/C++</code> 运行时库，而不是使用默认的 <code>msvcrt.dll</code>。这可以解决一些兼容性问题。</li></ul></li><li><p><strong>启动目录</strong>：<code>C:/msys64/home/%USERNAME%</code>，加载配置文件时启动的目录。</p></li><li><p><strong>图标</strong>：<code>C:/msys64/ucrt64.ico</code>，配置文件中所使用图标的表情符号或者图像文件位置，可自行更换，选择所喜欢的图标。</p></li></ul><p>以上是必要的配置，还有如<strong>选项卡标题</strong>、<strong>以管理员身份运行此配置文件</strong>、<strong>从下拉菜单中隐藏</strong>，可根据自身需要选择。</p><p><strong>外观</strong>和<strong>高级</strong>属于终端美化，暂不介绍。</p></li><li><p><strong>通过在 JSON 配置文件敲敲敲</strong>：</p><p>进入 <code>设置</code>，点击 <code>打开 JSON 文件</code>，然后找到 <code>&quot;profiles&quot;</code> 下面的 <code>&quot;list&quot;</code>，仿照其他的 <code>&#123;&#125;</code> 的内容进行修改或添加就行了。</p><p>咱继续给个例子：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">// defaultProfile: 默认 shell 的 guid，这使 UCRT64 成为默认 shell</span><span class="hljs-attr">&quot;defaultProfile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;17da3cac-b318-431e-8a3e-7fcdefe6d114&#125;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;profiles&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;list&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span>    <span class="hljs-comment">// ...</span>    <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;guid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;17da3cac-b318-431e-8a3e-7fcdefe6d114&#125;&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;UCRT64 / MSYS2&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;commandline&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/msys64/msys2_shell.cmd -defterm -here -no-start -ucrt64&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;startingDirectory&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/msys64/home/%USERNAME%&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/msys64/ucrt64.ico&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;guid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;71160544-14d8-4194-af25-d05feeac7233&#125;&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MSYS / MSYS2&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;commandline&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/msys64/msys2_shell.cmd -defterm -here -no-start -msys&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;startingDirectory&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/msys64/home/%USERNAME%&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/msys64/msys2.ico&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// ...</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>上述各字段分别是，<strong>全局唯一标识符</strong> —— <code>guid</code>、<strong>名称</strong> —— <code>name</code>、<strong>命令行</strong> —— <code>commandline</code>、<strong>启动目录</strong> —— <code>startingDirectory</code>、<strong>图标</strong> —— <code>icon</code>。</p><div class="note note-info">            <p><strong>该配置文件中的命令行默认会启动 <code>bash shell</code>。</strong></p><p>要更改默认的登录 shell，请安装相应的 shell 包，并在命令行中附加 -shell 选项。例如，</p><ul><li><p>要将 <code>fish shell</code> 设置为默认 shell：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;commandline&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/msys64/msys2_shell.cmd -defterm -here -no-start -ucrt64 -shell fish&quot;</span></code></pre></div></li><li><p>要将 <code>zsh shell</code> 设置为默认 shell：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;commandline&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/msys64/msys2_shell.cmd -defterm -here -no-start -ucrt64 -shell zsh&quot;</span></code></pre></div></li></ul>          </div></li></ol><div class="note note-info">            <p>有关不同配置文件设置的更多信息，请参见 <a href="https://learn.microsoft.com/zh-cn/windows/terminal/customize-settings/startup">Windows Termial 自定义设置</a>。</p>          </div><h2 id="6-MSYS2-各环境编译工具的安装"><a href="#6-MSYS2-各环境编译工具的安装" class="headerlink" title="6. MSYS2 各环境编译工具的安装"></a>6. MSYS2 各环境编译工具的安装</h2><p>不同的 MSYS 环境需要的编译器等等工具不经相同，所需要安装的包也不经相同，看了让人头大。现简单列举一下各环境所需要的包，嗯，应该说是最基础的包，具体需要哪些包取决于要编译的代码和程序所依赖的库。</p><p>以下表格根据各自的环境列出了包名，安装时，通常会使用下面列出的包前缀加完整包名：</p><table><thead><tr><th align="center"></th><th align="center">Name<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="环境变量 `MSYSTEM`">[1]</span></a></sup></th><th align="center">Package prefix<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="环境变量 `MINGW_PACKAGE_PREFIX`">[2]</span></a></sup></th></tr></thead><tbody><tr><td align="center"><img src="https://www.msys2.org/docs/msys.png" width="30"/></td><td align="center">MSYS</td><td align="center">None</td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/mingw64.png" width="30"/></td><td align="center">MINGW64</td><td align="center"><code>mingw-w64-x86_64-</code></td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/ucrt64.png" width="30"/></td><td align="center">UCRT64</td><td align="center"><code>mingw-w64-ucrt-x86_64-</code></td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/clang64.png" width="30"/></td><td align="center">CLANG64</td><td align="center"><code>mingw-w64-clang-x86_64-</code></td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/mingw32.png" width="30"/></td><td align="center">MINGW32</td><td align="center"><code>mingw-w64-i686-</code></td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/clang32.png" width="30"/></td><td align="center">CLANG32</td><td align="center"><code>mingw-w64-clang-i686-</code></td></tr><tr><td align="center"><img src="https://www.msys2.org/docs/clangarm64.png" width="30"/></td><td align="center">CLANGARM64</td><td align="center"><code>mingw-w64-clang-aarch64-</code></td></tr></tbody></table><h3 id="1）C-语言编译器"><a href="#1）C-语言编译器" class="headerlink" title="1）C 语言编译器"></a>1）C 语言编译器</h3><p>在 msys2 中安装编译器的话，主要需要安装这几个包：</p><ul><li>gcc: GCC（GNU Compiler Collection）是由 GNU 开发的编程语言编译器，这是 GCC 编译器的 Mingw-w64 版本。</li><li>gdb: 是一个用于调试 C 代码的 GNU 调试器。</li><li>make: GNU Make 工具的 Mingw-w64 版本。它用于构建和管理代码库。</li><li>cmake: 是一个用于自动生成 Makefile 的工具，支持 Windows 和 Unix 系统。</li></ul><p>开始说明 msys2 各环境的 C 语言编译器安装。</p><ul><li><p><code>MSYS</code>：包名没有前缀。</p><p>安装 <code>gcc</code>、<code>gdb</code>、<code>make</code>等等工具。</p><div class="code-wrapper"><pre><code class="hljs zsh">$ pacman -S gcc正在解析依赖关系...正在查找软件包冲突...软件包 (8) binutils-2.40-1  isl-0.25-3  mpc-1.3.1-1  msys2-runtime-devel-3.4.6-2  msys2-w32api-headers-10.0.0.r16.g49a56d453-1          msys2-w32api-runtime-10.0.0.r16.g49a56d453-1  windows-default-manifest-6.4-1  gcc-11.3.0-3</code></pre></div><div class="code-wrapper"><pre><code class="hljs zsh">$ pacman -S gdb正在解析依赖关系...正在查找软件包冲突...软件包 (8) expat-2.5.0-1  libgc-8.2.2-1  libguile-3.0.9-1  libxxhash-0.8.1-1  mpdecimal-2.5.1-1  python-3.11.2-1  xxhash-0.8.1-1          gdb-11.1-6</code></pre></div><p>执行 <code>pacman -S gcc</code> 命令后，<code>pacman</code> 会分析依赖关系，然后下载所需要的依赖，如 <code>binutils</code>、<code>isl</code>、<code>mpc</code>、<code>msys2-runtime-devel</code>、<code>msys2-w32api-headers</code>、<code>msys2-w32api-runtime</code>、<code>windows-default-manifest</code>，最后下载 <code>gcc</code>。</p><blockquote><p>如果需要的 <code>make</code>、<code>cmake</code> 的话：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ pacman -S make正在解析依赖关系...正在查找软件包冲突...软件包 (1) make-4.4.1-1</code></pre></div><div class="code-wrapper"><pre><code class="hljs zsh">$ pacman -S cmake正在解析依赖关系...正在查找软件包冲突...软件包 (6) jsoncpp-1.9.5-1  libarchive-3.6.2-3  librhash-1.4.3-1  libuv-1.44.2-1  pkgconf-1.9.4-1  cmake-3.26.3-1</code></pre></div></blockquote></li><li><p><code>MINGW64</code>: 包前缀是 <code>mingw-w64-x86_64-</code>。</p><p>安装 MINGW64 环境的 GCC 可以直接安装 <code>mingw-w64-x86_64-toolchain</code> 这个包，这是 MSYS2 所定义的一个 Group，简单说就是一个包组，是包含 MINGW64 环境 C 编译器的软件包的一个组合包。包含了：</p><div class="code-wrapper"><pre><code class="hljs txt">mingw-w64-x86_64-binutilsmingw-w64-x86_64-crt-gitmingw-w64-x86_64-gccmingw-w64-x86_64-gcc-adamingw-w64-x86_64-gcc-fortranmingw-w64-x86_64-gcc-libgfortranmingw-w64-x86_64-gcc-libsmingw-w64-x86_64-gcc-objcmingw-w64-x86_64-libgccjitmingw-w64-x86_64-gdbmingw-w64-x86_64-gdb-multiarchmingw-w64-x86_64-headers-gitmingw-w64-x86_64-libmangle-gitmingw-w64-x86_64-libwinpthread-gitmingw-w64-x86_64-winpthreads-gitmingw-w64-x86_64-makemingw-w64-x86_64-pkgconfmingw-w64-x86_64-tools-gitmingw-w64-x86_64-winstorecompat-git</code></pre></div><p>安装命令：</p><div class="code-wrapper"><pre><code class="hljs zsh">pacman -S mingw-w64-x86_64-toolchain</code></pre></div><div class="code-wrapper"><pre><code class="hljs zsh">$ pacman -S mingw-w64-x86_64-toolchain:: 在组 mingw-w64-x86_64-toolchain 中有 19 成员：:: 软件仓库 mingw64  1) mingw-w64-x86_64-binutils  2) mingw-w64-x86_64-crt-git  3) mingw-w64-x86_64-gcc  4) mingw-w64-x86_64-gcc-ada  5) mingw-w64-x86_64-gcc-fortran  6) mingw-w64-x86_64-gcc-libgfortran  7) mingw-w64-x86_64-gcc-libs  8) mingw-w64-x86_64-gcc-objc  9) mingw-w64-x86_64-gdb  10) mingw-w64-x86_64-gdb-multiarch  11) mingw-w64-x86_64-headers-git  12) mingw-w64-x86_64-libgccjit  13) mingw-w64-x86_64-libmangle-git  14) mingw-w64-x86_64-libwinpthread-git  15) mingw-w64-x86_64-make  16) mingw-w64-x86_64-pkgconf  17) mingw-w64-x86_64-tools-git  18) mingw-w64-x86_64-winpthreads-git  19) mingw-w64-x86_64-winstorecompat-git输入某个选择 ( 默认=全部选定 ):</code></pre></div><p>直接安装所有就行。</p><p>如果还需要安装如 <code>cmake</code> 等等包，就直接 + 包名前缀 <code>mingw-w64-x86_64-</code> 就行了：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ pacman -S mingw-w64-x86_64-cmake正在解析依赖关系...正在查找软件包冲突...软件包 (7) mingw-w64-x86_64-jsoncpp-1.9.5-2  mingw-w64-x86_64-libarchive-3.6.2-2  mingw-w64-x86_64-libb2-0.98.1-2          mingw-w64-x86_64-lz4-1.9.4-1  mingw-w64-x86_64-ninja-1.11.1-3  mingw-w64-x86_64-rhash-1.4.3-1          mingw-w64-x86_64-cmake-3.26.3-2</code></pre></div><div class="note note-info">            <p>所有安装的 MINGW64 环境的工具都位于 <code>/mingw64</code> 这个路径下，若是 msys2 的安装路径是 <code>C:/msys64</code>，那么 MINGW64 的工具都在 <code>C:/msys64/mingw64</code> 下。</p><p>如果需要使用 msys2 中的工具在 Windows 使用，比如 GCC 编译器，那就使用 <code>C:/msys64/mingw64</code> 下的相关工具了。</p>          </div></li></ul><p>其他环境下的包都是类似的，只是包名前缀不一样，下面只是简单介绍一下安装命令：</p><ul><li><code>MINGW32</code>: 包名前缀 <code>mingw-w64-i686-</code>，安装 toolchain：<code>pacman -S mingw-w64-i686-toolchain</code>。</li><li><code>UCRT64</code>: 包名前缀 <code>mingw-w64-ucrt-x86_64-</code>，安装 toolchain：<code>pacman -S mingw-w64-ucrt-x86_64-toolchain</code>。</li><li><code>CLANG64</code>: 包名前缀 <code>mingw-w64-clang-x86_64-</code>，安装 toolchain：<code>pacman -S mingw-w64-clang-x86_64-toolchain</code>。</li><li><code>CLANGARM64</code>: 包名前缀 <code>mingw-w64-clang-aarch64-</code>，安装 toolchain：<code>pacman -S mingw-w64-clang-aarch64-toolchain</code>。</li><li><code>CLANG32</code>: 包名前缀 <code>mingw-w64-clang-i686-</code>，安装 toolchain：<code>pacman -S mingw-w64-clang-i686-toolchain</code>。</li></ul><div class="note note-info">            <p>在 MSYS 环境下，一般需要安装以下工具来支持 <strong>C 语言</strong>的编译：</p><ul><li><strong><code>gcc</code> 编译器</strong>：用于编译 C 语言代码。</li><li><strong><code>make</code> 工具</strong>：用于自动化构建和编译程序，通常需要根据 <code>Makefile</code> 文件来执行构建和编译操作。</li><li><strong><code>gdb</code> 调试器</strong>：用于调试程序，可以在程序运行过程中对变量和内存进行查看和修改。</li><li><strong><code>pkg-config</code></strong> 工具：用于检测和获取已安装的库的信息，通常在编译程序时需要指定库的路径和编译选项。</li></ul><p><code>CMake</code> 是一款跨平台的开源构建工具，用于管理和构建软件项目。它可以自动生成与操作系统、编译器和库相关的 <code>Makefile</code> 或者 <code>Project</code> 文件，从而简化了项目的构建和移植。</p><p><code>CMake</code> 不直接构建软件，而是通过生成 <code>Makefile</code> 或者项目文件来让构建工具完成具体的构建过程。</p><p><code>CMake</code> 支持的平台非常广泛，包括 <code>Windows</code>、<code>Linux</code>、<code>macOS</code>、<code>Android</code> 等。</p>          </div><h3 id="2）Rust"><a href="#2）Rust" class="headerlink" title="2）Rust"></a>2）Rust</h3><p>先鸽</p><h2 id="7-个人-Windows-Terminal-的-MSYS2-配置"><a href="#7-个人-Windows-Terminal-的-MSYS2-配置" class="headerlink" title="7. 个人 Windows Terminal 的 MSYS2 配置"></a>7. 个人 Windows Terminal 的 MSYS2 配置</h2><h3 id="1）安装-zsh"><a href="#1）安装-zsh" class="headerlink" title="1）安装 zsh"></a>1）安装 zsh</h3><div class="code-wrapper"><pre><code class="hljs bash">pacman -S zsh</code></pre></div><h3 id="2）安装-oh-my-zsh"><a href="#2）安装-oh-my-zsh" class="headerlink" title="2）安装 oh my zsh"></a>2）安装 oh my zsh</h3><div class="code-wrapper"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></code></pre></div><p>编辑 oh my zsh 配置文件 <code>nano ~/.zshrc</code>：</p><ul><li><p>修改 <code>ZSH_THEME=ys</code></p></li><li><p>修改插件：</p><div class="code-wrapper"><pre><code class="hljs .zshrc">plugins=(     git    zsh-autosuggestions    zsh-syntax-highlighting    history-substring-search)</code></pre></div><p>并下载相关代码：</p><div class="code-wrapper"><pre><code class="hljs zsh">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-history-substring-search.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/history-substring-searchgit clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></pre></div><p>下载完成后，执行下一步。</p></li><li><p>使配置生效：<code>source ~/.zshrc</code></p></li></ul><h3 id="3）安装-lsd"><a href="#3）安装-lsd" class="headerlink" title="3）安装 lsd"></a>3）安装 lsd</h3><p>一个 Rust 编写的 ls 替代品，支持彩色输出、图标显示、Git 状态显示等。</p><p>搜索 lsd：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ pacman -Ss lsdmingw32/mingw-w64-i686-lsd 0.23.1-1    The next gen ls command (mingw-w64)mingw64/mingw-w64-x86_64-lsd 0.23.1-1    The next gen ls command (mingw-w64)ucrt64/mingw-w64-ucrt-x86_64-lsd 0.23.1-1    The next gen ls command (mingw-w64)clang32/mingw-w64-clang-i686-lsd 0.23.1-1    The next gen ls command (mingw-w64)clang64/mingw-w64-clang-x86_64-lsd 0.23.1-1    The next gen ls command (mingw-w64)</code></pre></div><p>有不同版本的 lsd。不过还是推荐使用 rust 安装或者直接编译：</p><p>安装 rust (ucrt 环境)：</p><div class="code-wrapper"><pre><code class="hljs zsh">pacman -S mingw-w64-ucrt-x86_64-rust</code></pre></div><p>使用 cargo 命令安装 lsd：</p><div class="code-wrapper"><pre><code class="hljs zsh">cargo install lsd</code></pre></div><p>如果想安装最新的 lsd：</p><div class="code-wrapper"><pre><code class="hljs zsh">cargo install --git https://github.com/Peltoche/lsd.git --branch master</code></pre></div><p>如果不出意外的话，这样应该就能直接使用 lsd。</p><p>如果出现问题，就自行解决吧。<br>同时也可以自行编译：</p><div class="code-wrapper"><pre><code class="hljs zsh">git clone https://github.com/lsd-rs/lsd.git## 上述克隆不了，可使用下述命令## git clone https://ghproxy.com/github.com/lsd-rs/lsd.git</code></pre></div><p>开始编译：</p><div class="code-wrapper"><pre><code class="hljs zsh">cd lsdcargo build</code></pre></div><p>更多信息详见：<a href="https://github.com/lsd-rs/lsd">lsd | github</a></p><div class="note note-info">            <p>如果提示添加 cargo 路径到环境变量，那就添加 cargo 路径到环境变量：</p><div class="code-wrapper"><pre><code class="hljs zsh">export PATH=&quot;$PATH:/c/Users/USERNAME/.cargo/bin&quot;</code></pre></div><p>添加在 <code>.bashrc</code> 或者 <code>.zshrc</code> 文件中。</p>          </div><h3 id="3）使用-Visual-Studio-Code-打开文件或文件夹"><a href="#3）使用-Visual-Studio-Code-打开文件或文件夹" class="headerlink" title="3）使用 Visual Studio Code 打开文件或文件夹"></a>3）使用 Visual Studio Code 打开文件或文件夹</h3><p>直接让 MSYS 使用 Windows 安装的 Visual Studio Code 就行，将 VS code 的路径添加到环境变量中：</p><div class="code-wrapper"><pre><code class="hljs zsh">export PATH=&quot;$PATH:/c/Program Files (x86)/Microsoft VS Code/bin&quot;</code></pre></div><p>或者是：</p><div class="code-wrapper"><pre><code class="hljs zsh">export PATH=&quot;$PATH:/c/Users/$USER/AppData/Local/Programs/Microsoft VS Code/bin&quot;</code></pre></div><p>根据自身情况进行修改。</p><p>将上述加入 <code>~/.zshrc</code> 中。<br>最后再生效：</p><div class="code-wrapper"><pre><code class="hljs zsh">source ~/.zshrc</code></pre></div><h3 id="4）安装-node-js、-npm、-yarn"><a href="#4）安装-node-js、-npm、-yarn" class="headerlink" title="4）安装 node.js、 npm、 yarn"></a>4）安装 node.js、 npm、 yarn</h3><p>先更新软件源：</p><div class="code-wrapper"><pre><code class="hljs zsh">pacman -Syu</code></pre></div><p>然后根据自己 Msys2 的环境安装 node.js，比如安装 UCRT64 环境的：</p><div class="code-wrapper"><pre><code class="hljs zsh">pacman -S mingw-w64-ucrt-x86_64-nodejs</code></pre></div><blockquote><p>如果是其他环境的 node.js 安装，就先搜索都有什么 node.js 可以安装：</p><div class="code-wrapper"><pre><code class="hljs zsh">pacman -Ss nodejs</code></pre></div><p>然后选择需要的 node.js 进行安装。</p></blockquote><p>npm 会和 node.js 一起安装，当安装完 node.js 时，npm 也会安装完，可以使用 <code>npm -v</code> 检测是否安装完成。</p><p>使用 <code>node -v</code> 检测 node.js 是否安装成功。</p><p>安装 yarn 的话使用：</p><div class="code-wrapper"><pre><code class="hljs zsh">npm install -g yarn</code></pre></div><p>检测 yarn 是否安装成功 <code>yarn -v</code>。</p><p>好家伙，结果给我返回一个：<strong>zsh: command not found: yarn</strong>，仔细一看发现应该是 npm 的安装路路径并不在 PATH 中，看来还需要小小设置一下，然后经查询可以使用下述命令查询 npm 安装路径：</p><div class="code-wrapper"><pre><code class="hljs zsh">npm root -g</code></pre></div><p>返回给我 <code>C:\msys64\ucrt64\lib\node_modules</code>，那咱就在 ~&#x2F;.zshrc 文件中添加一行:</p><div class="code-wrapper"><pre><code class="hljs .zshrc">export PATH=&quot;$PATH:/ucrt64/lib/node_modules&quot;</code></pre></div><p>再使文件生效。<code>yarn -v</code> 继续检测，好家伙还有问题 —— zsh: permission denied: yarn，咱知道这是没有 yarn 的可执行权限，一般都是加上 <code>sudo</code> 命令就好了，不过咱们 msys2 中没有 <code>sudo</code> 命令，害，咋回事呢。先不管这个吧，咱先去 npm 安装路径里看看：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ ls /ucrt64/lib/node_modules/                  corepack   hexo-cli   npm   yarn</code></pre></div><blockquote><p>咱的 ls 是给 lsd 加上别名了。<code>alias ls=&quot;lsd&quot;</code></p></blockquote><p>说明咱是安装了 yarn 的，我还安装了 hexo-cil 呢，再进去看看：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ ls /ucrt64/lib/node_modules/yarn     bin   lib   LICENSE   package.json   preinstall.js   README.md</code></pre></div><p>还有个可执行文件的文件夹，再进去看看：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ ls /ucrt64/lib/node_modules/yarn/bin yarn   yarn.cmd   yarn.js   yarnpkg   yarnpkg.cmd</code></pre></div><p>有个 yarn 文件呀，看看文件类型：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ file /ucrt64/lib/node_modules/yarn/bin/yarn/ucrt64/lib/node_modules/yarn/bin/yarn: POSIX shell script, ASCII text executable</code></pre></div><p>这是一个 ASCII 码编写的 POSIX shell 脚本文件，其中包含了一些 Linux&#x2F;Unix 系统下可执行的 shell 命令。</p><p>执行一下看看：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ /ucrt64/lib/node_modules/yarn/bin/yarn -v1.22.19</code></pre></div><p>是可以的哦。难道说是因为可执行文件太深了？<br>将 <code>/ucrt64/lib/node_modules/yarn/bin</code> 加入环境变量试试，在 <code>~/.zshrc</code> 文件加入下面内容，并生效：</p><div class="code-wrapper"><pre><code class="hljs zsh">export PATH=&quot;$PATH:/ucrt64/lib/node_modules/yarn/bin&quot;</code></pre></div><p>看看能使用 yarn 了没：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ yarn -v1.22.19</code></pre></div><p>好家伙，成了，但是这也太麻烦了吧，我是用 npm 安装应用后，还得添加路径到环境变量，这也太麻烦了。</p><p>stackoverflow 里有多个回答，其中有一个就是要使用 Windows 安装的 node.js 和 npm 然后并添加 node.js 和 npm 的安装路径，二者默认的路径是：</p><ul><li><code>node.js</code>: <code>C:\Program Files\nodejs</code>，包含 <code>node</code>、<code>npm</code>。</li><li><code>npm</code>: <code>C:\Users\&lt;USERNAME&gt;\AppData\Roaming\npm</code>，这是使用 <code>npm install xxxx</code> 后所安装应用的安装位置。</li></ul><p>我查看自己 Windows 10 中的上述路径的文件，差不多就如我所说了，有 npm 以及使用 npm 安装的应用。咱是用 msys2 查看一下都有啥：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ ls /c/Program\ Files/nodejs node_modules   corepack   corepack.cmd   install_tools.bat   node.exe   node_etw_provider.man   nodevars.bat   npm   npm.cmd   npx   npx.cmd$ ls /c/Program\ Files/nodejs/node_modules corepack   npm$ ls /c/Program\ Files/nodejs/node_modules/npm bin   docs   lib   man   node_modules   index.js   LICENSE   npmrc   package.json   README.md$ ls /c/Program\ Files/nodejs/node_modules/npm/bin node-gyp-bin   npm   npm-cli.js   npm.cmd   npx   npx-cli.js   npx.cmd</code></pre></div><p>尝试执行一下 <code>npm -v</code> 命令，执行的是上述 Windows 中的 npm:</p><div class="code-wrapper"><pre><code class="hljs zsh">$ /c/Program\ Files/nodejs/node_modules/npm/bin/npm -vnode:internal/modules/cjs/loader:1078  throw err;  ^Error: Cannot find module &#x27;C:\msys64\ucrt64\bin\node_modules\npm\bin\npm-cli.js&#x27;    at Module._resolveFilename (node:internal/modules/cjs/loader:1075:15)    at Module._load (node:internal/modules/cjs/loader:920:27)    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)    at node:internal/main/run_main_module:23:47 &#123;  code: &#x27;MODULE_NOT_FOUND&#x27;,  requireStack: []&#125;Node.js v18.15.0Could not determine Node.js install directory</code></pre></div><p>看来是之前安装的 node.js 和 Windows 下的冲突了，把已经安装的卸载：<code>pacman -Rns mingw-w64-ucrt-x86_64-nodejs</code> 连同依赖也都删除了，再把之前所添加的和 npm 相关的环境变量也删除，并使 <code>.zshrc</code> 文件生效，再执行 <code>/c/Program\ Files/nodejs/node_modules/npm/bin/npm -v</code>:</p><div class="code-wrapper"><pre><code class="hljs zsh">$ /c/Program\ Files/nodejs/node_modules/npm/bin/npm -v9.3.1</code></pre></div><p>OK，看来是冲突解决了，那再将上述所说的 Windows 的 node.js 和 npm 路径添加到 msys2 的环境变量：</p><div class="code-wrapper"><pre><code class="hljs zsh">export PATH=&quot;$PATH:/c/Program Files/nodejs&quot;export PATH=&quot;$PATH:/c/Users/&lt;USERNAME&gt;/AppData/Roaming/npm&quot;</code></pre></div><blockquote><p>&lt;USERNAME&gt; 是自己 Windows 的用户名哦，注意一下。</p></blockquote><p>然后再试 <code>.zshrc</code> 文件生效。</p><div class="code-wrapper"><pre><code class="hljs zsh">$ node -vv18.14.0$ npm -v 9.3.1$ yarn -v1.22.19$ hexo -vINFO  Validating confighexo: 6.3.0hexo-cli: 4.3.0os: win32 10.0.19044node: 18.14.0v8: 10.2.154.23-node.22uv: 1.44.2zlib: 1.2.13brotli: 1.0.9ares: 1.18.1modules: 108nghttp2: 1.51.0napi: 8llhttp: 6.0.10uvwasi: 0.0.14acorn: 8.8.1simdutf: 3.1.0undici: 5.14.0openssl: 3.0.7+quiccldr: 42.0icu: 72.1tz: 2022gunicode: 15.0ngtcp2: 0.8.1nghttp3: 0.7.0</code></pre></div><p>好哦，显而易见的，这养的方法比之前使用包管理器 <code>pacman</code> 安装的方便多了，只需要一次性添加两条环境变量就好了，不像之前 npm 安装一次就需要添加一次环境变量。</p><p>哦，再看一下 npm 安装路径里都有什么：</p><div class="code-wrapper"><pre><code class="hljs zsh">$ ls /c/Users/&lt;USERNAME&gt;/AppData/Roaming/npm etc   node_modules   hexo   hexo.cmd   hexo.ps1   vue   vue.cmd   vue.ps1   yarn   yarn.cmd   yarn.ps1   yarnpkg   yarnpkg.cmd   yarnpkg.ps1</code></pre></div><h4 id="（1）Node-js-和-npm-安装步骤"><a href="#（1）Node-js-和-npm-安装步骤" class="headerlink" title="（1）Node.js 和 npm 安装步骤"></a>（1）Node.js 和 npm 安装步骤</h4><p>不错不错，特别的好使。现在综上所述一下，将 Windows 安装 Node.js 和 npm 以及添加环境变量的方法总结一下：</p><div class="note note-danger">            <p><del>TMD，先不写了，有空再写，TMD。</del></p><p><del>我 TMD 本来是想再 MSYS UCRT64 环境使用 hexo 新生成一篇 post 的，结果发现没有 hexo、npm、nodejs，🍀，然后就写了上述内容 —— 关于 MSYS 中 nodejs 的安装。TMD，一下子直接花了好多时间，😭😭😭😭😭😭。</del></p>          </div><h3 id="5）Visual-Studio-Code-使用-MSYS2-作为默认终端"><a href="#5）Visual-Studio-Code-使用-MSYS2-作为默认终端" class="headerlink" title="5）Visual Studio Code 使用 MSYS2 作为默认终端"></a>5）Visual Studio Code 使用 MSYS2 作为默认终端</h3><div class="note note-info">            <p>该部分的编写时间是：<strong>2023-04-05 15:31:10</strong>，注意时效性，可能不是那么适用。</p><p>官方文档有专门关于终端的内容，可以自行查看：<a href="https://code.visualstudio.com/docs/terminal/basics">Terminal Basics - TERMINAL | Visual Studio Code Docs</a>。</p>          </div><p>主要是修改 VS code 的设置文件 —— <code>settings.json</code>，以及该文件中 <code>terminal.integrated.profiles.windows</code> 字段的内容，记录时所参照的系统是 Windows 10。</p><p>啊吧啊吧，我 TM 直接贴出我的 <code>settings.json</code> 文件的 <code>terminal.integrated.profiles.windows</code> 字段内容，不继续多讲了，懒了懒了：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;terminal.integrated.profiles.windows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;PowerShell&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PowerShell&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;terminal-powershell&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;Command Prompt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>            <span class="hljs-string">&quot;$&#123;env:windir&#125;\\Sysnative\\cmd.exe&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-string">&quot;$&#123;env:windir&#125;\\System32\\cmd.exe&quot;</span>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;terminal-cmd&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;Git Bash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Git Bash&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;MSYS2(URCT64)&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>            <span class="hljs-string">&quot;$&#123;env:windir&#125;\\Sysnative\\cmd.exe&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-string">&quot;$&#123;env:windir&#125;\\System32\\cmd.exe&quot;</span>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>            <span class="hljs-string">&quot;/c&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-string">&quot;C:/msys64/msys2_shell.cmd -defterm -here -no-start -ucrt64&quot;</span>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;terminal-bash&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;color&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;terminal.ansiRed&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>咱使用 UCRT64 环境，同时为了显示出某些 icons 啥的，需要使用 nerdfonts 字体，所以咱设置一下终端所使用的字体：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;terminal.integrated.fontFamily&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#x27;mononoki NFM&#x27;, &#x27;微软雅黑&#x27;&quot;</span></code></pre></div><p>同时也方便直接对 VS code 所打开项目进行某些命令行操作呢，还需要<strong>设置一下终端打开时所处于的路径</strong>：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;terminal.integrated.defaultLocation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;editor&quot;</span></code></pre></div><p>哦。还需要设置一下默认终端：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;terminal.integrated.defaultProfile.windows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MSYS2(URCT64)&quot;</span></code></pre></div><p>暂且这样。</p><h3 id="6）-zshrc-文件配置"><a href="#6）-zshrc-文件配置" class="headerlink" title="6）.zshrc 文件配置"></a>6）.zshrc 文件配置</h3><p>主要记录一下环境变量的设置，以及命令别名设置，直接上文件：</p><div class="code-wrapper"><pre><code class="hljs .zshrc"># Environment Variable# export ALL_PROXY=http://127.0.0.1:10809# export PATH=&quot;$PATH:/home/&#123;UserName&#125;/.local/share/gem/ruby/3.1.0/bin&quot;export PATH=&quot;$PATH:/c/Users/&#123;UserName&#125;/.cargo/bin&quot;export PATH=&quot;$PATH:/c/Program Files (x86)/Microsoft VS Code/bin&quot;export PATH=&quot;$PATH:/c/Android/platform-tools&quot;export PATH=&quot;$PATH:/c/Users/&#123;UserName&#125;/scoop/apps/scrcpy/current&quot;export PATH=&quot;$PATH:/c/Program Files/nodejs&quot;export PATH=&quot;$PATH:/c/Users/&#123;UserName&#125;/AppData/Roaming/npm&quot;# export PATH=&quot;$PATH:/ucrt64/lib/node_modules&quot;# export PATH=&quot;$PATH:/ucrt64/lib/node_modules/yarn/bin&quot;# Aliasesalias ls=&quot;lsd --config-file /home/&#123;UserName&#125;/.config/lsd/config.yaml&quot;alias datetime=&#x27;echo $(date +%F%n%T)&#x27;alias path=&#x27;echo $PATH | tr &quot;:&quot; &quot;\n&quot; | sort -u&#x27;alias msysenv=&#x27;echo $MSYSTEM&#x27;alias zshconfig=&#x27;echo &quot;sourcing ~/.zshrc...&quot; &amp;&amp; source ~/.zshrc&#x27;alias all_proxy=&#x27;ALL_PROXY=http://127.0.0.1:10809&#x27;</code></pre></div><p>添加了一些常用的环境变量：</p><ul><li>VS code</li><li>adb</li><li>scrcpy</li><li>nodejs</li><li>npm</li></ul><p>等等，这个都在本文中有所描述，基本上就是在自己使用 msys2 的过程中，将觉得有用的东西使用上，并进行记录。</p><h2 id="继续摸鱼"><a href="#继续摸鱼" class="headerlink" title="继续摸鱼"></a>继续摸鱼</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.msys2.org/">MSYS2</a></li><li><a href="https://www.msys2.org/docs/package-naming/">Package Naming | MSYS2</a></li><li><a href="https://www.msys2.org/docs/environments/">Environments | MSYS2</a></li><li><a href="https://stackoverflow.com/questions/46473196/installing-nodejs-and-npm-on-msys2">Installing nodejs and npm on MSYS2 | stack<strong>overflow</strong></a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>环境变量 <code>MSYSTEM</code><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>环境变量 <code>MINGW_PACKAGE_PREFIX</code><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MSYS2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux 系统桌面环境美化记录</title>
    <link href="/archlinux-beauty/"/>
    <url>/archlinux-beauty/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>虽然早就安装了 Arch Linux 步入了邪教，但是一直没有将邪教打扮成自己喜欢的样子。自始至终都没有怎么搜索美化相关的教程，仅仅是看着设置里 <code>外观</code> 中的配置，然后就开始瞎琢磨，从默认的全局主题开始，这里点击一下再查看效果，那里在点击一下查看效果，将所有可以配置的样式都整完了一遍后，还是差强人意。系统自带的果然还是没有特别符合咱自己的口味，看着旁边 <code>获取新的主题\xxx\xxx\xxx\样式</code>，我就迫不及待地打开，加载速度略微有点小慢，不过问题不大，至少加载了不少主题的图片，看起来真有意思，下载下载，全部下载，统统下载，一连选择了很多主题，这怕是可以用到天荒地老了吧，不过，我* * * * * * * * * * * * *，因为网络问题，几乎就没有成功下载来一个。只能说，9，6 翻了。</p><p>但是这难不倒人，开始请教万能的度娘，搜索——下载主题，点击 KDE 商店，继续选择选择，下载，解压，放置到合适位置……一顿操作猛如虎，一点都不行云流水，直接拖泥带水的，点开设置，查看主题，有了有了，上新了，应用……心态炸裂，卧槽，怎么地效果和咱看到的预览图不太一样呢，你这不是妥妥的电信诈骗嘛，会不会是你的主题有问题，然后，浏览，下载……呵呵哒，果然图片仅供参考真的是一大公理。</p><p>于是乎就这样，心血来潮我就搁着捣鼓 Plasma 的主题，一直想找到图片与实物相符的主题，然后就，RNM，退钱……</p><p>最后想起来，我可以看看别人有没有视频教程的，于是乎 ———— <code>Latte Dock</code> 被我找到啦，真的是好东西呀。</p><h3 id="Latte-Dock"><a href="#Latte-Dock" class="headerlink" title="Latte Dock"></a>Latte Dock</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装方式巨简单：</p><div class="code-wrapper"><pre><code class="hljs bash">yay -S latte-dock</code></pre></div><blockquote><p>卸载的话，似乎不是那么能够轻易地卸载感觉</p></blockquote><div class="note note-danger">            <p><strong>To Be Continued:</strong></p><p>还没写完涅。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch Linux</tag>
      
      <tag>Beauty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 SSH 密钥对 git push 进行身份验证</title>
    <link href="/git-ssh-authentication/"/>
    <url>/git-ssh-authentication/</url>
    
    <content type="html"><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>当咱首次使用 <code>git push</code> 命令时，会要求咱输入 GitHub 账户的 username 和 password，这中<strong>基本身份验证</strong>在 <strong>2021.8.13</strong> 以前还是可以的，之后的话，就会报错啦：</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-comment">remote: Support for password authentication was removed on August 13, 2021.</span><span class="hljs-comment">remote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.</span></code></pre></div><p>要进行身份验证的话就得使用其他的办法，先咱已知两种：</p><ol><li><strong>SSH 密钥身份验证</strong></li><li><strong>Personal Access Token（PAT）身份验证</strong>：<br>Personal Access Token 是一种令牌，可用于代替密码进行身份验证。可以在 GitHub、GitLab 或 Bitbucket 等 Git 托管服务中生成 PAT ，并在进行远程操作时使用它。生成 PAT 的过程可能因服务而异，但通常都可以在帐户设置中找到相关选项。</li></ol><p>第二种方法较为复杂，就暂且不适用，简单介绍一下第一种的使用方法。</p><h3 id="SSH-身份验证"><a href="#SSH-身份验证" class="headerlink" title="SSH 身份验证"></a>SSH 身份验证</h3><p><strong>推荐使用的操作系统：Linux</strong></p><h4 id="生成-SSH-密钥"><a href="#生成-SSH-密钥" class="headerlink" title="生成 SSH 密钥"></a>生成 SSH 密钥</h4><p>如果您已经有 SSH 密钥对，可以跳过这一步。否则，您可以在终端中输入以下命令来生成新的 SSH 密钥：</p><div class="code-wrapper"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span></code></pre></div><p>在提示符下，按照默认设置一路回车即可。</p><p>这将在 <code>~/.ssh</code> 目录下生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，其中 <code>id_rsa</code> 是私钥，<code>id_rsa.pub</code> 是公钥。</p><blockquote><p>按照提示操作，生成一个 SSH 密钥对。<br>提示中显示 SSH 密钥对存放的路径。一般默认位置 <code>~/.ssh</code>。</p></blockquote><h4 id="添加公钥到-Git-账户"><a href="#添加公钥到-Git-账户" class="headerlink" title="添加公钥到 Git 账户"></a>添加公钥到 Git 账户</h4><p>将 <code>id_rsa.pub</code> 文件的内容复制到 Git 账户的 SSH 密钥设置中。</p><h4 id="在本地-Git-仓库中配置-SSH-协议"><a href="#在本地-Git-仓库中配置-SSH-协议" class="headerlink" title="在本地 Git 仓库中配置 SSH 协议"></a>在本地 Git 仓库中配置 SSH 协议</h4><p>在终端中进入您的git仓库，输入以下命令：</p><div class="code-wrapper"><pre><code class="hljs bash">git remote set-url origin git@github.com:user/repo.git</code></pre></div><p>将 <code>user/repo.git</code> 替换为 <code>git</code> 仓库的 <code>URL</code>。这将把 <code>git</code> 仓库的 <code>URL</code> 从 <code>HTTPS</code> 协议改为 <code>SSH</code> 协议。</p><h4 id="添加私钥到-ssh-agent"><a href="#添加私钥到-ssh-agent" class="headerlink" title="添加私钥到 ssh-agent"></a>添加私钥到 ssh-agent</h4><p>将 SSH 私钥（默认为 <code>~/.ssh/id_rsa</code>）添加到 ssh-agent 中，以便在进行 SSH 连接时无需每次都输入私钥密码。</p><blockquote><p>当您尝试连接到需要身份验证的远程服务器时，ssh-agent 会自动使用保存在其中的私钥进行身份验证。如果您没有使用 ssh-add 命令将私钥添加到 ssh-agent 中，则需要在每次尝试连接时手动输入私钥密码。</p></blockquote><p>执行命令：</p><div class="code-wrapper"><pre><code class="hljs bash">ssh-add ~/.ssh/id_rsa</code></pre></div><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>然后就可以 Git push 了，根据提示仔细应对就行。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>执行 命令 <code>ssh-add ~/.ssh/id_rsa</code>，shell 报错：</p><div class="code-wrapper"><pre><code class="hljs bash">Could not open a connection to your authentication agent.</code></pre></div><p>这个错误提示通常表示 ssh-agent 没有启动或者没有在当前 shell 中正确地配置。需要进行以下操作：</p><ol><li><p>确保已经安装了 <code>ssh-agent</code>。<br>如果使用的是 Linux 或 Mac 系统，通常它已经默认安装了。可以在终端中输入以下命令检查：</p><div class="code-wrapper"><pre><code class="hljs bash">ssh-agent -h</code></pre></div><p>如果系统已经安装了 <code>ssh-agent</code>，它会输出 <code>ssh-agent</code> 的帮助信息。否则，可以使用系统包管理器来安装它。</p></li><li><p><code>ssh-agent</code>已经启动，请使用以下命令检查它的进程 <code>ID</code>：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SSH_AGENT_PID</span></code></pre></div><p>如果没有输出任何内容，说明 <code>ssh-agent</code> 没有在当前 <code>shell</code> 中正确地配置。</p><p>可以使用以下命令启动 <code>ssh-agent</code>，并将其添加到当前 <code>shell</code>中：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span></code></pre></div></li><li><p>添加私钥：<br> 一旦 <code>ssh-agent</code> 已经启动并添加到了当前 <code>shell</code> 中，请使用以下命令添加私钥到 <code>ssh-agent</code> 中：</p> <div class="code-wrapper"><pre><code class="hljs bash">ssh-add ~/.ssh/id_rsa</code></pre></div><p> 如果还是出现 “Could not open a connection to your authentication agent.” 错误，请尝试重启 <code>ssh-agent</code>：</p> <div class="code-wrapper"><pre><code class="hljs bash">ssh-agent -k<span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span>ssh-add ~/.ssh/id_rsa</code></pre></div></li></ol><p>以上步骤应该能够解决这个问题。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><strong>神奇海螺</strong></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 调试桥（adb）的学习与使用</title>
    <link href="/adb-learning/"/>
    <url>/adb-learning/</url>
    
    <content type="html"><![CDATA[<h3 id="ADB-介绍"><a href="#ADB-介绍" class="headerlink" title="ADB 介绍"></a>ADB 介绍</h3><p>Android 调试桥（<code>adb</code>）是一种功能多样的命令行工具，主要用于电脑连接安卓设备，进行通信。</p><div class="note note-info">            <p><strong>Android 开发者 &gt; Android Studio &gt; 用户指南</strong>：<br>Android 调试桥 (<code>adb</code>) 是一种功能多样的命令行工具，可让您与设备进行通信。<br><code>adb</code> 命令可用于执行各种设备操作，例如安装和调试应用。<br><code>adb</code> 提供对 <code>Unix shell</code>（可用来在设备上运行各种命令）的访问权限。</p>          </div><p><code>abd</code> 是一种<strong>客户端-服务器</strong>程序，包括以下三个组件：</p><ul><li><strong>客户端</strong>：用于发送命令。客户端在开发机器上运行。您可以通过发出 <code>adb</code> 命令从命令行终端调用客户端。</li><li>**守护程序 (adbd)**：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。</li><li><strong>服务器</strong>：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。</li></ul><h4 id="ADB-安装"><a href="#ADB-安装" class="headerlink" title="ADB 安装"></a>ADB 安装</h4><ul><li><strong><code>Android SDK</code> 平台工具软件包</strong>下载：<br>  <code>adb</code> 包含在 <code>Android SDK</code> 平台工具软件包中。<br>  您可以使用 <code>SDK</code> 管理器下载此软件包，该管理器会将其安装在 <code>android_sdk/platform-tools/</code> 下。</li><li><strong>独立的 <code>Android SDK</code> 平台工具软件包</strong>：<br>  点击后方链接下载：<a href="https://developer.android.google.cn/studio/releases/platform-tools?hl=zh-cn">Download Platform Tools</a></li></ul><p><strong>然后，将上述目录 <code>xxxx/plalform-tools</code> 添加入系统环境变量</strong>。</p><h3 id="adb-的工作原理"><a href="#adb-的工作原理" class="headerlink" title="adb 的工作原理"></a>adb 的工作原理</h3><p>当启动某个 <code>adb</code> 客户端时，该客户端会先检查是否有 <code>adb</code> 服务器进程已在运行。如果没有，它会启动服务器进程。服务器在启动后会与本地 TCP 端口 5037 绑定，并监听 <code>adb</code> 客户端发出的命令。</p><div class="note note-info">            <p>注意：所有 <code>adb</code> 客户端均使用端口 5037 与 <code>adb</code> 服务器通信。</p>          </div><p>然后，服务器会与所有正在运行的设备建立连接。它通过扫描 5555 到 5585 之间（该范围供前 16 个模拟器使用）的奇数号端口查找模拟器。服务器一旦发现 <code>adb</code> 守护程序 (<code>adbd</code>)，便会与相应的端口建立连接。</p><p>每个模拟器都使用一对按顺序排列的端口：一个用于控制台连接的偶数号端口，另一个用于 <code>adb</code> 连接的奇数号端口。例如：</p><p>模拟器 1，控制台：5554<br>模拟器 1，<code>adb</code>：5555<br>模拟器 2，控制台：5556<br>模拟器 2，<code>adb</code>：5557<br>依此类推。</p><p>如上所示，在端口 5555 处与 <code>adb</code> 连接的模拟器与控制台监听端口为 5554 的模拟器是同一个。</p><p>服务器与所有设备均建立连接后，便可以使用 <code>adb</code> 命令访问这些设备。由于服务器管理与设备的连接，并处理来自多个 <code>adb</code> 客户端的命令，因此可以从任意客户端或从某个脚本控制任意设备。</p><h3 id="在设备上启用-adb-调试"><a href="#在设备上启用-adb-调试" class="headerlink" title="在设备上启用 adb 调试"></a>在设备上启用 adb 调试</h3><ul><li><strong>启用开发者选项</strong>：<br>  在搭载 <code>Android 4.2</code> 及更高版本的设备上，开发者选项屏幕默认情况下处于隐藏状态。如需将其显示出来，请<a href="https://developer.android.google.cn/studio/debug/dev-options?hl=zh-cn#enable">启用开发者选项</a>。</li><li><strong>启用 USB 调试（位于开发者选项下）</strong></li></ul><div class="note note-info">            <p><strong>注意：</strong><br>当您连接搭载 <code>Android 4.2.2</code> 或更高版本的设备时，系统会显示一个对话框，询问您是否接受允许通过此计算机进行调试的 RSA 密钥。这种安全机制可以保护用户设备，因为它可以确保用户只有在能够解锁设备并确认对话框的情况下才能执行 USB 调试和其他 <code>adb</code> 命令。</p>          </div><p>再使用 USB 连接设备。</p><div class="note note-danger">            <p><strong>To Be Continued:</strong></p><p>还没写完涅。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>adb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 学习......</title>
    <link href="/git-learning/"/>
    <url>/git-learning/</url>
    
    <content type="html"><![CDATA[<h2 id="常用-Git-命令"><a href="#常用-Git-命令" class="headerlink" title="常用 Git 命令"></a>常用 Git 命令</h2><p>以下是一些常用的 Git 命令：</p><ul><li><code>git init</code>：初始化一个 Git 仓库</li><li><code>git clone [url]</code>：从远程仓库克隆代码到本地</li><li><code>git add [file]</code>：将文件添加到暂存区</li><li><code>git commit -m &quot;[message]&quot;</code>：提交暂存区中的文件到版本库，并添加一条提交信息</li><li><code>git status</code>：查看当前仓库状态</li><li><code>git log</code>：查看提交日志</li><li><code>git pull</code>：从远程仓库拉取最新代码</li><li><code>git push</code>：将本地代码推送到远程仓库</li><li><code>git branch</code>：查看当前仓库的所有分支</li><li><code>git checkout [branch]</code>：切换分支</li><li><code>git merge [branch]</code>：将指定分支合并到当前分支</li><li><code>git diff [file]</code>：查看文件差异</li><li><code>git stash</code>：将当前未提交的改动暂存起来</li><li><code>git reset [file]</code>：将文件从暂存区中移除</li><li><code>git revert [commit]</code>：撤销指定的提交</li><li><code>git tag [name]</code>：给当前提交打标签</li><li><code>git remote</code>：查看远程仓库信息</li><li><code>git config</code>：配置 Git</li></ul><p>以上只是一些常用的 Git 命令，Git 还有很多其他命令和选项，可以通过 <code>git --help</code> 查看 Git 的帮助文档来了解更多信息。</p><hr><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p><code>Git</code> 使用 <code>git init</code> 命令来初始化一个 <code>Git</code> 仓库，<code>Git</code> 的很多命令都需要在 <code>Git</code> 的仓库中运行，所以 <code>git init</code> 是使用 <code>Git</code> 的第一个命令。</p><p>在执行完成 <code>git init</code> 命令后，<code>Git</code> 仓库会生成一个 <code>.git</code> 目录，该目录用于追踪管理版本库，不建议手动修改该文件夹。</p><div class="note note-info">            <p><code>.git</code> 目录：<br>包含所有 git 操作的所需要文件。</p><p><code>git init</code> 初始化后的目录结构：</p><div class="code-wrapper"><pre><code class="hljs bash">$ tree.└── .git    ├── HEAD    ├── branches    ├── config    ├── description    ├── hooks    │   ├── applypatch-msg.sample    │   ├── commit-msg.sample    │   ├── fsmonitor-watchman.sample    │   ├── post-update.sample    │   ├── pre-applypatch.sample    │   ├── pre-commit.sample    │   ├── pre-merge-commit.sample    │   ├── pre-push.sample    │   ├── pre-rebase.sample    │   ├── pre-receive.sample    │   ├── prepare-commit-msg.sample    │   └── update.sample    ├── info    │   └── exclude    ├── objects    │   ├── info    │   └── pack    └── refs        ├── heads        └── tags10 directories, 16 files</code></pre></div><p>进行 <code>git add</code> + <code>git commit</code>，操作后的 <code>.git</code> 目录：</p><div class="code-wrapper"><pre><code class="hljs stylus">$ tree<span class="hljs-selector-class">.git</span>├── COMMIT_EDITMSG├── HEAD├── branches├── config├── description├── hooks│   ├── applypatch-msg<span class="hljs-selector-class">.sample</span>│   ├── commit-msg<span class="hljs-selector-class">.sample</span>│   ├── fsmonitor-watchman<span class="hljs-selector-class">.sample</span>│   ├── post-update<span class="hljs-selector-class">.sample</span>│   ├── pre-applypatch<span class="hljs-selector-class">.sample</span>│   ├── pre-commit<span class="hljs-selector-class">.sample</span>│   ├── pre-merge-commit<span class="hljs-selector-class">.sample</span>│   ├── pre-push<span class="hljs-selector-class">.sample</span>│   ├── pre-rebase<span class="hljs-selector-class">.sample</span>│   ├── pre-receive<span class="hljs-selector-class">.sample</span>│   ├── prepare-commit-msg<span class="hljs-selector-class">.sample</span>│   └── update<span class="hljs-selector-class">.sample</span>├── index├── info│   └── exclude├── logs│   ├── HEAD│   └── refs│       └── heads│           └── master├── objects│   ├── <span class="hljs-number">3</span>d│   │   └── <span class="hljs-number">6</span>bb1c51730683ab010f472f60eb96f1041eb86│   ├── <span class="hljs-number">86</span>│   │   └── <span class="hljs-number">9644542</span>e81a31cd5d0828cdaca22fcb4bf1dce│   ├── ce│   │   └── <span class="hljs-number">013625030</span>ba8dba906f756967f9e9ca394464a│   ├── info│   └── pack└── refs    ├── heads    │   └── master    └── tags<span class="hljs-number">15</span> directories, <span class="hljs-number">24</span> files</code></pre></div><p>可以发现，进行了 <code>git add</code> 和 <code>git commit</code> 操作后的文件夹多出了：<code>COMMIT_EDITMSG</code> 文件、<code>index</code> 文件、<code>logs</code> 文件夹等等，<code>logs</code>、<code>objects</code>、<code>refs</code> 等文件夹下还会多出了子目录及文件。</p><p>简单介绍 .git 文件夹中内容：</p><ul><li><code>COMMIT_EDITMSG</code>：保存有最新一次提交的 <code>commit message</code>，<code>git</code> 系统不会用上，仅是给用户一个参考。 </li><li><code>HEAD</code>：指向目前被检出的分支或提交记录。</li><li><code>branches</code>：存储本地分支的目录。</li><li><code>config</code>：包含项目特定的配置文件，例如例如用户名、邮箱、远程仓库等。</li><li><code>description</code>：GitWeb 程序使用此文件来获取 Git 仓库的简短描述。</li><li><code>hooks</code>：存储客户端或服务端的 Git 钩子（hooks）脚本的目录。Git 钩子是在 Git 特定的动作发生时自动运行的脚本程序，例如提交前、提交后、合并时等。</li><li><code>index</code>：包含一个暂存区域，用于在提交之前暂存更改。</li><li><code>info</code>：存放一些 Git 的临时信息，例如排除一些不需要版本控制的文件、记录 Git 所有分支的最后一次提交的时间戳等。</li><li><code>info/exclude</code>：指定 Git 忽略文件的规则。</li><li><code>logs</code>：存放 Git 引用日志，记录每个引用的提交历史。</li><li><code>logs/HEAD</code>：存储引用的更改历史。</li><li><code>logs/refs/heads</code>：存储本地分支的更改历史。</li><li><code>objects</code>：存储 Git 数据库中的所有内容。<ul><li><code>info</code>：存储 Git 数据库的一些元数据信息。</li><li><code>pack</code>：存储 Git 压缩的对象文件。</li></ul></li><li><code>refs/heads</code>：存储本地分支引用的目录。</li><li><code>refs/tags</code>：存储标签引用的目录。</li></ul>          </div><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p><code>git clone</code> 以为<strong>克隆</strong>或<strong>拷贝</strong>，用作从现有的 Git 仓库克隆（下载）项目到本地。</p><p>直接克隆仓库：</p><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;repo</span>&gt;</code></pre></div><p>克隆仓库到指定文件夹：</p><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;repo</span>&gt; <span class="hljs-tag">&lt;dir&gt;</span></code></pre></div><p>克隆<strong>速度过慢</strong>或是<strong>无响应时</strong>，应选择走<strong>代理加速下载</strong>：</p><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://xxxxxx.xxx/<span class="hljs-tag">&lt;repo&gt;</span><span class="hljs-comment"># e.g:</span><span class="hljs-comment"># git clone https://ghproxy.com/https://github.com/xxxxx/xxxxx.git</span></code></pre></div><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p><code>git branch</code> 是 Git 中用来管理分支的命令。</p><p>以下是常见的 <code>git branch</code> 用法：</p><ul><li><code>git branch</code>: 查看本地分支列表。</li><li><code>git branch &lt;branch_name&gt;</code>: 创建一个新的分支。</li><li><code>git branch -d &lt;branch_name&gt;</code>: 删除指定的分支。</li><li><code>git branch -r</code>: 查看远程分支列表。</li><li><code>git branch -a</code>: 查看所有分支（本地和远程）的列表。</li><li><code>git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;</code>: 将分支重命名。</li><li><code>git branch --merged</code>: 查看已经合并到当前分支的分支。</li><li><code>git branch --no-merged</code>: 查看尚未合并到当前分支的分支。</li><li><code>git branch -vv</code>: 查看本地分支的详细信息，包括与远程分支的关联关系和最后一次提交。</li></ul><div class="note note-info">            <p><strong>新建分支时报错：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">$ git branch xxxxxfatal: Not a valid object name: <span class="hljs-string">&#x27;master&#x27;</span>.</code></pre></div><blockquote><p>初学 <code>Git</code> 时，如果新建一个本地仓库的时候如果没有任何操作的情况下进行分支创建，会遇到该报错信息。</p></blockquote><p><strong>原因：</strong><br>根据提示可以知道，原因是没有一个叫 <code>master</code> 的提交对象。你也可以执行一下 <code>git branch</code>，会发现没有看到本地分支列表（没有内容）：</p><p>其实，要先进行一次 <code>commit</code> 操作（进行一次提交操作），才会真正建立 <code>master</code> 分支。</p><p>这是因为分支的指针要指向提交的，只有进行了提交，才有指针指向该分支，才算是真正的建立了分支，成为一个有效的对象。</p>          </div><hr><h2 id="git-checout"><a href="#git-checout" class="headerlink" title="git checout"></a>git checout</h2><p><strong><code>git checkout</code> 是 Git 中的一个重要命令，用于切换分支、回退版本、创建分支等操作。</strong></p><p>以下是 <code>git checkout</code> 常见的用法和问题：</p><ul><li><code>git checkout &lt;branch_name&gt;</code>：用于切换到另一个分支，例如 <code>git checkout dev</code> 将当前分支切换到名为 dev 的分支。</li><li><code>git checkout &lt;commit_id&gt;</code>：用于切换到指定的提交版本，例如 <code>git checkout abc123</code> 将当前代码库切换到提交 ID 为 abc123 的版本。这个操作也称为“撤销”或“还原”代码。</li><li><code>git checkout -b &lt;new_branch_name&gt;</code>：用于创建新的分支并切换到该分支，例如 <code>git checkout -b feature</code> 将创建一个名为 feature 的新分支，并将当前分支切换到 feature 分支。</li><li><code>git checkout -- &lt;file&gt;</code>：用于丢弃本地未提交的更改，例如 <code>git checkout -- index.html</code> 将丢弃 index.html 文件中未提交的更改。</li></ul><div class="note note-info">            <p><strong>常见的关于 <code>git checkout</code> 的问题：</strong></p><ul><li><p>报错“error: Your local changes to the following files would be overwritten by checkout”</p><p>如果在切换分支时出现此错误，表示您当前分支上的某些更改将覆盖目标分支上的文件。您可以使用以下命令保存本地更改，并在切换分支后再应用它们：</p><div class="code-wrapper"><pre><code class="hljs bash">git stashgit checkout &lt;target_branch&gt;git stash apply</code></pre></div></li><li><p>报错“error: pathspec ‘file_name’ did not match any file(s) known to git.”</p><p>如果在切换分支时出现此错误，表示您当前分支上没有名为 file_name 的文件。请检查文件名是否正确拼写，并确保文件已被添加到 Git 仓库中。</p></li></ul>          </div><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p><code>git add</code> 命令用于将文件或文件夹添加到 Git 的暂存区（也称为索引）中，以便在提交时将其包含在版本控制中。</p><p>常见用法：</p><ul><li><code>git add &lt;file_path&gt;</code>：添加单个文件</li><li><code>git add &lt;folder_path&gt;</code>：添加整个文件夹</li><li><code>git add .</code>：添加当前目录下的所有文件和文件夹</li><li><code>git add *.txt</code>：添加指定类型的文件，例如只添加 .txt 文件</li><li><code>git add &lt;folder_path&gt;/</code>：添加指定文件夹下的所有文件和文件夹</li><li><code>git add -A</code>：添加所有已修改的文件，包括删除的文件</li></ul><p>在提交前，需要使用 <code>git status</code> 命令检查已暂存的文件和未暂存的文件的状态。如果文件已暂存，则它们将包括在下一次提交中。如果文件未暂存，则需要使用 <code>git add</code> 命令将其添加到暂存区中。</p><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p><code>git status</code> 命令用于显示当前 Git 仓库的状态，包括哪些文件已被修改、哪些文件已被添加到暂存区、哪些文件尚未被跟踪等信息。</p><p>常见用法：</p><ul><li><code>git status</code>：显示当前 Git 仓库的状态</li><li><code>git status -v</code>：显示当前 Git 仓库的状态，并包括更详细的信息</li><li><code>git status --short</code>：以简洁的方式显示当前 Git 仓库的状态</li><li><code>git status --untracked-files</code>：显示未跟踪的文件</li></ul><p><code>git status</code> 命令是 Git 中最常用的命令之一，它可以帮助您了解当前仓库的状态，以便您决定是否需要执行其他操作，比如使用 <code>git add</code> 添加文件到暂存区或使用 <code>git commit</code> 提交更改。</p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p><code>git commit</code> 命令是 Git 中最常用的命令之一，用于将暂存区中的修改提交到本地仓库中。</p><p>常见用法：</p><ul><li><code>git commit -m &quot;commit message&quot;</code>：提交暂存区中的所有修改，并添加提交说明。</li><li><code>git commit -a -m &quot;commit message&quot;</code>：直接将所有已跟踪的修改提交到本地仓库中，无需先执行 <code>git add</code>。</li><li><code>git commit --amend</code>：修改最近一次提交的提交说明。</li><li><code>git commit -v</code>：提交时显示文件的差异。</li><li><code>git commit --no-verify</code>：提交时跳过 Git 钩子的验证。</li><li><code>git commit --allow-empty</code>：允许提交空的提交记录。</li><li><code>git commit --signoff</code>：提交时添加签名，通常用于公开的开源项目。</li><li><code>git commit --fixup &lt;commit&gt;</code>：创建一个针对指定提交的 fixup 提交，用于后续使用 rebase 进行合并操作。</li></ul><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p><code>git log</code> 是 Git 中用于查看提交历史的命令。它可以显示 Git 仓库中提交记录的详细信息，包括提交的 SHA 值、作者、提交时间、提交信息等。</p><p>常见的用法：</p><ul><li><code>git log</code>：显示所有提交记录，最近的提交记录排在最上面。</li><li><code>git log -n</code>：显示最近的 n 个提交记录。</li><li><code>git log --since=yyyy-mm-dd</code>：显示从指定日期开始的所有提交记录。</li><li><code>git log --until=yyyy-mm-dd</code>：显示截止到指定日期为止的所有提交记录。</li><li><code>git log --author=name</code>：显示指定作者的所有提交记录。</li><li><code>git log --grep=pattern</code>：显示提交信息中包含指定模式的所有提交记录。</li><li><code>git log --oneline</code>：以一行的形式显示提交记录，包括 SHA 值和提交信息。</li><li><code>git log --graph</code>：以图形化的方式显示提交历史，可以更清晰地查看分支合并情况。</li><li><code>git log --pretty=format:&quot;format&quot;</code>：使用指定的格式显示提交记录。format 是格式化字符串，可以包含各种占位符，如 %h 表示提交的短 SHA 值，%an 表示作者名等。</li><li><code>git log --follow &lt;file&gt;</code>：显示指定文件的提交历史，包括文件的改名和移动。</li><li><code>git log &lt;branch1&gt;..&lt;branch2&gt;</code>：显示两个分支之间的提交记录。</li></ul><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p><code>git pull</code> 是 Git 中用于从远程代码仓库中拉取最新代码到本地代码仓库中的命令。它会自动合并远程分支到当前分支，并更新本地代码仓库中的文件。</p><p>常见用法：</p><ul><li><code>git pull</code>：直接拉取并合并远程分支到当前分支。</li><li><code>git pull origin &lt;branch&gt;</code>：拉取并合并指定远程分支到当前分支。</li><li><code>git pull --rebase</code>：拉取并将本地未提交的修改变基到拉取的代码之上。</li><li><code>git pull --rebase origin &lt;branch&gt;</code>：拉取并将本地未提交的修改变基到指定的远程分支之上。</li></ul><p>需要注意的是，如果本地分支与远程分支之间存在冲突，则 <code>git pull</code> 会失败，并提示用户手动解决冲突后再进行提交。</p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p><code>git push</code> 命令用于将本地仓库的代码推送到远程仓库，以便在多个开发者之间共享代码。</p><p>通常情况下，<code>git push</code> 命令将本地代码推送到与之关联的远程仓库的默认分支。</p><p>常见用法：</p><ul><li><code>git push</code>: 将当前分支的代码推送到关联的远程仓库的默认分支。</li><li><code>git push &lt;remote&gt; &lt;branch&gt;</code>: 将本地指定分支的代码推送到关联的远程仓库的指定分支。</li><li><code>git push --all</code>: 将所有本地分支的代码推送到关联的远程仓库。</li><li><code>git push --force</code>: 强制推送本地代码到远程仓库。该命令会覆盖远程仓库上的修改，慎用。</li><li><code>git push --tags</code>: 将本地的标签推送到关联的远程仓库。</li></ul><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p><code>git merge</code> 命令用于将一个分支的修改合并到另一个分支上。</p><p>使用 <code>git merge</code> 命令，可以将当前分支（通常是 <code>master</code> 分支）与其他分支合并。例如，假设你有一个 <code>feature</code> 分支，想将它合并到 <code>master</code> 分支，可以使用以下命令：</p><div class="code-wrapper"><pre><code class="hljs zsh">git checkout mastergit merge feature</code></pre></div><p>这将把 <code>feature</code> 分支上的所有更改合并到 <code>master</code> 分支上。如果在合并过程中发生冲突，Git 将提示你进行手动解决冲突。</p><p><code>git merge</code> 命令有多种选项，常用的选项包括：</p><ul><li><code>--no-ff</code>：禁用快进合并（Fast-forward merge），这样可以保留分支合并历史，便于查看。</li><li><code>--squash</code>：将分支上的多个提交压缩为一个提交，并将它们合并到目标分支上。</li><li><code>-m</code>：当合并冲突时，指定合并信息的格式。</li></ul><h2 id="部分问题"><a href="#部分问题" class="headerlink" title="部分问题"></a>部分问题</h2><h3 id="remote-rejected"><a href="#remote-rejected" class="headerlink" title="remote rejected"></a>remote rejected</h3><div class="code-wrapper"><pre><code class="hljs zsh">To https://github.com/Muxiner/muxiner.github.io.git ! [remote rejected] source -&gt; source (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/acitons.yml` without `workflow` scope)</code></pre></div><p>上述是 <code>git push</code> 时的报错。</p><p>这个错误提示说明在使用 Personal Access Token(PAT) 授权推送代码时，没有为该令牌授予 workflow 权限，导致 GitHub Actions 无法更新或创建 workflows。</p><p>解决该问题的办法是，重新为 PAT 添加 workflow 权限：</p><ul><li>打开 GitHub Settings 页面。</li><li>选择 Developer settings &gt; Personal access tokens。</li><li>找到所使用的 PAT，并且点击 Edit 按钮。</li><li>在 Scopes 栏中，勾选 workflow 权限。</li><li>点击 Update token 保存修改。</li><li>现在，再次推送代码，就应该可以成功触发 GitHub Actions 并自动部署了。</li></ul><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/2023-03-20-gitpush.png"></p><div class="note note-danger">            <p><strong>To Be Continued:</strong></p><p>还没写完涅。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VScode 自动补全</title>
    <link href="/vscode-quick-suggestions/"/>
    <url>/vscode-quick-suggestions/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用 VS code 时没有自动补全的功能，用起来确实十分不适，曾记得之前使用 VS code 时存在着自动补全的功能，一番搜索下来，终是明白如何使用自动补全。</p></blockquote><h3 id="VS-code-文本补全"><a href="#VS-code-文本补全" class="headerlink" title="VS code 文本补全"></a>VS code 文本补全</h3><blockquote><p>VS Code 自动补全，VS Code 当中的自动补全内容，其实是由语言服务来提供的。</p><p>VS Code 为编程语言工作者提供了统一的 API ，即 <code>Language Server Protocol</code>，每种语言都能够通过实现这个 API 在 VS Code 上得到类似 IDE 的开发体验，而各个语言根据这个 API 实现的服务，就被称为<strong>语言服务</strong>。</p><p>语言服务会根据当前的项目、当前的文件，以及光标所在的位置，为我们提供一个建议列表。这个列表包含了在当前光标位置下我们可能会输入的代码。当我们不断地输入字符，VS Code 就会根据当前输入的字符，在这个列表进行过滤。</p></blockquote><p><strong>使用方法</strong>：</p><ul><li>输入字符，出现自动补全的过滤列表窗口；</li><li>选择好合适内容，使用 <code>Tab</code> 或 <code>Enter</code> 进行补全；</li><li><code>Escape</code> 键关闭（隐藏）自动补全窗口</li><li><strong>打字</strong>或 <del><code>Ctrl + Space</code></del> 重新打开自动补全窗口</li></ul><h4 id="VS-code-自动补全设置"><a href="#VS-code-自动补全设置" class="headerlink" title="VS code 自动补全设置"></a>VS code 自动补全设置</h4><p>打开 <code>settings.json</code>，可以通过设置 <code>&quot;editor.quickSuggestions&quot;</code> 来决定在什么语境下自动补全窗口会被唤出。默认设置如下：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;editor.quickSuggestions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>   <span class="hljs-attr">&quot;other&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;comments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;strings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span> <span class="hljs-punctuation">&#125;</span></code></pre></div><ul><li><code>other</code>: 代码;</li><li><code>comments</code>: 注释；</li><li><code>strings</code>：字符串。</li></ul><p><code>true</code>，启用自动补全窗口；<code>false</code> 关闭自动补全窗口。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://geek-docs.com/vscode/vscode-tutorials/vs-code-auto-complete.html">VSCode 自动补全 | 极客教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>VS code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VS code</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 包管理工具 Scoop 更换国内可用源</title>
    <link href="/scoop-replace-source/"/>
    <url>/scoop-replace-source/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要更换源"><a href="#为什么要更换源" class="headerlink" title="为什么要更换源"></a>为什么要更换源</h2><p>Windows 的命令行包管理器 Scoop 使用起来就非常的好用，但是，但是，但是，由于 github 被一道神秘力量阻挡在外，而 Scoop 的安装、安装和更新软件都依赖于 github 上的仓库，于是乎 Scoop 就变得不太好用了起来，当然这不是 Scoop 的问题。</p><p>这神秘的力量导致咱更新或安装软件经常性出现网络问题，即使是使用魔法，依然会存在问题，以至于就想更新一下软件，不是网络问题就是更新或下载的速度太慢。</p><p>非常的无奈，不过解决办法还是特别的多，一番简单的搜索过后，锁定解决方案 —— 使用国内镜像源&#x2F;代理加速。</p><h2 id="代理网站法器"><a href="#代理网站法器" class="headerlink" title="代理网站法器"></a>代理<del>网站</del>法器</h2><div class="note note-info">            <ul><li>简单列举几个站点，不定时检查下来站点的可用性。</li><li>站点排序不根据可靠性，随意排的。<br>个站点详细的使用方式需自行进入官方进行查看。</li></ul>          </div><h3 id="镜像网站"><a href="#镜像网站" class="headerlink" title="镜像网站"></a>镜像网站</h3><p>暂无。</p><h3 id="文件加速"><a href="#文件加速" class="headerlink" title="文件加速"></a>文件加速</h3><ol start="3"><li><p><strong>ghdl.feizhuqwq.cf</strong> Github 文件加速</p><p> 地址：<a href="https://ghdl.feizhuqwq.cf/">https://ghdl.feizhuqwq.cf/</a></p></li><li><p><strong>ghproxy.qystudio.ml</strong> Github 文件加速</p><p> 地址：<a href="https://ghproxy.qystudio.ml/">https://ghproxy.qystudio.ml/</a></p></li><li><p>GitHub 文件加速</p><p> 地址：<a href="https://gh.api.99988866.xyz/">GitHub 文件加速</a></p></li></ol><h3 id="加速下载"><a href="#加速下载" class="headerlink" title="加速下载"></a>加速下载</h3><ol><li><p><strong>Github Proxy</strong></p><p>地址：<a href="https://ghproxy.com/">Github Proxy</a><br><code>GitHub</code> 文件 , <code>Releases</code> , <code>archive</code> , <code>gist</code> , <code>raw.githubusercontent.com</code> 文件代理加速下载服务.</p></li><li><p>GitClone</p><p> 地址：<a href="https://gitclone.com/">GitClone</a><br> ​<code>gitclone.com</code> 是一个 <code>github.com</code> 缓存加速网站，通过对经常访问的 github 的代码库的缓存，加速从 github 的 <code>git clone</code> 操作。</p></li><li><p>FastGit UK Document</p><p> 地址：<a href="https://doc.fastgit.org/">FastGit UK Document</a><br> <code>FastGit</code> 是一个对于 <code>GitHub.com</code> 的镜像加速器。</p></li><li><p>GitHub 加速下载</p><p> 地址：<a href="http://toolwa.com/github/">GitHub 加速下载</a></p></li><li><p><strong>pd.zwc365.com</strong> Github 文件加速下载服务</p><p> 地址：<a href="https://pd.zwc365.com/">pd.zwc365.com</a></p></li><li><p>加速你的 Github</p><p> 地址：<a href="https://github.zhlh6.cn/">加速你的Github</a></p></li><li><p>FAST-GitHub</p><p>地址：<a href="https://fhefh2015.github.io/Fast-GitHub/">FAST-GitHub</a></p></li></ol><h2 id="Scoop-更换源"><a href="#Scoop-更换源" class="headerlink" title="Scoop 更换源"></a>Scoop 更换源</h2><p>使用 <a href="https://ghproxy.com/">Github Proxy</a> 对 Scoop 仓库进行代理加速下载。</p><blockquote><p>亲测，使用后效果起飞。Scoop 使用起来都舒服多了。</p></blockquote><p>使用方法很简单，仅需在原 url 前加入 <code>https://ghproxy.com/</code> 即可，如 <code>gie clone</code></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 原：git clone https://github.com/your_name/your_repo</span><span class="hljs-comment"># 使用 github proxy</span>git <span class="hljs-built_in">clone</span> https://ghproxy.com/https://github.com/your_name/your_repo</code></pre></div><p>因而对 Scoop 仓库等等 url 做如下修改：</p><h3 id="Scoop-源"><a href="#Scoop-源" class="headerlink" title="Scoop 源"></a>Scoop 源</h3><div class="code-wrapper"><pre><code class="hljs bash">scoop config SCOOP_REPO <span class="hljs-string">&#x27;https://ghproxy.com/https://github.com/ScoopInstaller/Scoop&#x27;</span></code></pre></div><h3 id="bucket-源"><a href="#bucket-源" class="headerlink" title="bucket 源"></a>bucket 源</h3><p>先 rm 掉原有的 bucket，然后再添加新的。</p><p><strong>main</strong></p><div class="code-wrapper"><pre><code class="hljs bash">scoop bucket add main <span class="hljs-string">&#x27;https://ghproxy.com/https://github.com/ScoopInstaller/Main&#x27;</span></code></pre></div><p><strong>extras</strong></p><div class="code-wrapper"><pre><code class="hljs bash">scoop bucket add extras <span class="hljs-string">&#x27;https://ghproxy.com/https://github.com/ScoopInstaller/Extras&#x27;</span></code></pre></div><p><strong>versions</strong></p><div class="code-wrapper"><pre><code class="hljs bash">scoop bucket add versions <span class="hljs-string">&#x27;https://ghproxy.com/https://github.com/ScoopInstaller/Versions&#x27;</span></code></pre></div><p><strong>java</strong></p><div class="code-wrapper"><pre><code class="hljs bash">scoop bucket add java <span class="hljs-string">&#x27;https://ghproxy.com/https://github.com/ScoopInstaller/Java&#x27;</span></code></pre></div><p><strong>nirsoft</strong></p><div class="code-wrapper"><pre><code class="hljs bash">scoop bucket add nirsoft <span class="hljs-string">&#x27;https://ghproxy.com/https://github.com/kodybrown/scoop-nirsoft&#x27;</span></code></pre></div><p><strong>nerd-fonts</strong></p><div class="code-wrapper"><pre><code class="hljs bash">scoop bucket add nerd-fonts <span class="hljs-string">&#x27;https://ghproxy.com/https://github.com/matthewjberger/scoop-nerd-fonts&#x27;</span></code></pre></div><p>添加其他 bucket 方法同上。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/scoop-bucket-proxy.png"></p><h2 id="xxxx"><a href="#xxxx" class="headerlink" title="xxxx"></a>xxxx</h2><p>有啥问题解决什么问题，问题解决不了，那就解决提出问题的人（doge）。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cygwin 的安装与配置</title>
    <link href="/cygwin-installation/"/>
    <url>/cygwin-installation/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Cygwin"><a href="#什么是-Cygwin" class="headerlink" title="什么是 Cygwin"></a>什么是 Cygwin</h2><p>安装之前先简单地介绍一下 <code>Cygwin</code> —— <strong>是一个可原生运行于 Windows 系统上的 POSIX 兼容环境</strong>。</p><blockquote><p><strong>维基百科</strong>：<br>Cygwin 是许多自由软件的集合，最初由 Cygnus Solutions 开发，用于各种版本的 Microsoft Windows 上，运行类 UNIX 系统。Cygwin 的主要目的是通过重新编译，将 POSIX 系统（例如 Linux、BSD，以及其他 Unix 系统）上的软件移植到 Windows 上。</p></blockquote><p>不多比比，直接开整。</p><h2 id="安装-cygwin"><a href="#安装-cygwin" class="headerlink" title="安装 cygwin"></a>安装 cygwin</h2><h3 id="下载-cygwin-安装包"><a href="#下载-cygwin-安装包" class="headerlink" title="下载 cygwin 安装包"></a>下载 cygwin 安装包</h3><p>官网指路：<a href="https://cygwin.com/">Cygwin - Get the Linux feeling on Windows</a>.</p><p>进入官网后，找到下方一 <code>Installing Cygwin</code> 的地方，点击下方黑体加粗后的链接 - <a href="https://cygwin.com/setup-x86_64.exe">setup-x86_64.exe</a>.</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/Pixiv/installing-cygwin.png"></p><blockquote><p>图省事直接点击咱这个 setup-x86_64.exe 就行。</p></blockquote><div class="note note-info">            <p>Use the setup program to perform a <strong>fresh install</strong> or to <strong>update</strong> an existing installation.</p><p>当你安装了 Cygwin 后，还可以使用该安装程序进行<strong>更新</strong>和<strong>重新安装</strong>。非常的好用。</p>          </div><h3 id="开始安装-cygwin"><a href="#开始安装-cygwin" class="headerlink" title="开始安装 cygwin"></a>开始安装 cygwin</h3><p>点击下载好的 <a href="https://cygwin.com/setup-x86_64.exe">setup-x86_64.exe</a>.</p><blockquote><p>没有下载还可以再点击一下上述链接，开始下载，完成后开始点击，进行安装。</p></blockquote><p>进入安装界面后，仔细看界面内容进行修改或者是下一步，如：</p><ul><li>选择<strong>根目录</strong>，如 <code>C:\cygwin64</code>.</li><li>选择<strong>本地包目录</strong>，如 <code>C:\xxxxx\cygwin_download</code>，自定义的。</li><li>设置<strong>网络连接</strong>，如 <code>系统代理</code>。</li><li>选择<strong>下载站点</strong>，如 <code>https://mirrors.ustc.edu.cn</code>.</li><li>选择<strong>需要下载或是更新的包</strong>，自行研究。</li></ul><p>然后还是下一步安装或是更新 cygwin，直至完成。</p><h2 id="配置-Cygwin"><a href="#配置-Cygwin" class="headerlink" title="配置 Cygwin"></a>配置 Cygwin</h2><h3 id="安装命令行软件包管理器-apt-cyg"><a href="#安装命令行软件包管理器-apt-cyg" class="headerlink" title="安装命令行软件包管理器 apt-cyg"></a>安装命令行软件包管理器 apt-cyg</h3><h4 id="简单介绍-apt-cyg"><a href="#简单介绍-apt-cyg" class="headerlink" title="简单介绍 apt-cyg"></a>简单介绍 apt-cyg</h4><p><code>apt-cyg</code> 是类似与 <code>apt-get</code>、<code>apt</code>、<code>yum</code>、<code>pacman</code> 等著名命令行包管理器的命令行包管理器，在 <code>Cygwin</code> 下使用。</p><p>Github 上托管了 n 种 shell 语言版的 apt-cyg —— <a href="https://github.com/search?l=Shell&q=apt-cyg&type=Repositories">Search apt-cyg | github</a>.</p><p>咱们要使用的是搜索结果排行第一的 <a href="https://github.com/transcode-open/apt-cyg">transcode-open&#x2F;apt-cyg</a>。</p><blockquote><p>其遵循 MIT 开源协议发布，2016 年发布 v1 版本后便再未更新过。<br>它其实就是一个 Shell 脚本，帮助用户查找、安装、卸载软件包，还可以根据文件名称反向查找所属的软件包。</p></blockquote><h4 id="安装-apt-cyg"><a href="#安装-apt-cyg" class="headerlink" title="安装 apt-cyg"></a>安装 apt-cyg</h4><p>项目推荐的安装步骤：</p><ol><li><p>下载安装包</p> <div class="code-wrapper"><pre><code class="hljs bash">lynx -<span class="hljs-built_in">source</span> rawgit.com/transcode-open/apt-cyg/master/apt-cyg &gt; apt-cyg</code></pre></div> <div class="note note-warning">            <p>如果上述命令无法完成下载，则直接使用 <code>git clone</code> 进行拉去项目：</p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/transcode-open/apt-cyg.git apt-cyg</code></pre></div>          </div></li><li><p>安装</p> <div class="code-wrapper"><pre><code class="hljs bash">install apt-cyg /bin</code></pre></div> <div class="note note-warning">            <p>如果使用 <code>git clone</code> 下载，则需要先进入 <code>apt-cyg</code> 文件夹在进行安装：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> apt-cyginstall apt-cyg /bin</code></pre></div>          </div></li></ol><div class="note note-success">            <p>使用 <a href="https://silaoa.github.io/2019/2019-05-25-Cygwin%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8apt-cyg.html#0x01-%E5%AE%89%E8%A3%85apt-cyg">Cygwin系列（八）：命令行软件包管理器apt-cyg | silaoa.github.io</a> 内容解释上述命令：</p><p>第 1 行是使用 <code>lynx</code> 命令将 <code>apt-cyg</code> 脚本从网站下载保存至当前目录的 <code>apt-cyg</code> 文件。<br>第 2 行是使用 <code>install</code> 命令将 <code>apt-cyg</code> 文件安装至 <code>/bin</code> 目录下，这一步其实包含了两个动作：</p><ul><li>将 <code>apt-cyg</code> 文件复制到 <code>/bin</code> 目录</li><li>增加 <code>/bin/apt-cyg</code> 文件可执行权限，这样用户可以在任意位置使用 <code>apt-cyg</code> 命令</li></ul><p>也可以手工的方式用浏览器下载 <code>apt-cyg</code> 脚本至本地，通过 <code>cp</code> 命令复制到 <code>/bin</code> 目录，再通过 <code>chmod</code> 命令增加 <code>/bin/apt-cyg</code> 文件可执行权限。</p><p><code>apt-cyg</code> 运行过程中依赖 <code>bash</code>、<code>tar</code>、<code>wget</code>、<code>bzip2</code>、<code>gawk</code>、<code>xz</code> 软件包中的命令来完成文件下载、文本分析、压缩&#x2F;解压等基本功能，需要先在 <code>Cygwin</code> 中安装好这些软件包。</p><p>其中，<code>bash</code>、<code>tar</code>、<code>wget</code>、<code>gawk</code> 属于 <code>Base</code> 类，在安装最小系统时已包含；<code>bzip2</code>、<code>xz</code> 属于 <code>Archive</code>类，需要通过 <code>setup</code> 先装上，确保后续运行 <code>apt-cyg</code> 不出错。</p><blockquote><p>突然发现了盲点，我光安装了 <code>apt-cyg</code> 没有安装 <code>bzip2</code>、<code>xz</code>，不过问题不大，再走一遍 <code>setup-x86_64.exe</code> 就行了。</p></blockquote><blockquote><p>突然又发现了盲点，上述的几个包都已经安装了，不需要再额外安装。</p></blockquote>          </div><p>安装后可以使用 <code>apt-cyg install nano</code> 命令安装一个 <code>nano</code> 编辑器检测 apt-cyg 是否安装成功：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/Pixiv/apt-cyg-install-nano.png"></p><div class="note note-info">            <p>关于 apt-cyg 的使用可见大佬 <strong>silaoA</strong> 的一篇博客，嗯，还是上述那篇 —— <a href="https://silaoa.github.io/2019/2019-05-25-Cygwin%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8apt-cyg.html#0x02-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">Cygwin系列（八）：命令行软件包管理器apt-cyg | silaoa.github.io</a>.</p>          </div><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p><strong>为能够在 Windows 环境下的命令行工具直接使用 linux 命令行命令，需在在系统环境变量的 <code>path</code> 中添加三条路径：</strong></p><ol><li><p><code>C:\cygwin64\bin</code></p><p><code>bin</code> 为 <code>binary</code> 的简写，包含基本的用户命令，可被所有用户使用。包含能够同时被用户和系统管理员使用的命令（二进制程序），并且可以在不挂载任何其它文件系统的情况下使用。</p></li><li><p><code>C:\cygwin64\sbin</code></p><p>存放系统管理员以及其他需要 <code>root</code> 权限来运行的工具。</p></li><li><p><code>C:\cygwin64\usr\local\bin</code></p><p>本地站点用户使用的二进制程序文件。</p></li></ol><p>结果如图：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/Pixiv/cygwin-env-path.png"></p><div class="note note-info">            <p>就是将 cygwin 中的<strong>用户可执行文件的目录</strong>以及<strong>系统可执行文件的目录</strong>加入到 Windows 系统环境变量中，以便于 Windows 下的命令行工具调用 cygwin 中的可执行文件，从而在 Windows 下使用 linux 一部分的命令行命令。</p><ul><li>用户可执行文件：<code>/bin</code>、<code>/usr/bin</code>、<code>/usr/local/bin</code>.</li><li>系统可执行文件：<code>/sbin</code>、<code>/usr/sbin</code>、<code>/usr/local/sbin</code>.</li></ul>          </div><div class="note note-primary">            <p>快捷打开 Windows 环境变量设置的方法：</p><ol><li><code>Win + R</code> 打开<strong>运行</strong></li><li>输入 <code>systempropertiesadvanced</code>，进入<strong>系统属性</strong>界面</li><li>点击下方<strong>环境变量</strong>，进入环境变量设置</li></ol><p>怎么说，就很快。</p>          </div><h2 id="使用-zsh-和-oh-my-zsh-进行美化"><a href="#使用-zsh-和-oh-my-zsh-进行美化" class="headerlink" title="使用 zsh 和 oh my zsh 进行美化"></a>使用 zsh 和 oh my zsh 进行美化</h2><p>方法与<a href="https://muxiner.github.io/2022/11/01/ubuntu-zsh-ohmyzsh/">Ubuntu 安装 zsh + oh my zsh 美化终端</a>殊途同归:</p><h3 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h3><div class="code-wrapper"><pre><code class="hljs bash">apt-cyg install zsh</code></pre></div><h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh my zsh"></a>安装 oh my zsh</h3><p>两个命令二选一：</p><div class="code-wrapper"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span>sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></code></pre></div><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><div class="code-wrapper"><pre><code class="hljs bash">nano ~/.bashrc</code></pre></div><p>在最后加入 <code>exec zsh</code>。</p><h3 id="修改-oh-my-zsh-主题"><a href="#修改-oh-my-zsh-主题" class="headerlink" title="修改 oh my zsh 主题"></a>修改 oh my zsh 主题</h3><div class="code-wrapper"><pre><code class="hljs bash">nano ~/.zshrc</code></pre></div><p>找到 <code>ZSH_THEME</code> 字段，修改引号内内容为 <code>robbyrussell</code>.</p><h3 id="生效配置"><a href="#生效配置" class="headerlink" title="生效配置"></a>生效配置</h3><p>输入命令使配置生效：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> zsh</code></pre></div><div class="note note-default">            <p>如果还需要安装 zsh 插件，可见 <a href="https://muxiner.github.io/2022/11/01/ubuntu-zsh-ohmyzsh/#%E5%AE%89%E8%A3%85-zsh-%E6%8F%92%E4%BB%B6">Ubuntu 安装 zsh + oh my zsh 美化终端</a>.</p>          </div><h2 id="添加-Cygwin-到-Windows-Terminal"><a href="#添加-Cygwin-到-Windows-Terminal" class="headerlink" title="添加 Cygwin 到 Windows Terminal"></a>添加 Cygwin 到 Windows Terminal</h2><ul><li>打开 Windows Terminal；</li><li>然后 <code>设置 &gt; 配置文件 &gt; 添加新配置文件</code>；</li><li>再者 <code>新建空配置文件</code>；</li><li>对空配置文件进行修改（基础修改）：<ul><li>名称：<code>Cygwin</code></li><li>命令行：<code>C:\cygwin64\bin\bash.exe -i -l</code></li><li>启动目录：<code>C:\cygwin64\home\xxxxxx</code></li><li>图标：<code>C:\cygwin64\Cygwin.ico</code></li></ul></li></ul><div class="note note-info">            <p>关于命令行的一点点解释，使用大佬 leo3418 <a href="https://leo3418.github.io/zh/2020/05/24/cygwin-git-bash-in-wt.html">在 Windows Terminal 中使用 Cygwin 命令行或 Git Bash</a> 的部分内容：</p><p>首先确定 Cygwin 的安装路径。如果您装的是 64 位版本，那么默认的安装路径是 <code>C:\cygwin64</code>。Bash 的可执行文件 <code>bash.exe</code> 存在 Cygwin 安装路径下的 <code>bin</code> 文件夹中，因此在默认的情况下，该文件的绝对路径是 <code>C:\cygwin64\bin\bash.exe</code>。</p><p>此处需要注意的一点是，Cygwin 中的 Bash 需要以交互式登录 shell（interactive login shell）的形式启动，否则的话，在运行一些包括 <code>ls</code> 在内的基本指令的时候会出 “command not found” 的消息。这个的原因是只有登录 shell 会在启动的时候运行 <code>/etc/profile</code>，然后 Cygwin 中的 <code>/etc/profile</code> 会把 <code>/usr/bin</code> 和 <code>/usr/local/bin</code> 加到 <code>PATH</code> 环境变量当中。如果开启的不是登录 shell，那么 <code>/etc/profile</code> 不会被运行，环境变量也就不会被设置。<strong>启动交互式登录 shell 的方法是使用 -i -l 选项</strong>。如果您想使用别的 shell，那么请自行确认下让 <code>/usr/bin</code> 和 <code>/usr/local/bin</code> 被添加到 PATH 下的方法。</p>          </div><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/Pixiv/cygwin-installation-final.png"></p><p>大功告成。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>install</tag>
      
      <tag>Cygwin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 安装 zsh + oh my zsh 美化终端</title>
    <link href="/ubuntu-zsh-ohmyzsh/"/>
    <url>/ubuntu-zsh-ohmyzsh/</url>
    
    <content type="html"><![CDATA[<p>关于 zsh 的一些简单介绍，查看权威介绍：</p><ul><li><a href="https://zh.wikipedia.org/wiki/Z_shell">Z shell | 中文维基百科</a></li><li><a href="https://wiki.archlinux.org/title/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Zsh | archlinux</a></li></ul><h3 id="install-zsh"><a href="#install-zsh" class="headerlink" title="install zsh"></a>install zsh</h3><p>Ubuntu 安装 zsh 十分简单，只是执行命令即可：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo apt install zsh</code></pre></div><blockquote><p>又看到别人教程说还需要切换 zsh 为默认 shell，目前来看是没有必要的。<br>因为安装完 oh my zsh 后，其会自动设置 zsh 为默认终端。</p></blockquote><div class="note note-info">            <p>如果手动设置默认 shell：</p><div class="code-wrapper"><pre><code class="hljs arcade">chsh -s <span class="hljs-string">`which zsh`</span></code></pre></div><p>再输入密码，并重启就行。</p>          </div><h3 id="install-oh-my-zsh"><a href="#install-oh-my-zsh" class="headerlink" title="install oh-my-zsh"></a>install oh-my-zsh</h3><blockquote><p>Oh My Zsh 是一个令人愉快的、开源的、社区驱动的框架，用于管理咱们的 Zsh 配置。<br>它捆绑了数千个有用的功能、助手、插件、主题，以及一些让咱们兴奋的东西……</p></blockquote><ul><li>官网：<a href="https://ohmyz.sh/">oh my zsh</a></li><li>文档：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki">oh my zsh | github wiki</a></li></ul><p><strong>安装</strong>：</p><blockquote><p>install oh-my-zsh via curl</p></blockquote><div class="code-wrapper"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></code></pre></div><blockquote><p>install oh-my-zsh via wget</p></blockquote><div class="code-wrapper"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span></code></pre></div><blockquote><p>上述命令会将 oh my zsh 安装在用户目录中，即 <code>/home/username/.oh-my-zsh</code>。是个隐藏文件。</p></blockquote><h3 id="powerlevel10k"><a href="#powerlevel10k" class="headerlink" title="powerlevel10k"></a>powerlevel10k</h3><p>接下来主要是配置 oh my zsh 的主题，其自带的主题还是比较多的，比如：</p><div class="note note-default">            <p>在我看来，也就 <code>agnoster</code> 最好看了。所以我将其放在第一位。</p><p>后面的只是我粗看一看，还过得去的。</p><p>罗卜白菜，各有所爱啦。</p>          </div><ul><li><p><code>agnoster</code></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221101150411-agnoster.png"></p></li><li><p><code>half-life</code></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221101150655-half-life.png"></p></li><li><p><code>jtriley</code></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221101150823-jtriley.png"></p></li><li><p><code>mortalscumbag</code></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221101150956-mortalscumbag.png"></p></li><li><p><code>steeef</code></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221101151132-steeef.png"></p></li><li><p><code>terminalparty</code></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221101151412-terminalparty.png"></p></li><li><p><code>tjkirch</code></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221101151526-tjkirch.png">  </p></li><li><p><code>ys</code></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221101151728-ys.png"></p></li></ul><p>更多主题情况请详见：</p><ul><li><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">oh my zsh themes | github wiki</a></li><li><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/External-themes">oh my zsh External themes | github wiki</a></li></ul><p>除了上述主题外，还有一种非常 freedom 的一种主题 ——  <code>powerlevel10k</code>。</p><blockquote><p>它强调速度、灵活性和开箱即用的体验。<br>It emphasizes speed, flexibility and out-of-the-box experience.</p></blockquote><p>该主题可以自行选择你所喜欢的样式来美化你的 prompt，也就是主题所改变的部分。</p><p>先看看咱的：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221101152215-powerlevel10k.png"></p><div class="note note-info">            <p>就只是简单的选择了自己喜欢的样式。</p><p>该主题还可以添加更多有意思的部分，这个详见：<a href="https://github.com/romkatv/powerlevel10k">powerlevel10k | github</a></p>          </div><h3 id="install-powerlevel10k"><a href="#install-powerlevel10k" class="headerlink" title="install powerlevel10k"></a>install powerlevel10k</h3><p>下载仓库：</p><div class="code-wrapper"><pre><code class="hljs zsh">git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k</code></pre></div><div class="note note-success">            <p>中国大陆用户可以使用 gitee.com 上的官方镜像加速下载.</p><div class="code-wrapper"><pre><code class="hljs zsh">git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/theme</code></pre></div>          </div><p>然后修改 <code>.zshrc</code> 文件：</p><div class="code-wrapper"><pre><code class="hljs zsh">nano ~/.zshrc</code></pre></div><p>注释 <code>ZSH_THEME</code> 字段，并在下方添加 <code>ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</code>。</p><p>最后执行命令进行设置，仔细阅读选项进行选择即可：</p><div class="code-wrapper"><pre><code class="hljs zsh">p10k configure</code></pre></div><h3 id="安装-zsh-插件"><a href="#安装-zsh-插件" class="headerlink" title="安装 zsh 插件"></a>安装 zsh 插件</h3><blockquote><p>看到别人推荐，自己试了确实不错。<br>zsh 插件确实挺多，可以去 wiki 看看：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">zsh Plugins | github wiki</a></p></blockquote><p><del>这里咱就只说俩，<strong>自动补全</strong> + <strong>代码高亮</strong>。</del></p><h4 id="安装自动补全-——-zsh-autosuggestions"><a href="#安装自动补全-——-zsh-autosuggestions" class="headerlink" title="安装自动补全 —— zsh-autosuggestions"></a>安装自动补全 —— <code>zsh-autosuggestions</code></h4><p>先下载到 oh my zsh 插件中</p><div class="code-wrapper"><pre><code class="hljs zsh">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></pre></div><p>然后在配置文件 <code>.zshrc</code> 相关位置如下添加：</p><div class="code-wrapper"><pre><code class="hljs txt">plugins=(     # other plugins...    zsh-autosuggestions)</code></pre></div><h4 id="安装代码高亮-——-zsh-syntax-highlighting"><a href="#安装代码高亮-——-zsh-syntax-highlighting" class="headerlink" title="安装代码高亮 —— zsh-syntax-highlighting"></a>安装代码高亮 —— <code>zsh-syntax-highlighting</code></h4><p>还是先下载到 oh my zsh 的插件中</p><div class="code-wrapper"><pre><code class="hljs zsh">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></pre></div><p>然后还是在配置文件 <code>.zshrc</code> 对应位置：</p><div class="code-wrapper"><pre><code class="hljs txt">plugins=( [plugins...] zsh-syntax-highlighting)</code></pre></div><h4 id="允许在命令历史记录中搜索子串-——-history-substring-search"><a href="#允许在命令历史记录中搜索子串-——-history-substring-search" class="headerlink" title="允许在命令历史记录中搜索子串 —— history-substring-search"></a>允许在命令历史记录中搜索子串 —— <code>history-substring-search</code></h4><div class="code-wrapper"><pre><code class="hljs zsh">git clone https://github.com/zsh-users/zsh-history-substring-search.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/history-substring-search</code></pre></div><p>然后还是在配置文件 <code>.zshrc</code> 对应位置：</p><div class="code-wrapper"><pre><code class="hljs txt">plugins=( [plugins...] history-substring-search)</code></pre></div><h4 id="目录导航-——-zsh-navigation-tools"><a href="#目录导航-——-zsh-navigation-tools" class="headerlink" title="目录导航 —— zsh-navigation-tools"></a>目录导航 —— <code>zsh-navigation-tools</code></h4><p>安装 <code>zsh-navigation-tools</code> 可以提供一些在命令行中浏览和编辑不同内容的工具，包括浏览别名、目录、函数、历史记录、进程、环境变量等。</p><p>安装：</p><div class="code-wrapper"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/z-shell/zsh-navigation-tools/main/doc/install.sh)</span>&quot;</span></code></pre></div><p>更新该插件就再运行该指令。</p><div class="note note-info">            <p>The tools are:</p><ul><li><p><code>n-aliases</code> - 浏览别名，并将编辑委托给 <code>vared</code></p></li><li><p><code>n-cd</code> - 浏览 <code>dirstack</code> 和已标记的目录，并允许进入所选目录</p></li><li><p><code>n-functions</code> - 浏览函数，并将编辑委托给 <code>zed</code> 或 <code>vared</code></p></li><li><p><code>n-history</code> - 浏览历史记录，并允许编辑和运行其中的命令</p></li><li><p><code>n-kill</code> - 浏览进程列表，并允许向所选进程发送信号</p></li><li><p><code>n-env</code> - 浏览环境，并将编辑委托给 <code>vared</code></p></li><li><p><code>n-options</code> - 浏览选项，并允许切换其状态</p></li><li><p><code>n-panelize</code> - 将给定命令的输出加载到浏览列表中<br>所有工具都支持使用 <code>&lt;</code>, <code>&gt;</code>, <code>{</code>, <code>}</code>, <code>h</code>, <code>l</code> 或<strong>左右光标</strong>进行水平滚动。其他键包括：</p></li><li><p><code>H</code>，<code>?</code>（来自 <code>n-history</code>） - 运行 <code>n-help</code></p></li><li><p><code>Ctrl-R</code> - 启动 <code>n-history</code>，增量、多关键字历史搜索器（<code>Zsh</code> 绑定）</p></li><li><p><code>Ctrl-A</code> - 旋转输入的单词（1+2+3 -&gt; 3+1+2）</p></li><li><p><code>Ctrl-F</code> - 修正模式（近似匹配）</p></li><li><p><code>Ctrl-L</code> - 重新绘制整个显示</p></li><li><p><code>Ctrl-T</code> - 浏览主题（下一个主题）</p></li><li><p><code>Ctrl-G</code> - 浏览主题（上一个主题）</p></li><li><p><code>Ctrl-U</code> - 上半页</p></li><li><p><code>Ctrl-D</code> - 下半页</p></li><li><p><code>Ctrl-P</code> - 上一个元素（也可以使用vim的k）</p></li><li><p><code>Ctrl-N</code> - 下一个元素（也可以使用vim的j）</p></li><li><p><code>[</code>，<code>]</code> - 在  <code>n-cd</code> 中跳转目录书签，在 <code>n-kill</code> 中跳转典型信号</p></li><li><p><code>g</code>，<code>G</code> - 列表的开始和结尾</p></li><li><p><code>/</code> - 显示增量搜索</p></li><li><p><code>F3</code> - 显示&#x2F;隐藏增量搜索</p></li><li><p><code>Esc</code> - 退出增量搜索，并清除过滤器</p></li><li><p><code>Ctrl-W</code>（在增量搜索中） - 删除整个单词</p></li><li><p><code>Ctrl-K</code>（在增量搜索中） - 删除整行</p></li><li><p><code>Ctrl-O</code>，<code>o</code> - 进入唯一模式（无重复行）</p></li><li><p><code>Ctrl-E</code>，<code>e</code> - 编辑私有历史记录（当在私有历史记录视图中时）</p></li><li><p><code>F1</code> - （在 <code>n-history</code> 中） - 切换视图</p></li><li><p><code>F2</code>，<code>Ctrl-X</code>，<code>Ctrl-/</code> - 搜索预定义关键字（在配置文件中定义）</p></li></ul>          </div><p>结束。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/ohmyzsh/ohmyzsh/">oh my zsh | github</a></li><li><a href="https://ohmyz.sh/">oh my zsh</a></li><li><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">oh my zsh Plugins| github wiki</a></li><li><a href="https://github.com/romkatv/powerlevel10k">powerlevel10k | github</a></li><li><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions | github</a></li><li><a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh">zsh-autosuggestions install</a></li><li><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting | github</a></li><li><a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md">zsh-syntax-highlighting install</a></li><li><a href="https://matnoble.me/tech/ubuntu/install-zsh/">Ubuntu 安装 Zsh ，配置最强终端</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>install</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 更换中科大软件源</title>
    <link href="/ubuntu-ustc-sources/"/>
    <url>/ubuntu-ustc-sources/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>为加快 Ubuntu 更新或者下载软件的速度，更换使用中科大软件源。</p><p>还可以使用其他的软件源，如清华源、阿里源等等。</p><p>需要根据自身网络情况选择合适的软件源，以寻求最快的下载速度。</p><blockquote><p>目前咱这边使用中科大源优于清华源。</p></blockquote>          </div><h3 id="更换步骤"><a href="#更换步骤" class="headerlink" title="更换步骤"></a>更换步骤</h3><blockquote><p>Ubuntu 系统中，软件源文件地址：<code>/etc/apt/sources.list</code></p></blockquote><ol><li><p>（选用）备份软件源</p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.backup</code></pre></div><blockquote><p>方便以后可以使用原来的软件源</p></blockquote></li><li><p><strong>添加中科大软件源</strong></p><ul><li><p><strong>有备份软件源情况</strong></p> <div class="code-wrapper"><pre><code class="hljs bash">sudo nano /etc/apt/sources.list</code></pre></div><p> 将之前的所有内容全部删除，然后添加如下内容。</p><blockquote><p>滚包的时候似乎更快。</p></blockquote></li><li><p><strong>无备份软件源</strong><br>直接复制内容，粘贴到文件最前面。</p></li></ul> <div class="note note-secondary">            <p>不同的 Ubuntu 发行版有不同的软件源，不同的地方只有字符中的 <strong>jammy</strong> 字样。这个是 <code>Ubuntu Codename</code> (别名)。可以执行 <code>lsb_release -a</code> 命令进行查看：</p><div class="code-wrapper"><pre><code class="hljs bash">muxiner@DESKTOP-ATVFS68:~$ lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription:    Ubuntu 22.04.1 LTSRelease:        22.04Codename:       jammy</code></pre></div><p>下方内容中的 <code>jammy</code> 字段需要根据自身 Ubuntu 版本情况进行更改。</p>          </div> <div class="code-wrapper"><pre><code class="hljs txt">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse multiverse</code></pre></div><p> 完成编辑后要保存。</p></li><li><p><strong>更新</strong></p><ul><li>更新源：<div class="code-wrapper"><pre><code class="hljs bash">sudo apt update</code></pre></div></li><li>如出现依赖问题，解决方式如下：<div class="code-wrapper"><pre><code class="hljs bash">sudo apt -f insatll</code></pre></div></li><li>更新软件：<div class="code-wrapper"><pre><code class="hljs bash">sudo apt upgrade</code></pre></div></li></ul></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">Ubuntu 镜像使用帮助</a></p><blockquote><p>这个真好，可以自己选择版本，然后直接复制。</p></blockquote><blockquote><p>也可以更换成科大源，替换字符：<code>tuna.tsinghua</code> $\rightarrow$ <code>lstc</code>，就行。</p></blockquote></li><li><p><a href="https://zhuanlan.zhihu.com/p/142014944">Ubuntu20.04软件源更换</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 安装 Colorls 美化命令行命令 ls</title>
    <link href="/ubuntu-install-colorls/"/>
    <url>/ubuntu-install-colorls/</url>
    
    <content type="html"><![CDATA[<p>先上效果图。</p><div class="note note-success">            <p>查看博客站点文件情况。</p><ol><li>使用 colorls 查看 站点根目录以及 posts 目录</li><li>未使用 colorls，即原 ls 查看 站点根目录以及 posts 目录</li></ol>          </div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221031210934-use-colorls.png" alt="使用 colorls 的效果"></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221031211106-not-colorls.png" alt="没有使用 colorls 的效果"></p><p>可见使用后，结果更加的好看，主要是有不同的<strong>字体颜色</strong>以及显示<strong>文件类型的图标</strong>。</p><h3 id="项目介绍-——-colorls"><a href="#项目介绍-——-colorls" class="headerlink" title="项目介绍 —— colorls"></a>项目介绍 —— colorls</h3><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221031211723-Color-Ls-github.png"></p><p><code>Color Ls</code> 是一个基于 <code>Ruby</code> 开发的脚本，能够添加颜色以及图标对 <code>ls</code> 结果输出进行着色。</p><h3 id="安装-colorls"><a href="#安装-colorls" class="headerlink" title="安装 colorls"></a>安装 colorls</h3><p>一共三步。</p><h4 id="安装-Ruby-以及相关依赖"><a href="#安装-Ruby-以及相关依赖" class="headerlink" title="安装 Ruby 以及相关依赖"></a>安装 Ruby 以及相关依赖</h4><div class="code-wrapper"><pre><code class="hljs bash">sudo apt install ruby ruby-dev ruby-colorize</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221031212518-install-ruby.png"></p><h4 id="安装并使用-Nerd-Fonts"><a href="#安装并使用-Nerd-Fonts" class="headerlink" title="安装并使用 Nerd Fonts"></a>安装并使用 Nerd Fonts</h4><p><a href="https://www.nerdfonts.com/font-downloads">Nerd Fonts Download</a></p><iframe src="https://www.nerdfonts.com/font-downloads" width="100%" height="320" name="topFrame" scrolling="yes"  noresize="noresize" frameborder="0" id="topFrame"></iframe><p>选择合适的字体并下载安装。</p><p>推荐几个：</p><ul><li>Cascadia Cove Nerd Font</li><li>Hack Nerd Font</li><li>JetBrainsMono Nerd Font</li></ul><div class="note note-success">            <p>Windows Terminal 中自带的 <code>Cascadia Mono</code> 字体也能用。</p>          </div><h4 id="安装-colorls-1"><a href="#安装-colorls-1" class="headerlink" title="安装 colorls"></a>安装 colorls</h4><div class="code-wrapper"><pre><code class="hljs bash">sudo gem install colorls</code></pre></div><p>正常情况下，成功安装：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221031213155-install-colorls-success.png"></p><p>那就还有不正常情况：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221031213856-install-colorls-error.png"></p><p>经过一番验证后，初步了解到，这是因为缺少编译程序必须的软件包 —— <code>build-essential</code>。</p><p>其作用是：<strong>提供编译程序必须软件包的列表信息。</strong></p><blockquote><p>也就是说编译程序有了这个软件包，它才知道，头文件在哪，才知道库函数在哪，还会下载依赖的软件包，最后才组成一个开发环境。</p></blockquote><p>一般来说 Ubuntu 都是自带该包的：</p><div class="code-wrapper"><pre><code class="hljs bash">muxiner@xxxxxxxxxxxxx:~$ sudo apt install build-essential[sudo] password <span class="hljs-keyword">for</span> muxiner:Reading package lists... DoneBuilding dependency tree... DoneReading state information... Donebuild-essential is already the newest version (12.9ubuntu3).0 upgraded, 0 newly installed, 0 to remove and 82 not upgraded.</code></pre></div><p>没有的话也可以使用 <code>sudo apt install build-essential</code> 进行安装，同时还会安装 C 语言编译器。</p><p>然后就可以快乐的安装 colorls 了。</p><h3 id="Colorls-的使用"><a href="#Colorls-的使用" class="headerlink" title="Colorls 的使用"></a>Colorls 的使用</h3><p>这个详见 <a href="https://github.com/athityakumar/colorls">https://github.com/athityakumar/colorls</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/athityakumar/colorls">colorls | github</a></li><li><a href="https://www.omgubuntu.co.uk/2017/07/add-bling-ls-bash-command-colorls">Add Bling to the ‘ls’ Bash Command with Colorls</a></li><li><a href="https://www.cnblogs.com/bing-yu12/p/6384447.html">build-essential 的作用</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>install</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 上安装 Linux 发行版 —— Ubuntu</title>
    <link href="/use-wsl2-ubuntu/"/>
    <url>/use-wsl2-ubuntu/</url>
    
    <content type="html"><![CDATA[<p>没啥好说的，直接开始安装教程。</p><div class="note note-primary">            <p>简单的介绍一下 <strong>WSL</strong>：</p><ul><li>适用于 Linux 的 Windows 子系统 —— 可让开发人员按原样运行 GNU&#x2F;Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。</li></ul><p>更多的信息可详见官方文档：</p><ul><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/">适用于 Linux 的 Windows 子系统文档</a><ul><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/about">什么是适用于 Linux 的 Windows 子系统 (WSL)？</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/compare-versions#whats-new-in-wsl-2">WSL 2 的新增功能</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/compare-versions">比较 WSL 1 和 WSL 2</a></li></ul></li></ul>          </div><h3 id="安装-WSL"><a href="#安装-WSL" class="headerlink" title="安装 WSL"></a>安装 WSL</h3><div class="note note-default">            <p><strong><code>WSL</code> 有 <code>Windows</code> 版本要求</strong>：<br>必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11。</p>          </div><ol><li><p>以<strong>管理员身份</strong>运行 PowerShell</p></li><li><p>安装 WSL</p><div class="code-wrapper"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--install</span></code></pre></div><p> 此命令将启用所需的可选组件，下载最新的 Linux 内核，将 WSL 2 设置为默认值，并安装 Linux 发行版（默认安装 Ubuntu）。</p><blockquote><p>执行完成后，需要重启计算机来安装在 Windows Server 2022 上运行 WSL 所需的全部内容。<strong>稍后再重启计算机。</strong></p></blockquote></li><li><p>启用适用于 Linux 的 Windows 子系统</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">Enable-WindowsOptionalFeature</span> <span class="hljs-literal">-Online</span> <span class="hljs-literal">-FeatureName</span> Microsoft<span class="hljs-literal">-Windows-Subsystem-Linux</span></code></pre></div> <div class="note note-warning">            <ul><li>必须启用“适用于 Linux 的 Windows 子系统”可选功能并重启，然后才能在 Windows 上运行 Linux 发行版。</li><li>依然以管理员身份运行 PowerShell。</li></ul>          </div></li><li><p>安装 Linux 分发版 —— Ubuntu</p><ul><li>打开 Microsoft Store，搜索 Ubuntu，下载。</li></ul></li><li><p>打开 Ubuntu，输入 username 和 password。</p></li></ol><p>结束。</p><div class="note note-primary">            <p>如果在安装过程中出现其他的问题，请自行搜索问题进行解决。</p>          </div><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">使用 WSL 在 Windows 上安装 Linux</a></li><li><a href="https://zhuanlan.zhihu.com/p/348813745">安装WSL2并下载配置Ubuntu</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>Linux</category>
      
      <category>WSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>wsl2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微软商店 Microsoft Store 的安装</title>
    <link href="/install-microsoft-store/"/>
    <url>/install-microsoft-store/</url>
    
    <content type="html"><![CDATA[<h3 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h3><p>简单说就是，当安装了比较干净的 windows 系统，如 <code>Windows 10 LTSC</code>，系统中没有类似于 Microsoft Store、图片查看器等等工具，但是又迫切的想要使用 Microsoft Store 用来下载或者安装某些软件时，就需要使用到 Microsoft Store。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>啥不会就 Goolge。</p><p>一番 Google 下来也看到了不少的方法：</p><ol><li>打开 powershell 执行一系列命令——失败<br>命令应该是可以的，不过并没有细究失败原因</li><li>打开某网站下载 Microsoft Store 软件包 —— 失败<br>这个应该也是可以的马，但是看他们说还需要安装一些依赖，有些复杂，咱暂时有些急迫去解决该问题，也就没有细究。</li><li>github 上有个项目傻瓜式安装<br>这个就是真简单了，下载包，根据指示可以一键安装。</li></ol><p>咱就简单说明一下方法三。</p><p>首先咱先附上该项目的地址：<a href="https://github.com/kkkgo/LTSC-Add-MicrosoftStore">LTSC-Add-MicrosoftStore</a></p><p>项目名字也是非常直白，针对 LTSC 的 Windows 版本增加 Microsoft Store。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20221028210543-ltsc-add-ms.png" alt="项目情况"></p><p>项目实现原理也十分明了，就是将 Microsoft Store 安装所需要的包以及依赖给咱准备好，同时还有 App Installer &#x2F; Purchase App &#x2F; Xbox 等安装需要的包以及依赖，然后编写一个 CMD 命令脚本，傻瓜式安装。</p><p>项目还提醒了：</p><blockquote><p>如果您不想安装 App Installer &#x2F; Purchase App &#x2F; Xbox，请在运行安装之前删除对应的. appxbundle 后缀的文件。<br>但是，如果您<strong>计划安装游戏，或带有购买选项的应用</strong>，则不要删除。</p></blockquote><p>所以基本上还是不需要删除什么文件的。</p><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ol><li>访问项目地址，下载项目文件<ul><li><a href="https://github.com/kkkgo/LTSC-Add-MicrosoftStore">LTSC-Add-MicrosoftStore</a></li><li><a href="https://github.com/lixuy/LTSC-Add-MicrosoftStore/archive/2019.zip">下载地址</a>：点击直接下载文件。</li></ul></li><li>解压文件</li><li>根据自身情况删除部分文件，或是不做修改</li><li>以<strong>管理员身份</strong>运行 <code>Add-Store.cmd</code></li><li>打开 Microsoft Store 检查安装是否成功</li></ol><div class="note note-info">            <ul><li><p>如果装完之后商店仍然打不开，请先重启试试。</p></li><li><p>如果仍然不行，请以管理员身份打开命令提示符并运行以下命令之后，然后再重启试试。</p> <div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">PowerShell</span> -ExecutionPolicy Unrestricted -Command <span class="hljs-string">&quot;&amp; &#123;<span class="hljs-variable">$manifest</span> = (Get-AppxPackage Microsoft.WindowsStore).InstallLocation + &#x27;\AppxManifest.xml&#x27; ; Add-AppxPackage -DisableDevelopmentMode -Register <span class="hljs-variable">$manifest</span>&#125;&quot;</span></code></pre></div></li></ul>          </div><div class="note note-default">            <p>商店修复：</p><ul><li><code>Win+R</code> 打开运行，输入 <code>WSReset.exe</code> 回车。<br>该命令会清空并重置 Windows Store 商店的所有缓存。</li></ul>          </div><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>用此方法安装的 Microsoft Store 以及其他软件版本教旧，可使用 Microsoft Store 进行更新。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>install</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 安装 WSL Ubuntu 出现错误代码：0x8007019e</title>
    <link href="/wsl-error-0x8007019e/"/>
    <url>/wsl-error-0x8007019e/</url>
    
    <content type="html"><![CDATA[<p>近期为了方便自己重装系统，准备整一个适用自己的系统镜像，想着给它也整个 WSL Ubuntu 省的后面重装后还麻烦。</p><p>由于咱选取了 <code>windows 10 企业版 LTSC</code>，为了搞 linux 子系统也是要费不少功夫，其他的先不谈，直接到 Ubuntu 的使用。</p><p>下载完 Ubuntu 后点击使用，一开始就出现该错误：</p><div class="code-wrapper"><pre><code class="hljs subunit">Installing, this may take a few minutes...Installation Failed!<span class="hljs-keyword">Error: </span>0x8007019ePress any key to continue...</code></pre></div><p>一番搜索后发现 —— <strong>未安装 Windows 子系统支持</strong></p><p><strong>解决办法</strong>：</p><ul><li><p>必须启用“适用于 Linux 的 Windows 子系统”可选功能并<strong>重启</strong>，然后才能在 Windows 上运行 Linux 发行版。</p></li><li><p>以管理员身份运行 <code>PowerShell</code>，并执行下列命令：</p><div class="code-wrapper"><pre><code class="hljs pwershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></pre></div></li></ul><p>重启完后打开 Ubuntu 等一会就行了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/cai1432452416/p/11748610.html">在windows应用商店安装ubuntu系统，报错WslRegisterDistribution failed with error: 0x8007019e</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-on-server">Windows Server 安装指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>install</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 文章加密</title>
    <link href="/hexo-blog-encrypt/"/>
    <url>/hexo-blog-encrypt/</url>
    
    <content type="html"><![CDATA[<h3 id="丑话在先"><a href="#丑话在先" class="headerlink" title="丑话在先"></a>丑话在先</h3><p>本来是没有什么文章内容需要加密的，不过现在突然发现我可以使用博客文章记录一下咱喜欢的 <a href="pixiv.net">Pixiv</a> 画师，如果是正常的插画，就不需要加密，不过嘛，我喜欢的多少需要一点科学观看，所以还是使用加密，就自己看看吧。</p><p>本是记得 hexo 的文章信息头可以加入 <code>password</code> 的字段，不过搜索后发现还需要安装一个 hexo 扩展：<code>hexo-blog-encrypt</code>。</p><p>于是记录一下。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>一旦你输入了正确的密码，它就会被存储在本地浏览器的 <code>localStorage</code> 中。按个按钮，密码将会被清空。若博客中有脚本，它将被正确地执行。</li><li>支持按标签加密。</li><li>所有的核心功能都是由原生的 <code>API</code> 所提供的。在 <code>Node.js</code> 中，我们使用 <code>Crypto</code>。在浏览器中，我们使用 <code>Web Crypto API</code>。</li><li><code>PBKDF2</code>，<code>SHA256</code> 被用作复制密钥，<code>AES256-CBC</code> 被用作加解密，我们还使用 <code>HMAC</code> 来验证密文的来源，并确保其纠正。</li><li>广泛地使用 <code>Promise</code> 来进行异步操作，从而确保线程不被杜塞。</li><li>过时的浏览器将无法正常显示，因此，请升级您的浏览器。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><div class="code-wrapper"><pre><code class="hljs powershell">npm install <span class="hljs-literal">--save</span> hexo<span class="hljs-literal">-blog-encrypt</span></code></pre></div><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>将 <code>password</code> 添加到文章信息头：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020-03-13 21:12:21</span><span class="hljs-attr">password:</span> <span class="hljs-string">muyiio</span><span class="hljs-meta">---</span></code></pre></div><h3 id="按照标签加密"><a href="#按照标签加密" class="headerlink" title="按照标签加密"></a>按照标签加密</h3><h4 id="1-修改文章信息头"><a href="#1-修改文章信息头" class="headerlink" title="1. 修改文章信息头"></a>1. 修改文章信息头</h4><div class="code-wrapper"><pre><code class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><span class="hljs-attr">tags:</span><span class="hljs-bullet">-</span> <span class="hljs-string">加密文章tag</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020-03-13 21:12:21</span><span class="hljs-attr">password:</span> <span class="hljs-string">muyiio</span><span class="hljs-attr">abstract:</span> <span class="hljs-string">这里有东西被加密了，需要输入密码查看哦。</span><span class="hljs-attr">message:</span> <span class="hljs-string">您好，这里需要密码。</span><span class="hljs-attr">wrong_pass_message:</span> <span class="hljs-string">抱歉，这个密码看着不太对，请再试试。</span><span class="hljs-attr">wrong_hash_message:</span> <span class="hljs-string">抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。</span><span class="hljs-meta">---</span></code></pre></div></code></pre><h4 id="2-修改博客本目录-config-yml。添加如下字段"><a href="#2-修改博客本目录-config-yml。添加如下字段" class="headerlink" title="2. 修改博客本目录 _config.yml。添加如下字段"></a>2. 修改博客本目录 <code>_config.yml</code>。添加如下字段</h4><div class="code-wrapper"><pre><code class="hljs"><pre><code class="hljs handlebars"><span class="language-xml"># 安全</span><span class="language-xml">encrypt: # hexo-blog-encrypt</span><span class="language-xml">    abstract: 这里有东西被加密了，需要输入密码查看哦。</span><span class="language-xml">    message: 您好, 这里需要密码.</span><span class="language-xml">    tags:</span><span class="language-xml">    - &#123;name: tagName, password: 密码A&#125;</span><span class="language-xml">    - &#123;name: tagName, password: 密码B&#125;</span><span class="language-xml">    template: <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hexo-blog-encrypt&quot;</span> <span class="hljs-attr">data-wpm</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">hbeWrongPassMessage</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">data-whm</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">hbeWrongHashMessage</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hbe-input-container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hbePass&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">hbeMessage</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">hbeMessage</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottom-line&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hbeData&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hbeData&quot;</span> <span class="hljs-attr">data-hmacdigest</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">hbeHmacDigest</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">hbeEncryptedData</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</span><span class="language-xml">    wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span></code></pre></div></code></pre><h3 id="DLC"><a href="#DLC" class="headerlink" title="DLC"></a>DLC</h3><p>记录下咱没有用到的内容。</p><p><strong>对 TOC 文章进行加密</strong></p><p>如果有一篇文章使用了 <code>TOC</code>，需要修改模板的部分代码。这里以 <code>matery</code> 主题作为示例：</p><p>在 <code>hexo/themes/matery/layout/_partial/article.ejs</code> 找到 <code>article.ejs</code>。<br>然后找到 <code>&lt;％post.content％&gt;</code> 这段代码，通常在 30 行左右。<br>使用如下的代码来替代它：</p><div class="code-wrapper"><pre><code class="hljs xquery">&lt;% <span class="hljs-keyword">if</span>(post.toc ==<span class="hljs-built_in"> true</span>)&#123; %&gt;  &lt;div<span class="hljs-built_in"> id</span>=<span class="hljs-string">&quot;toc-div&quot;</span> class=<span class="hljs-string">&quot;toc-article&quot;</span> &lt;% <span class="hljs-keyword">if</span> (post.encrypt ==<span class="hljs-built_in"> true</span>) &#123; %&gt;style=<span class="hljs-string">&quot;display:none&quot;</span> &lt;% &#125; %&gt;&gt;    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;toc-title&quot;</span>&gt;</span>Index<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>      &lt;% <span class="hljs-keyword">if</span> (post.encrypt ==<span class="hljs-built_in"> true</span>) &#123; %&gt;        &lt;<span class="hljs-meta">%-</span> toc(post.origin, &#123;list_number:<span class="hljs-built_in"> true</span>&#125;) %&gt;      &lt;% &#125; <span class="hljs-keyword">else</span> &#123; %&gt;        &lt;<span class="hljs-meta">%-</span> toc(post.content, &#123;list_number:<span class="hljs-built_in"> true</span>&#125;) %&gt;      &lt;% &#125; %&gt;  &lt;/div&gt;&lt;% &#125; %&gt;&lt;<span class="hljs-meta">%-</span> post.content %&gt;</code></pre></div><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/D0n9X1n/hexo-blog-encrypt">hexo-blog-encrypt</a></li><li><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">hexo-blog-encrypt | 中文</a></li><li><a href="https://zhuanlan.zhihu.com/p/113235573">对 Hexo 博客文章进行加密</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 出现 Unable to mkstemp 等问题解决</title>
    <link href="/ubuntu-error-unable-to-mkstemp/"/>
    <url>/ubuntu-error-unable-to-mkstemp/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在使用 WSL Ubuntu 进行软件更新或软件下载时，出现如下问题：</p><div class="code-wrapper"><pre><code class="hljs bash">$ sudo apt install xxx[sudo] password <span class="hljs-keyword">for</span> xxxxxx:Reading package lists... Error!E: Unable to mkstemp /tmp/clearsigned.message.r1RilL - GetTempFile (20: Not a directory)E: The package lists or status file could not be parsed or opened.</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">$ sudo apt updateE: Unable to mkstemp /tmp/clearsigned.message.u1lbd8 - GetTempFile (20: Not a directory)E: The package lists or status file could not be parsed or opened.</code></pre></div><p>造成软件更新或下载失败。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>想起之前在这 ubuntu 做使用，看到 <code>/tmp</code> 非空，且了解到：</p><blockquote><p>&#x2F;tmp&#x2F;    存储系统和用户的临时信息。<br>就想着删除 <code>/tmp</code> 目录下的内容，于是直接动手。</p></blockquote><p>然而，删除完后， <code>/tmp</code> 目录就在是出问题：</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /tmp-bash: <span class="hljs-built_in">cd</span>: /tmp: Not a directory$ <span class="hljs-built_in">mkdir</span> -p /tmp<span class="hljs-built_in">mkdir</span>: cannot create directory ‘/tmp’: File exists</code></pre></div><p>刚开始没当回事，以为重启就没事，也就没在乎。</p><p>哪知过几天再来使用 ubuntu 时，更新或下载软件时出现上述问题。</p><p>然后开始询问度娘，搜索到“误删 <code>/tmp</code> 目录”等等的解决方法。</p><p><strong>思路很简单，就是删除 &#x2F;tmp 再重新创建 &#x2F;tmp。</strong></p><p><strong>命令如下：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> -r /tmpsudo <span class="hljs-built_in">mkdir</span> /tmp</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Git 时网络问题（代理）解决</title>
    <link href="/git-proxy-error/"/>
    <url>/git-proxy-error/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用 git 命令执行与 github 相关命令失败的错误提示，如下：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment">## station one</span>OpenSSL SSL_read: Connection was reset, errno <span class="hljs-number">10054</span><span class="hljs-comment">## station two</span>Failed to connect to github.com port <span class="hljs-number">443</span> after <span class="hljs-number">21098</span> ms: Timed out</code></pre></div><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>简而言之，github 被墙，走代理，然而设置不正确。</p><p>修改一下就好。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>执行下述命令（根据自身情况做适当修改）：</p><div class="code-wrapper"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> <span class="hljs-literal">--unset</span> socks5.proxygit config <span class="hljs-literal">--global</span> socks5.proxy <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:xxxx<span class="hljs-comment">### xxxx 为端口号</span></code></pre></div><div class="note note-primary">            <p>没法解决问题的话，就得对症下药，如 DNS 问题就干嘛干嘛之类的。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>水博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更改终端显示语言</title>
    <link href="/console-lang=en/"/>
    <url>/console-lang=en/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>将 linux (arch) 的语言设置为中文后，不仅是显示语言成功设置为中文，就连终端的显示（提示）语言也是中文，使用起来，总有种奇怪的感觉，觉得奇怪是因为习惯了全英文的终端显示。</p><p>所以想要将终端显示设置回英文。</p><p>经过多番搜索后，终于找到一个不错的解决方案。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p><strong>打开终端</strong></p></li><li><p><strong>使用命令 <code>echo $0</code> 或是 <code>echo $SHELL</code> 查看当前使用的 <code>Shell</code>：</strong></p> <div class="code-wrapper"><pre><code class="hljs bash">xxxx@xxxxx: ~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$0</span>/bin/bash</code></pre></div> <div class="code-wrapper"><pre><code class="hljs bash">xxxx@xxxxx: ~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>/bin/bash</code></pre></div><blockquote><p>一般 <code>shell</code> 类型：<code>bash</code>、<code>zsh</code>。</p></blockquote></li><li><p><strong>使用编辑器打开配置文件</strong><br> 编辑器可选取：<code>Vim</code>、<code>nano</code>。<br> <code>bash</code> 的（用户）配置文件：<code>.bashrc</code> 或是 <code>.bash_profile</code></p><blockquote><p>编辑任一即可<br><code>zsh</code> 的（用户）配置文件：<code>.zshrc</code></p></blockquote><p> 输入命令编辑器打开配置文件：</p> <div class="code-wrapper"><pre><code class="hljs bash">nano ~/.bashrc</code></pre></div></li><li><p><strong>编辑配置文件</strong><br> 在文件中加入下述内容：</p> <div class="code-wrapper"><pre><code class="hljs txt">if [ &quot;$TERM&quot;=&quot;linux&quot; ] ;then export LANG=en_US.UTF-8 export LANGUAGE=en_US fi</code></pre></div><p> 保存。</p></li><li><p><strong>使配置文件生效</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc</code></pre></div><blockquote><p><code>zsh</code> 的配置文件生效命令同理。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>console</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Gurb 进行多系统引导，并使用主题美化 Grub 界面</title>
    <link href="/linux-gurb-beauty/"/>
    <url>/linux-gurb-beauty/</url>
    
    <content type="html"><![CDATA[<p>咕咕咕，开始。</p><div class="note note-primary">            <p><strong>2022-07-24</strong> 更新：简单记录一下，未能添加前后对比图</p>          </div><h3 id="更改-Deepin-的系统引导为-grub"><a href="#更改-Deepin-的系统引导为-grub" class="headerlink" title="更改 Deepin 的系统引导为 grub"></a>更改 Deepin 的系统引导为 grub</h3><ol><li><p><code>ctrl + alt + T</code> 打开终端，查看 <code>efi</code> 的挂载点</p> <div class="code-wrapper"><pre><code class="hljs bash">lsblk<span class="hljs-comment"># 查看 /boot/efi 的挂载点 </span></code></pre></div><p> 查询到 <code>/boot/efi</code> 的挂载点是：<code>/dev/sda1</code></p></li><li><p>安装 <code>grub</code> 到 <code>efi</code> 挂载点</p><div class="code-wrapper"><pre><code class="hljs bash">sudo grub-install /dev/sda1</code></pre></div><blockquote><p>安装成功时会提示下述内容：<br>Installation finished. No error reported.<br>若是中文界面的终端：<br>安装完成。没有错错误报告。</p></blockquote></li></ol><h3 id="美化-grub-引导界面"><a href="#美化-grub-引导界面" class="headerlink" title="美化 grub 引导界面"></a>美化 grub 引导界面</h3><h4 id="下载个人所喜欢的主题"><a href="#下载个人所喜欢的主题" class="headerlink" title="下载个人所喜欢的主题"></a>下载个人所喜欢的主题</h4><p>主题网站：<a href="https://www.gnome-look.org/browse?cat=109&ord=rating">GMOME-LOOK.ORG | GRUB THEME</a></p><p>个人选择了 <code>Vimix</code> 主题。主题路径：<a href="https://www.gnome-look.org/p/1009236">Grub-theme-vimix</a></p><blockquote><p>部分主题拥有适用于不同分辨率显示屏的版本，鉴于个人机器的硬件水平酌情选择，如：<br><code>1080p</code>、<code>4k</code>、<code>2k</code>。</p></blockquote><p>下载方式：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220724221058.png"></p><p>或是：</p><p>点击 <code>files</code>，再选择对应分辨率的文件。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220724221532.png"></p><h4 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h4><ol><li><p>解压主题：</p><ul><li>使用命令行解压：   <div class="code-wrapper"><pre><code class="hljs bash">tar -Jxf Vimix-1080p.tar.xz<span class="hljs-comment"># tar -Jxf Vimix-2k.tar.xz</span><span class="hljs-comment"># tar -Jxf Vimix-4k.tar.xz</span></code></pre></div> 选择合适的命令解压。</li><li>使用文件系统解压。</li></ul></li><li><p>放置主题文件<br>将解压出来的主题文件放置到系统的 <code>grub</code> 主题文件中去。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> Vimix /usr/share/grub/themes/Vimix -rf</code></pre></div><blockquote><p>上述命令执行时，<strong>所在的路径为 Vimix 文件夹所在路径</strong>。</p></blockquote></li><li><p>修改系统配置</p><p> 编辑 grub 文件。</p> <div class="code-wrapper"><pre><code class="hljs bash">sudo nano /etc/default/grub</code></pre></div><blockquote><p>根据个人喜好选择编辑器如，nano、vim。</p></blockquote><p> 然后修改 GRUB_THEME，这是 grub 的主题设置，默认注释掉。<br> 直接插入一行代码：</p> <div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">GRUB_THEME</span>=<span class="hljs-string">&quot;/usr/share/grub/themes/vimix/theme.txt&quot;</span></code></pre></div><blockquote><p>修改了引号中的路径，指向我们自定的主题文件的 <code>theme.txt</code>。</p></blockquote></li></ol><h4 id="更新-grub-cfg-文件"><a href="#更新-grub-cfg-文件" class="headerlink" title="更新 grub.cfg 文件"></a>更新 <code>grub.cfg</code> 文件</h4><p>执行命令更新 <code>grub.cfg</code> 文件，使我们上述所作的设置生效。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo update-grub</code></pre></div><h3 id="重启查看效果"><a href="#重启查看效果" class="headerlink" title="重启查看效果"></a>重启查看效果</h3><p>执行命令命令重启电脑：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo reboot</code></pre></div><p>或是可视化的点点点，重启电脑。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch Linux</tag>
      
      <tag>Grub</tag>
      
      <tag>Beauty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好东西就记录下来.jpg</title>
    <link href="/good-skills-record/"/>
    <url>/good-skills-record/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><strong>2022-07-12</strong> 更新</p>          </div><h3 id="PowerShell-获取系统时间"><a href="#PowerShell-获取系统时间" class="headerlink" title="PowerShell 获取系统时间"></a>PowerShell 获取系统时间</h3><blockquote><p>人懒不想每次写博文、更新博文时手敲日期和时间，就想偷懒，使用命令行格式化输出想要的时间。</p></blockquote><blockquote><p>较多使用 Windows 系统，因为使用 PowerShell 获取时间。</p></blockquote><p><strong>基础命令</strong>：</p><ul><li><code>Get-Date</code>: 获取当前<strong>时间</strong></li><li><code>Get-Date -Format &#39;yyyy&#39;</code>: 获取当前<strong>年份</strong></li><li><code>Get-Date -Format &#39;MM&#39;</code>: 获取当前<strong>月份</strong></li><li><code>Get-Date -Format &#39;dd&#39;</code>: 获取当前<strong>日</strong></li><li><code>Get-Date -Format &#39;HH&#39;</code>: 获取当前<strong>时</strong>（24 小时制）</li><li><code>Get-Date -Format &#39;hh&#39;</code>: 获取当前<strong>时</strong>（12 小时制）</li><li><code>Get-Date -Format &#39;mm&#39;</code>: 获取当前<strong>分</strong></li><li><code>Get-Date -Format &#39;ss&#39;</code>: 获取当前<strong>秒</strong></li></ul><p><span style="color: #02b2ff; ">自由组合一下获得格式化的日期或者时间：</span></p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> <span class="hljs-string">&#x27;yyyy-MM-dd&#x27;</span><span class="hljs-comment"># 2022-07-12</span><span class="hljs-built_in">Get-Date</span><span class="hljs-comment"># 2022年7月12日 17:47:14</span><span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> <span class="hljs-string">&#x27;HH:mm:ss&#x27;</span><span class="hljs-comment"># 17:47:56</span><span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> <span class="hljs-string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span><span class="hljs-comment"># 2022-07-12 17:48:25</span><span class="hljs-built_in">Get-Date</span> <span class="hljs-literal">-Format</span> <span class="hljs-string">&#x27;yyyy年M月dd日 HH时mm分ss秒&#x27;</span><span class="hljs-comment"># 2022年7月12日 17时52分42秒</span></code></pre></div><p>但是每次获取格式化时间时都需要输入这么多字符也很麻烦，那就使用 alias：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Function now &#123;get-date -format &quot;yyyy-MM-d HH:mm:ss&quot;&#125;&#x27;</span> &gt;&gt; <span class="hljs-variable">$profile</span></code></pre></div><blockquote><p>意思就是，将 <code>Function now &#123;get-date -format &quot;yyyy-MM-d HH:mm:ss&quot;&#125;</code> 追加到 <code>$PROFILE</code> 文件里。<br>上述命令含义是：<code>now</code> 代替 <code>get-date -format &quot;yyyy-MM-d HH:mm:ss&quot;</code>。<br>二者效果相同。</p></blockquote><h2 id="然后："><a href="#然后：" class="headerlink" title="然后："></a>然后：<br><div class="code-wrapper"><pre><code class="hljs powershell">now<span class="hljs-comment"># 2022-07-12 18:01:15</span></code></pre></div></h2><div class="note note-primary">            <p><strong>2023-02-21</strong> 更新</p>          </div><h3 id="Windows-下的-Redis-安装及简单使用"><a href="#Windows-下的-Redis-安装及简单使用" class="headerlink" title="Windows 下的 Redis 安装及简单使用"></a>Windows 下的 Redis 安装及简单使用</h3><p>平台：<strong>Windows</strong></p><h4 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h4><p>Redis 下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p><p>选择 <code>Redis-x64-x.x.xxx.msi</code> 下载，安装。</p><p>使用 msi 安装可自行添加<strong>系统环境变量</strong>。</p><h4 id="Redis-使用"><a href="#Redis-使用" class="headerlink" title="Redis 使用"></a>Redis 使用</h4><p>未添加 Redis 的路径到系统环境变量，需要在 Redis 的安装路径启动 CMD&#x2F;Powershell 等等。</p><p>添加了环境变量可直接使用下述指令：</p><ul><li><p>启动 redis：</p><div class="code-wrapper"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span>.exe redis.windows.conf<span class="hljs-meta"># 或 redis-server redis.windows.conf</span><span class="hljs-meta"># 或 redis-server</span></code></pre></div></li><li><p>关闭 redis：<br>任选一：</p><ul><li>关掉命令行窗口</li><li><code>Ctrl + C</code></li></ul></li><li><p>访问 redis 服务端：</p><div class="code-wrapper"><pre><code class="hljs stylus">redis-cli<span class="hljs-selector-class">.exe</span> -h <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span>或 redis-cli -h <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span></code></pre></div></li><li><p>redis 作为 windows 服务启动方式</p><div class="code-wrapper"><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> <span class="hljs-comment">--service-install redis.windows.conf</span></code></pre></div><p>启动服务：<code>redis-server --service-start</code><br>停止服务：<code>redis-server --service-stop</code></p></li><li><p>移除 redis 的 Windows 服务</p><div class="code-wrapper"><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span>.exe <span class="hljs-comment">--service-uninstall</span># 或 redis-<span class="hljs-keyword">server</span> <span class="hljs-comment">--service-uninstall</span></code></pre></div></li></ul><div class="note note-primary">            <p><strong>2023-03-29</strong> 更新</p>          </div><h3 id="Linux-Shell-获取系统时间"><a href="#Linux-Shell-获取系统时间" class="headerlink" title="Linux Shell 获取系统时间"></a>Linux Shell 获取系统时间</h3><p>Linux <code>date</code> 命令可以显示或者设定系统的日期和时间。</p><p><strong>语法</strong></p><div class="code-wrapper"><pre><code class="hljs zsh">date [OPTION]... [+FORMAT]date [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help] [--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]</code></pre></div><p><strong>可选参数：</strong></p><ul><li><code>-d, --date=STRING</code>：<br>通过字符串显示时间格式，字符串不能是’now’。</li><li><code>-f, --file=DATEFILE</code>：<br>类似于–date; 一次从DATEFILE处理一行。</li><li><code>-I[FMT], --iso-8601[=FMT]</code>：<br>按照 ISO 8601 格式输出时间，FMT 可以为’date’(默认)，’hours’，’minutes’，’seconds’，’ns’。 可用于设置日期和时间的精度，例如：2006-08-14T02:34:56-0600。</li><li><code>-R, --rfc-2822</code>：<br>按照 RFC 5322 格式输出时间和日期，例如: Mon, 14 Aug 2006 02:34:56 -0600。</li><li><code>--rfc-3339=FMT</code>：<br>按照 RFC 3339 格式输出，FMT 可以为’date’, ‘seconds’,’ns’中的一个，可用于设置日期和时间的精度， 例如：2006-08-14 02:34:56-06:00。</li><li><code>-r, --reference=FILE</code>：<br>显示文件的上次修改时间。</li><li><code>-s, --set=STRING</code>：<br>根据字符串设置系统时间。</li><li><code>-u, --utc, --universal</code>：<br>显示或设置协调世界时(UTC)。</li><li><code>--help</code>：<br>显示帮助信息。</li><li><code>--version</code>：<br>输出版本信息。</li></ul><p><strong>FORMAT 参数:</strong><br>在显示方面，使用者可以设定欲显示的格式 ，格式设定为一个加号后接数个标记，其中可用的标记列表如下：</p><div class="code-wrapper"><pre><code class="hljs txt">%%     输出字符 %%a     星期几的缩写 (Sun..Sat)%A     星期的完整名称(Sunday..Saturday)。 %b     缩写的月份名称（例如，Jan）%B     完整的月份名称（例如，January）%c     本地日期和时间（例如，Thu Mar  3 23:05:25 2005）%C     世纪，和%Y类似，但是省略后两位（例如，20）%d     日 (01..31)%D     日期，等价于%m/%d/%y%e     一月中的一天，格式使用空格填充，等价于%_d%F     完整的日期；等价于 %Y-%m-%d%g     ISO 标准计数周的年份的最后两位数字%G     ISO 标准计数周的年份，通常只对%V有用%h     等价于 %b%H     小时 (00..23)%I     小时 (01..12)%j     一年中的第几天 (001..366)%k     小时，使用空格填充 ( 0..23); 等价于 %_H%l     小时, 使用空格填充 ( 1..12); 等价于 %_I%m     月份 (01..12)%M     分钟 (00..59)%n     新的一行，换行符%N     纳秒 (000000000..999999999)%p     用于表示当地的AM或PM，如果未知则为空白%P     类似 %p, 但是是小写的%r     本地的 12 小时制时间(例如 11:11:04 PM)%R     24 小时制 的小时与分钟; 等价于 %H:%M%s     自 1970-01-01 00:00:00 UTC 到现在的秒数%S     秒 (00..60)%t     插入水平制表符 tab%T     时间; 等价于 %H:%M:%S%u     一周中的一天 (1..7); 1 表示星期一%U     一年中的第几周，周日作为一周的起始 (00..53)%V     ISO 标准计数周，该方法将周一作为一周的起始 (01..53)%w     一周中的一天（0..6），0代表星期天%W     一年中的第几周，周一作为一周的起始（00..53）%x     本地的日期格式（例如，12/31/99）%X     本地的日期格式（例如，23:13:48）%y     年份后两位数字 (00..99)%Y     年%z     +hhmm 格式的数值化时区格式（例如，-0400）%:z    +hh:mm 格式的数值化时区格式（例如，-04:00）%::z   +hh:mm:ss格式的数值化时区格式（例如，-04:00:00）%:::z  数值化时区格式，相比上一个格式增加&#x27;:&#x27;以显示必要的精度（例如，-04，+05:30）%Z     时区缩写 （如 EDT）</code></pre></div><p><strong>一些简单示例：</strong></p><div class="code-wrapper"><pre><code class="hljs zsh">$ date2023年03月29日 20:07:46# 当前年月日$ date +%F2023-03-29# 当前时分$ date +%R21:06# 当前时分秒$ date +%T21:06:34# 当前星期$ date +%A星期三# 组合输出日期，分隔符 /$ date +%Y/%m/%d2023/03/29# 组合输出日期，分隔符 -$ date +%Y-%m-%d2023-03-29# 输出时分秒，分隔符 :$ date +%H:%M:%S21:10:11# 输出年月日时分秒$ date +%F%n%T2023-03-2921:10:22</code></pre></div><p>还可以使用 <code>echo $()</code> 括号中间加 date 命令。</p><div class="code-wrapper"><pre><code class="hljs zsh">$ echo $(date +%F%n%T)2023-03-29 21:12:59</code></pre></div><p>还可以将需要常用的命令设置别名，以方便简便使用：</p><div class="code-wrapper"><pre><code class="hljs zsh">alias datetime=&#x27;echo $(date +%F%n%T)&#x27;</code></pre></div><p>并将其添加到 <code>~/.zshrc</code> 或者 <code>~/.bashrc</code> 中。<br>再 <code>source ~/.zshrc</code> 或者 <code>source ~/.bashrc</code>。</p><div class="code-wrapper"><pre><code class="hljs zsh">$ datetime2023-03-29 21:40:39</code></pre></div><h3 id="MV-使用"><a href="#MV-使用" class="headerlink" title="MV 使用"></a>MV 使用</h3><p>{ % note info % }<br>2023-06-12 20:29:38 更新。<br>{ % endnote % }</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 find 命令查找源目录下的所有文件，并使用 mv 命令移动到目标目录</span>find <span class="hljs-string">&quot;<span class="hljs-variable">$source_dir</span>&quot;</span> -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">mv</span> &#123;&#125; <span class="hljs-string">&quot;<span class="hljs-variable">$target_dir</span>&quot;</span> \;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skills</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio Code 插件使用记录</title>
    <link href="/vscode-plugins/"/>
    <url>/vscode-plugins/</url>
    
    <content type="html"><![CDATA[<h3 id="更新情况"><a href="#更新情况" class="headerlink" title="更新情况"></a>更新情况</h3><div class="note note-primary">            <p><strong>2022-07-12</strong> 更新：</p><ul><li>添加 <span class="label label-info"><a href="#C-C-Plugins" title="vs code C\C++插件">C\C++ Plugins</a></span>：<span class="label label-default"><a href="#1-C-C">C\C++</a></span>、<span class="label label-default"><a href="#2-C-x2F-C-Extension-Pack">C&#x2F;C++ Extension Pack</a></span></li><li>添加 <span class="label label-info"><a href="#美化" title="vs code 美化插件">美化</a></span>：<span class="label label-default"><a href="#2-One-Dark-Pro">One Dark Pro</a></span>、<span class="label label-default"><a href="#1-Beauty">Beauty</a></span></li><li>添加 <span class="label label-info"><a href="#汉化" title="vs code 汉化插件">汉化</a></span>：<span class="label label-default"><a href="#Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio">Chinese (Simplified) (简体中文) Language Pack for Visual Studio</a></span></li><li>添加 <span class="label label-info"><a href="#Markdown" title="vs code 汉化插件">Markdown</a></span>：<span class="label label-default"><a href="#1-Markdown-All-in-One">Markdown All in One</a></span>、<span class="label label-default"><a href="#2-Markdown-PDF">Markdown PDF</a></span></li><li>添加 <span class="label label-info"><a href="#Python" title="vs code python 插件">Python</a></span>：<span class="label label-default"><a href="#1-Python">Python</a></span>、<span class="label label-default"><a href="#2-Pylance">Pylance</a></span></li></ul>          </div><div class="note note-primary">            <p><strong>2022-07-16</strong> 更新：</p><ul><li><span class="label label-info">美化</span> 添加：<span class="label label-default"><a href="#2-Material-Icon-Theme">Material Icon Theme</a></span>、<span class="label label-default"><a href="#3-vscode-icons">vscode-icons</a></span></li><li>添加 <span class="label label-info"><a href="#前端" title="vs code 前端插件">前端</a></span>：<span class="label label-default"><a href="#1-Live-Server">Live Server</a></span>、<span class="label label-default"><a href="#2-Auto-Complete-Tag">Auto Complete Tag</a></span>、<span class="label label-default"><a href="#3-Auto-Rename-Tag">Auto Rename Tag</a></span>、<span class="label label-default"><a href="#4-Auto-Close-Tag">Auto Close Tag</a></span>、<span class="label label-default"><a href="#5-CSS-Peek">CSS Peek</a></span>、<span class="label label-default"><a href="#6-HTML-CSS-Support">HTML CSS Support</a></span></li><li>添加 <span class="label label-info"><a href="#高效率工具" title="vs code 高效率工具插件">高效率工具</a></span>：<span class="label label-default"><a href="#1-Path-Intellisense">Path Intellisense</a></span>、<span class="label label-default"><a href="#2-Bracket-Pair-Colorization-Toggler">Bracket Pair Colorization Toggler</a></span></li></ul>          </div><h3 id="C-C-Plugins"><a href="#C-C-Plugins" class="headerlink" title="C\C++ Plugins"></a>C\C++ Plugins</h3><div class="note note-info">            <p>关于 windows 下 VS code C\C++ 环境的配置：<a class="btn" href="https://muxiner.github.io/2022/04/19/vscode-env-c-new/#"  target="_blank">Windows 下 VS code 配置 C&#x2F;C++ 环境</a></p>          </div><h4 id="1-C-C"><a href="#1-C-C" class="headerlink" title="1. C\C++"></a>1. C\C++</h4><p><a id='C\C++'></a></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712185147.png"></p><p>C&#x2F;C++ 扩展为 Visual Studio Code 添加了对 C&#x2F;C++ 的语言支持，包括 IntelliSense 和调试等功能。</p><blockquote><p>是在 vs code 上面使用 C\C++ 的必要插件。</p></blockquote><h4 id="2-C-x2F-C-Extension-Pack"><a href="#2-C-x2F-C-Extension-Pack" class="headerlink" title="2. C&#x2F;C++ Extension Pack"></a>2. C&#x2F;C++ Extension Pack</h4><p><a id='C/C++Extension-Pack'></a></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712185921.png"></p><p>此扩展包包括一组用于 Visual Studio Code 中 C++ 开发的流行扩展。</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C&#x2F;C++</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-themes">C&#x2F;C++ Themes</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=twxs.cmake">CMake</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">CMake Tools</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=cschlosser.doxdocgen">Doxygen Documentation Generator</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=jeff-hykin.better-cpp-syntax">Better C++ Syntax</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack">Remote Development Extension Pack</a></li></ul><blockquote><p>推荐 C\C++ 插件的插件呀。</p></blockquote><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><h3 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h3><h4 id="1-Beauty"><a href="#1-Beauty" class="headerlink" title="1. Beauty"></a>1. Beauty</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712191137.png"></p><p>Beauty 是 Web 开发中 VSCODE 的代码美化器扩展。<br>它支持多种语言，如 javascript, css, less, python, jsx, markups(html, swig, nunjucks)…等。</p><blockquote><p>不格式化其他的编程语言吗。</p></blockquote><h4 id="2-One-Dark-Pro"><a href="#2-One-Dark-Pro" class="headerlink" title="2. One Dark Pro"></a>2. One Dark Pro</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712191628.png"></p><p><code>Atom</code> 用于 <code>Visual Studio Code</code> 的标志性 <code>One Dark</code> 主题。</p><blockquote><p>很好看的主题呀。</p></blockquote><h4 id="2-Material-Icon-Theme"><a href="#2-Material-Icon-Theme" class="headerlink" title="2. Material Icon Theme"></a>2. Material Icon Theme</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716174638.png"></p><p>Get the Material Design icons into your VS Code.</p><blockquote><p>这个图标还挺好看的呢。<br>想看清楚的图标的话，需要去官方的 <a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">MarketPlace</a> 看一看吧。</p></blockquote><h4 id="3-vscode-icons"><a href="#3-vscode-icons" class="headerlink" title="3. vscode-icons"></a>3. vscode-icons</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716181801.png"></p><p>vscode 团队设计的图标库，还可以，但是在我看来，没上一个好看哦。</p><h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><h4 id="Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio"><a href="#Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio" class="headerlink" title="Chinese (Simplified) (简体中文) Language Pack for Visual Studio"></a>Chinese (Simplified) (简体中文) Language Pack for Visual Studio</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712192229.png"></p><p>此中文（简体）语言包为 VS Code 提供本地化界面。</p><blockquote><p>英文不友好者狂喜插件。</p></blockquote><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><h4 id="1-Markdown-All-in-One"><a href="#1-Markdown-All-in-One" class="headerlink" title="1. Markdown All in One"></a>1. Markdown All in One</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712192533.png"></p><p><code>Visual Studio Code</code> 的 <code>Markdown</code> 支持。</p><blockquote><p>将 <code>vscode</code> 作为 <code>markdown</code> 编辑器的话就需要这个了。</p></blockquote><h4 id="2-Markdown-PDF"><a href="#2-Markdown-PDF" class="headerlink" title="2. Markdown PDF"></a>2. Markdown PDF</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712192745.png"></p><p>此扩展将 <code>Markdown</code> 文件转换为 <code>pdf</code>、<code>html</code>、<code>png</code> 或 <code>jpeg</code> 文件。</p><blockquote><p>导出 <code>markdown</code> 文件需要的插件。</p></blockquote><div class="note note-info">            <p>如果导出文件时数学公式不正确，可见：<a class="btn" href="https://muxiner.github.io/2022/04/18/vscode-markdown-pdf-math-latex-error/"  target="_blank">VS code Markdown 导出 PDF 时，数学公式未能正确导出</a></p>          </div><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="1-Python"><a href="#1-Python" class="headerlink" title="1. Python"></a>1. Python</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712193331.png"></p><p><code>IntelliSense</code> (Pylance)、<code>Linting</code>、调试（多线程、远程）、<code>Jupyter Notebooks</code>、代码格式化、重构、单元测试。</p><blockquote><p>编辑 python 的必备插件呀。</p></blockquote><h4 id="2-Pylance"><a href="#2-Pylance" class="headerlink" title="2. Pylance"></a>2. Pylance</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220712193550.png"></p><p><code>VS Code</code> 中用于 <code>Python</code> 的高性能、功能丰富的语言服务器。</p><p><code>Pylance</code> 可与 <code>VScode</code> 中的 <code>Python</code> 插件一起使用的一个插件，以提供高性能的语言支持。<br>在后台，<code>Pylance</code> 由 <code>Microsoft</code> 的静态类型检查工具 <code>Pyright</code> 提供支持。 使用 <code>Pyright</code>，<code>Pylance</code> 可以为 <code>Python IntelliSense</code> 体验提供丰富的类型信息，从而帮助您更快地编写更好的代码。</p><p><code>Pylance</code> 名称是 <code>Monty Python</code> 的 <code>Lancelot</code> 的一个小颂歌，<code>Lancelot</code> 是第一个在圣杯中回答守门员问题的骑士。</p><p><strong>快速开始</strong></p><ol><li>安装 <code>Pylance</code> 扩展。<ol><li>打开一个 <code>Python（.py）</code>文件，<code>Pylance</code> 扩展名将被激活。</li></ol></li><li>当提示您将 <code>Pylance</code> 设置为默认语言服务器时，选择“是”。 这将更新您的首选项，也可以通过使用文本编辑器将“python.languageServer”：“ Pylance” 添加到 <code>settings.json</code> 文件中来手动进行。</li></ol><p><code>Pylance</code> 为 <code>Python 3</code> 提供了一些很棒的功能，包括：</p><ul><li>字串</li><li>签名帮助，带有类型信息</li><li>参数建议</li><li>代码补全</li><li>自动导入（以及添加和删除导入代码操作）</li><li>输入代码的时候报告代码错误和警告（诊断）</li><li>代码大纲</li><li>代码导航</li><li>类型检查模式</li><li>本地多个工作区支持</li><li><code>IntelliCode</code> 兼容性</li><li><code>Jupyter Notebooks</code> 兼容性</li><li>语法高亮</li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h4 id="1-Live-Server"><a href="#1-Live-Server" class="headerlink" title="1. Live Server"></a>1. Live Server</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716182133.png"></p><p>模拟本地服务器，编写完网页代码后保存，浏览器的页面情况将自动刷新，就无需在浏览器中刷新。</p><h4 id="2-Auto-Complete-Tag"><a href="#2-Auto-Complete-Tag" class="headerlink" title="2. Auto Complete Tag"></a>2. Auto Complete Tag</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716184131.png"></p><p>同时拥有<strong>自动关闭标签</strong>和<strong>自动重命名标签</strong>的功能。</p><blockquote><p>就是下面两个插件的功能，要么安装该插件，要么安装下面两个插件。</p></blockquote><h4 id="3-Auto-Rename-Tag"><a href="#3-Auto-Rename-Tag" class="headerlink" title="3. Auto Rename Tag"></a>3. Auto Rename Tag</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716183614.png"></p><p>自动重命名成对的 HTML&#x2F;XML 标记。</p><h4 id="4-Auto-Close-Tag"><a href="#4-Auto-Close-Tag" class="headerlink" title="4. Auto Close Tag"></a>4. Auto Close Tag</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716183810.png"></p><p>自动添加 HTML&#x2F;XMl 关闭标记。</p><p>特征：</p><ul><li>键入开始标签的右括号时自动添加结束标签</li><li>插入结束标签后，光标在开始和结束标签之间</li><li>设置不自动关闭的标签列表</li><li>自动关闭自关闭标签</li><li>支持 <code>Sublime Text 3</code> 的自动关闭标签</li><li>使用键盘快捷键或命令面板手动添加关闭标签</li></ul><h4 id="5-CSS-Peek"><a href="#5-CSS-Peek" class="headerlink" title="5. CSS Peek"></a>5. CSS Peek</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716184534.png"></p><p>快速跳到CSS的定义处预览。</p><p>特征：该扩展支持符号定义跟踪的所有正常功能，但它适用于 <code>css</code> 选择器（<code>类</code>、<code>ID</code> 和 <code>HTML</code> 标记）。这包括：</p><ul><li><code>Peek</code>：内联加载 <code>css</code> 文件并在此处进行快速编辑。( <code>Ctrl + Shift + F12</code> )</li><li><code>转到</code>：直接跳转到 <code>css</code> 文件或在新编辑器中打开它 (<code>F12</code>)</li><li><code>悬停</code>：悬停在符号 (<code>Ctrl + hover</code>)上显示定义</li></ul><h4 id="6-HTML-CSS-Support"><a href="#6-HTML-CSS-Support" class="headerlink" title="6. HTML CSS Support"></a>6. HTML CSS Support</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716184901.png"></p><p>适用于 <code>HTML</code> 的 <code>Visual Studio Code CSS Intellisense</code>.</p><p>特征: </p><ul><li>完善 HTML <code>id</code> 和 <code>类</code>属性。</li><li>支持链接和嵌入的样式表。</li><li>支持模板继承。</li><li>支持其他样式表。</li><li>支持其他类似 <code>HTML</code> 的语言。</li><li>按需验证 <code>CSS</code> 选择器。</li></ul><p>用法: 可以通过 <code>ctrl + 空格</code> 查看 <code>id</code> 和 <code>类</code> 属性建议列表。</p><h3 id="高效率工具"><a href="#高效率工具" class="headerlink" title="高效率工具"></a>高效率工具</h3><h4 id="1-Path-Intellisense"><a href="#1-Path-Intellisense" class="headerlink" title="1. Path Intellisense"></a>1. Path Intellisense</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716173750.png"></p><p>该插件支持自动提示文件路径，支持各种文件无脑快速引入。</p><h4 id="2-Bracket-Pair-Colorization-Toggler"><a href="#2-Bracket-Pair-Colorization-Toggler" class="headerlink" title="2. Bracket Pair Colorization Toggler"></a>2. Bracket Pair Colorization Toggler</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/md_img20220716182853.png"></p><p>给不同区域的括号加上不同的颜色，加以区分。</p><p>仓库：<a href="https://github.com/dzhavat/bracket-pair-toggler">Bracket Pair Colorization Toggler</a></p>]]></content>
    
    
    <categories>
      
      <category>VS code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
      <tag>Plugins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下包管理器 Scoop 的安装与使用</title>
    <link href="/using-scoop/"/>
    <url>/using-scoop/</url>
    
    <content type="html"><![CDATA[<h3 id="🍉-什么是-Scoop"><a href="#🍉-什么是-Scoop" class="headerlink" title="🍉 什么是 Scoop"></a>🍉 什么是 Scoop</h3><blockquote><p>😶‍🌫️ 可以去看 <a href="https://github.com/ScoopInstaller/Scoop">Scoop Github 上的介绍</a>。</p><p>😶‍🌫️ 还有官方文档 <a href="https://github.com/ScoopInstaller/Scoop/wiki">Scoop Wiki</a></p><p>😶‍🌫️ 官网 <a href="https://scoop.sh/">Scoop.sh</a></p></blockquote><p><code>Scoop</code> 是 <code>Windows</code> 上的命令行安装工具。</p><p>🙈 可以用来干嘛？</p><p>🦥 通过命令行界面，<code>Scoop</code> 可以顺畅地安装应用程序。（官方说明）</p><ul><li>🌲 没有权限弹出窗口</li><li>🌲 隐藏 GUI 向导式安装程序</li><li>🌲 防止因而安装大量程序造成 PATH 污染</li><li>🌲 避免安装和卸载程序的不当使用</li><li>🌲 自动查找并安装依赖项</li><li>🌲 自动执行所有额外的设置步骤来获取工作程序</li></ul><h3 id="🍉-安装-Scoop"><a href="#🍉-安装-Scoop" class="headerlink" title="🍉 安装 Scoop"></a>🍉 安装 Scoop</h3><h4 id="🍊-准备工作"><a href="#🍊-准备工作" class="headerlink" title="🍊 准备工作"></a>🍊 准备工作</h4><ul><li><p><code>PowerShell</code> ：确保已安装 <code>PowerShell 5.0</code> 或更高版本。</p><blockquote><p><code>Windows 10</code> 以及更高的版本默认安装的 <code>PowerShell 5.0</code>。</p></blockquote></li><li><p>确保以允许 <code>Powershell</code> 执行本地脚本。</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">set-executionpolicy</span> remotesigned <span class="hljs-literal">-scope</span> currentuser</code></pre></div><blockquote><p><code>Unrestricted</code> 也可以，但是安全性较低。</p><p>最好使用 <code>RemoteSigned</code>。</p></blockquote></li></ul><h3 id="🍉-安装-Scoop-1"><a href="#🍉-安装-Scoop-1" class="headerlink" title="🍉 安装 Scoop"></a>🍉 安装 Scoop</h3><h4 id="🍑-安装在默认位置"><a href="#🍑-安装在默认位置" class="headerlink" title="🍑 安装在默认位置"></a>🍑 安装在默认位置</h4><p>默认安装在 <code>C:\Users\username\scoop</code> 路径下。</p><p>执行命令：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-Expression</span> (<span class="hljs-built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="hljs-string">&#x27;https://get.scoop.sh&#x27;</span>)</code></pre></div><p>或是执行（更短的）：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">iwr</span> <span class="hljs-literal">-useb</span> get.scoop.sh | <span class="hljs-built_in">iex</span></code></pre></div><div class="note note-info">            <p><a id="install"><strong>2022.11.17 更新：</strong></a></p><p>为加快 Scoop 的安装速度，主要是下载速度，使用代理进行加速下载。</p><ul><li><p><strong>fastgit</strong> 下载</p><ul><li><p>进入用户主目录：<code>cd ~</code></p></li><li><p>下载 <code>scoop_install.ps1</code>：</p> <div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">curl</span> <span class="hljs-literal">-o</span> scoop_install.ps1 https://raw.fastgit.org/scoopinstaller/install/master/install.ps1</code></pre></div></li><li><p>修改 <code>scoop_install.ps1</code> 中文件下载地址：</p><div class="code-wrapper"><pre><code class="hljs powershell">(<span class="hljs-built_in">Get-Content</span> scoop_install.ps1).replace(<span class="hljs-string">&#x27;https://github.com/ScoopInstaller/&#x27;</span>, <span class="hljs-string">&#x27;https://download.fastgit.org//ScoopInstaller/&#x27;</span>) | <span class="hljs-built_in">Set-Content</span> scoop_install.ps1</code></pre></div></li><li><p>安装 Scoop：<code>./scoop_install.ps1</code></p></li><li><p>删除 <code>scoop_install.ps1</code>：<code>rm scoop_install.ps1</code></p></li></ul></li><li><p><strong>github proxy</strong> 下载</p><ul><li><p>进入用户主目录：<code>cd ~</code></p></li><li><p>下载 <code>scoop_install.ps1</code>：</p> <div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">curl</span> <span class="hljs-literal">-o</span> scoop_install.ps1 https://ghproxy.com/https://raw.githubusercontent.com/scoopinstaller/install/master/install.ps1</code></pre></div></li><li><p>修改 <code>scoop_install.ps1</code> 中文件下载地址：</p><div class="code-wrapper"><pre><code class="hljs powershell">(<span class="hljs-built_in">Get-Content</span> scoop_install.ps1).replace(<span class="hljs-string">&#x27;https://github.com/ScoopInstaller/&#x27;</span>, <span class="hljs-string">&#x27;https://ghproxy.com/https://github.com/ScoopInstaller/&#x27;</span>) | <span class="hljs-built_in">Set-Content</span> scoop_install.ps1</code></pre></div></li><li><p>安装 Scoop：<code>./scoop_install.ps1</code></p></li><li><p>删除 <code>scoop_install.ps1</code>：<code>rm scoop_install.ps1</code></p></li></ul></li></ul>          </div><h4 id="🍑-自定义安装目录"><a href="#🍑-自定义安装目录" class="headerlink" title="🍑 自定义安装目录"></a>🍑 自定义安装目录</h4><p>例如将 <code>Scoop</code> 安装在 <code>C:\Scoop</code> 路径下。</p><p>需要添加该路径到<strong>用户变量</strong>中：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$env:SCOOP</span>=<span class="hljs-string">&#x27;C:\scoop&#x27;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs powershell">[<span class="hljs-type">environment</span>]::setEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>,<span class="hljs-variable">$env:SCOOP</span>,<span class="hljs-string">&#x27;User&#x27;</span>)</code></pre></div><blockquote><p>当然也可以添加到<strong>系统变量</strong>中：</p><p>不过此时需要以<strong>管理员身份</strong>运行 <code>PowerShell</code> ，或是以<strong>管理员身份</strong>运行 <code>Windows Terminal</code>，再打开 <code>PowerShell</code> ，否则会报错：</p><div class="code-wrapper"><pre><code class="hljs powershell">[<span class="hljs-type">environment</span>]::setEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>,<span class="hljs-variable">$env:SCOOP</span>,<span class="hljs-string">&#x27;Machine&#x27;</span>)</code></pre></div></blockquote><blockquote><p><span style="color:red;">添加完环境变量后需要重启 PowerShell 或 Terminal 等待变量生效。</span></p></blockquote><p>然后再执行安装指令：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">iwr</span> <span class="hljs-literal">-useb</span> get.scoop.sh | <span class="hljs-built_in">iex</span></code></pre></div><div class="note note-info">            <p>安装方式同上，<a href="#install">点此跳转到新的安装方式</a></p>          </div><h4 id="🍑-自定义全局应用安装目录"><a href="#🍑-自定义全局应用安装目录" class="headerlink" title="🍑 自定义全局应用安装目录"></a>🍑 自定义全局应用安装目录</h4><p>例如自定义将全局应用安装在 <code>C:\apps</code> 路径下：</p><p>就需要将该目录添加到系统变量中，步骤同上文相同：</p><ol><li>😶‍🌫️ 以管理员身份运行</li><li>😶‍🌫️ <code>$env:SCOOP_GLOBAL=&#39;C:\apps&#39;</code></li><li>😶‍🌫️ <code>[environment]::setEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;,$env:SCOOP_GLOBAL,&#39;Machine&#39;)</code></li><li>😶‍🌫️ 安装指令：<code>scoop install -g &lt;app&gt;</code></li></ol><p>合起来就是：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$env:SCOOP_GLOBAL</span>=<span class="hljs-string">&#x27;C:\apps&#x27;</span>[<span class="hljs-type">environment</span>]::setEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP_GLOBAL&#x27;</span>,<span class="hljs-variable">$env:SCOOP_GLOBAL</span>,<span class="hljs-string">&#x27;Machine&#x27;</span>)scoop install <span class="hljs-literal">-g</span> &lt;app&gt;</code></pre></div><h3 id="🍉-使用-Scoop"><a href="#🍉-使用-Scoop" class="headerlink" title="🍉 使用 Scoop"></a>🍉 使用 Scoop</h3><p>查看 scoop 的命令：</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop help</code></pre></div><p>查看命令的详细信息：</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop help &lt;command&gt;<span class="hljs-comment"># for example: scoop help install </span><span class="hljs-comment"># For more detailed information on INSTALL</span></code></pre></div><p>执行 <code>scoop help install </code>：</p><div class="code-wrapper"><pre><code class="hljs powershell">Usage: scoop install &lt;app&gt; [<span class="hljs-type">options</span>]e.g. The usual way to install an app (uses your local <span class="hljs-string">&#x27;buckets&#x27;</span>):     scoop install gitTo install an app from a manifest at a URL:     scoop install https://raw.githubusercontent.com/ScoopInstaller/Main/master/bucket/runat.jsonTo install an app from a manifest on your computer     scoop install \path\to\app.jsonOptions:  <span class="hljs-literal">-g</span>, <span class="hljs-literal">--global</span>              Install the app globally  <span class="hljs-literal">-i</span>, <span class="hljs-literal">--independent</span>         Don<span class="hljs-string">&#x27;t install dependencies automatically</span><span class="hljs-string">  -k, --no-cache            Don&#x27;</span>t use the download cache  <span class="hljs-literal">-u</span>, <span class="hljs-literal">--no-update-scoop</span>     Don<span class="hljs-string">&#x27;t update Scoop before installing if it&#x27;</span>s outdated  <span class="hljs-literal">-s</span>, <span class="hljs-literal">--skip</span>                Skip hash validation (use with caution!)  <span class="hljs-literal">-a</span>, <span class="hljs-literal">--arch</span> &lt;<span class="hljs-number">32</span>bit|<span class="hljs-number">64</span>bit&gt;  Use the specified architecture, <span class="hljs-keyword">if</span> the app supports it</code></pre></div><h4 id="🍒-安装应用"><a href="#🍒-安装应用" class="headerlink" title="🍒 安装应用"></a>🍒 安装应用</h4><p>分为两种情况：</p><h5 id="😃为当前用户安装"><a href="#😃为当前用户安装" class="headerlink" title="😃为当前用户安装"></a>😃为当前用户安装</h5><p>安装路径：<code>scoop\apps</code> </p><blockquote><p><code>scoop</code> 路径默认在 <code>C:\User\username</code> 。</p><p>若是自定义安装路径，例如上文的位置，则在 <code>C:\Scoop</code> </p></blockquote><p>安装命令：</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop install &lt;app&gt;<span class="hljs-comment"># for example:</span><span class="hljs-comment"># scoop install nano</span></code></pre></div><h5 id="😃为所有用户安装"><a href="#😃为所有用户安装" class="headerlink" title="😃为所有用户安装"></a>😃为所有用户安装</h5><p>默认的安装路径：<code>C:\ProgramData\scoop</code></p><p>若是如上文所示，自定义了全局应用安装目录，则安装路径：<code>C:\apps</code></p><blockquote><p>需要以<strong>管理员身份</strong>运行。</p></blockquote><p>安装命令：</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop install &lt;app&gt; <span class="hljs-literal">-g</span><span class="hljs-comment"># for example:</span><span class="hljs-comment"># scoop install nano -g</span></code></pre></div><h4 id="🍒-卸载应用"><a href="#🍒-卸载应用" class="headerlink" title="🍒 卸载应用"></a>🍒 卸载应用</h4><h5 id="😃卸载某一程序"><a href="#😃卸载某一程序" class="headerlink" title="😃卸载某一程序"></a>😃卸载某一程序</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop uninstall &lt;app&gt;</code></pre></div><h5 id="😃卸载程序并移除配置文件"><a href="#😃卸载程序并移除配置文件" class="headerlink" title="😃卸载程序并移除配置文件"></a>😃卸载程序并移除配置文件</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop uninstall &lt;app&gt; <span class="hljs-literal">-p</span></code></pre></div><h5 id="😃卸载全局程序"><a href="#😃卸载全局程序" class="headerlink" title="😃卸载全局程序"></a>😃卸载全局程序</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop uninstall &lt;app&gt; <span class="hljs-literal">-g</span></code></pre></div><h5 id="😃更多信息"><a href="#😃更多信息" class="headerlink" title="😃更多信息"></a>😃更多信息</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop help uninstall</code></pre></div><h4 id="🍒-更新"><a href="#🍒-更新" class="headerlink" title="🍒 更新"></a>🍒 更新</h4><h5 id="😃更新-scoop-及所有-bucket-但不更新-app"><a href="#😃更新-scoop-及所有-bucket-但不更新-app" class="headerlink" title="😃更新 scoop 及所有 bucket 但不更新 app"></a>😃更新 scoop 及所有 bucket 但不更新 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop update</code></pre></div><h5 id="😃更新某一-app"><a href="#😃更新某一-app" class="headerlink" title="😃更新某一 app"></a>😃更新某一 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop update &lt;app&gt;</code></pre></div><h5 id="😃更新-scoop、bucket、app"><a href="#😃更新-scoop、bucket、app" class="headerlink" title="😃更新 scoop、bucket、app"></a>😃更新 scoop、bucket、app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop update *</code></pre></div><h5 id="😃更新全局-app"><a href="#😃更新全局-app" class="headerlink" title="😃更新全局 app"></a>😃更新全局 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop update &lt;app&gt; <span class="hljs-literal">-g</span></code></pre></div><h5 id="😃更多信息-1"><a href="#😃更多信息-1" class="headerlink" title="😃更多信息"></a>😃更多信息</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop help update</code></pre></div><h4 id="🍒-其他有用操作"><a href="#🍒-其他有用操作" class="headerlink" title="🍒 其他有用操作"></a>🍒 其他有用操作</h4><h5 id="😃查看已安装-app"><a href="#😃查看已安装-app" class="headerlink" title="😃查看已安装 app"></a>😃查看已安装 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop list</code></pre></div><h5 id="😃查看可更新-app"><a href="#😃查看可更新-app" class="headerlink" title="😃查看可更新 app"></a>😃查看可更新 app</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop status</code></pre></div><h5 id="😃查看某-app-主页"><a href="#😃查看某-app-主页" class="headerlink" title="😃查看某 app 主页"></a>😃查看某 app 主页</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop home &lt;app&gt;</code></pre></div><h5 id="😃查看「已知库」"><a href="#😃查看「已知库」" class="headerlink" title="😃查看「已知库」"></a>😃查看「已知库」</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket known</code></pre></div><h5 id="😃添加「已知库」"><a href="#😃添加「已知库」" class="headerlink" title="😃添加「已知库」"></a>😃添加「已知库」</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket add &lt;bucket&gt;</code></pre></div><h5 id="😃查看已添加的库"><a href="#😃查看已添加的库" class="headerlink" title="😃查看已添加的库"></a>😃查看已添加的库</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket list</code></pre></div><h5 id="😃删除已添加的库"><a href="#😃删除已添加的库" class="headerlink" title="😃删除已添加的库"></a>😃删除已添加的库</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket <span class="hljs-built_in">rm</span> &lt;bucket&gt;</code></pre></div><h5 id="😃添加第三方库"><a href="#😃添加第三方库" class="headerlink" title="😃添加第三方库"></a>😃添加第三方库</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop bucket add &lt;bucket&gt; &lt;bucket_url&gt;</code></pre></div><h5 id="😃删除已安装软件的旧版本"><a href="#😃删除已安装软件的旧版本" class="headerlink" title="😃删除已安装软件的旧版本"></a>😃删除已安装软件的旧版本</h5><div class="code-wrapper"><pre><code class="hljs powershell">scoop cleanup *</code></pre></div><h5 id="😃清理软件缓存"><a href="#😃清理软件缓存" class="headerlink" title="😃清理软件缓存"></a>😃清理软件缓存</h5><p>通常是下载的软件安装包。</p><p>以下命令清除所有缓存，即清空 <code>Scoop</code> 目录下的 <code>cache</code> 文件夹。</p><div class="code-wrapper"><pre><code class="hljs powershell">scoop cache <span class="hljs-built_in">rm</span> *</code></pre></div><h3 id="🍉-进阶"><a href="#🍉-进阶" class="headerlink" title="🍉 进阶"></a>🍉 进阶</h3><p>更多信息请查看 <a href="https://github.com/ScoopInstaller/Scoop/wiki">官方文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 支配集、覆盖集、独立集与匹配</title>
    <link href="/discrete-mathematics-set-knowledge/"/>
    <url>/discrete-mathematics-set-knowledge/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/set.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 有向图的连通性</title>
    <link href="/discrete-mathematics-graph-connectivity/"/>
    <url>/discrete-mathematics-graph-connectivity/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 图的矩阵表示</title>
    <link href="/discrete-mathematics-graph-matrix/"/>
    <url>/discrete-mathematics-graph-matrix/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/graph-matrix.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 欧拉图和哈密顿图</title>
    <link href="/discrete-mathematics-elatu-hamilton/"/>
    <url>/discrete-mathematics-elatu-hamilton/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/elatu-hamilton.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 平面图</title>
    <link href="/discrete-mathematics-plane-map/"/>
    <url>/discrete-mathematics-plane-map/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/plane-map.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 图的着色</title>
    <link href="/discrete-mathematics-color-graphic/"/>
    <url>/discrete-mathematics-color-graphic/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/clolor.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 树</title>
    <link href="/discrete-mathematics-tree/"/>
    <url>/discrete-mathematics-tree/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/9.1.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感知机学习算法</title>
    <link href="/ml-perceptron/"/>
    <url>/ml-perceptron/</url>
    
    <content type="html"><![CDATA[<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h3><h4 id="原始形式"><a href="#原始形式" class="headerlink" title="原始形式"></a>原始形式</h4><ul><li>感知机模型：$f(x)&#x3D;sign(\omega x + \theta)$</li><li>输入：训练集<ul><li>$T&#x3D;{(x_1, y_1),(x_2,y_2,…,(x_n, y_n))}$<ul><li>$x_i\in X&#x3D;R^n$</li><li>$y_i\in{1,-1}$</li><li>$i&#x3D;1,2,…,n$</li></ul></li><li>学习率 $\eta$：$0&lt; \eta \leq 1$</li></ul></li><li>输出：$\omega$，$\theta$</li><li>步骤：<ol><li>选定初值 $\omega_0, \theta_0$<blockquote><p>一般都是 0</p></blockquote></li><li>从训练集中选出数据 $(x_i,y_i)$</li><li>当 $y_i(\omega x_i + \theta) \leq 0$ 时，更新 $\omega, \theta$:<ul><li>$\omega \leftarrow \omega + \eta x_iy_i$</li><li>$\theta \leftarrow \theta + \eta y_i$</li></ul></li><li>继续执行第二步，直至训练集中没有误分类点</li></ol></li></ul><h2 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h2><ul><li><p><code>/感知机数据集/perceptron_data.txt</code></p></li><li><p>共有 98 个样本 2 个输入变量</p></li><li><p>数据格式如下图：</p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225935.png" width = "40%"></li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li><code>Python</code> 版本：<code>Python 3.9</code></li><li>编辑器：<code>Jupyter Notebook</code>、<code>PyCharm</code></li><li>扩展包：<code>numpy</code>、<code>pandas</code>、<code>matplotlib</code> 等基础扩展包<blockquote><p>不可使用 <code>sklearn</code>、<code>kreas</code> 等机器学习包</p></blockquote></li></ul><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ol><li>采用<strong>感知机学习算法</strong>建立模型</li><li><strong>神经元激活函数</strong>建议选用 <code>sign</code> 函数<blockquote><p>（数据集最后一列的标签请将 <code>0</code> 转换为 <code>-1</code>）</p></blockquote></li><li>迭代输出每一次更新后的 $\omega$ 和 $\theta$</li><li>数据集线性可分，最好求解出<strong>线性超平面</strong></li></ol><h2 id="实验代码详解"><a href="#实验代码详解" class="headerlink" title="实验代码详解"></a>实验代码详解</h2><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>根据上述的感知机学习算法编写代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">perceptron</span>(<span class="hljs-params">data_x, data_y, eta</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    感知机学习算法</span><span class="hljs-string">    :param data_x: 样本</span><span class="hljs-string">    :param data_y: 标签</span><span class="hljs-string">    :param eta: 学习率</span><span class="hljs-string">    :return: w， θ</span><span class="hljs-string">    &quot;&quot;&quot;</span>    omega = np.zeros(data_x.shape[<span class="hljs-number">1</span>])    theta = <span class="hljs-number">0</span>    classify_count = <span class="hljs-number">0</span> <span class="hljs-comment"># 记录分类次数</span>    classify_round = <span class="hljs-number">0</span> <span class="hljs-comment"># 记录分类轮次</span>    classify_right = <span class="hljs-literal">False</span> <span class="hljs-comment"># 记录误分类点的存在</span>    new_round = <span class="hljs-literal">True</span>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> classify_right:        <span class="hljs-keyword">if</span> new_round:            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第 %d 轮：&quot;</span> % classify_round)            classify_round += <span class="hljs-number">1</span>        classify_right = <span class="hljs-literal">True</span>        new_round = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, data_x.shape[<span class="hljs-number">0</span>]):            <span class="hljs-keyword">if</span> data_y[index] * (np.dot(omega, data_x[index]) + theta) &lt;= <span class="hljs-number">0</span>:                theta += eta * data_y[index]                omega += eta * data_x[index] * data_y[index]                classify_count += <span class="hljs-number">1</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分类次数：%d\t θ: %.2f\t w：&quot;</span> % (classify_count, theta), omega)                <span class="hljs-comment"># 绘图</span>                table_line(data_x[:, <span class="hljs-number">0</span>], data_x[:, <span class="hljs-number">1</span>], data_y, omega, theta, classify_count)                classify_right = <span class="hljs-literal">False</span>                new_round = <span class="hljs-literal">True</span>    <span class="hljs-keyword">return</span> omega, theta</code></pre></div><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>绘图主要是两个部分：</p><ol><li>训练集根据 [0, 1] 划分后的散点图</li><li>随着 $\omega, \theta$ 的变化而变化的含有超平面的图</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_scatter_data</span>(<span class="hljs-params">x_axis, y_axis, label</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    对数据按照 label【0，1】进行分组，方便绘制不同颜色的散点图</span><span class="hljs-string">    &quot;&quot;&quot;</span>    x_red, x_blue, y_red, y_blue = [], [], [], []    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(label)):        <span class="hljs-keyword">if</span> label[index] == <span class="hljs-number">1</span>:            x_red.append(x_axis[index])            y_red.append(y_axis[index])        <span class="hljs-keyword">elif</span> label[index] == -<span class="hljs-number">1</span>:            x_blue.append(x_axis[index])            y_blue.append(y_axis[index])    <span class="hljs-keyword">return</span> [x_red, x_blue], [y_red, y_blue]<span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_table</span>(<span class="hljs-params">x_axis, y_axis, label</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    显示最开始的分组结果</span><span class="hljs-string">    &quot;&quot;&quot;</span>    axis_x, axis_y = get_scatter_data(x_axis, y_axis, label)    color = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]    mark = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>]    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(axis_x)):        plt.scatter(axis_x[index], axis_y[index], color=color[index], label=mark[index], alpha=<span class="hljs-number">.5</span>)    plt.xlim((-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>))    plt.ylim((-<span class="hljs-number">3</span>, <span class="hljs-number">15</span>))    plt.legend()  <span class="hljs-comment"># 显示图例</span>    plt.show()<span class="hljs-keyword">def</span> <span class="hljs-title function_">table_line</span>(<span class="hljs-params">x_axis, y_axis, label, omega, theta, i</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    绘制每次迭代时的超平面，并保存图片</span><span class="hljs-string">    :param x_axis: 样本的第一列</span><span class="hljs-string">    :param y_axis: 样本第二列</span><span class="hljs-string">    :param label: 样本标签【0，1】</span><span class="hljs-string">    :param omega: w</span><span class="hljs-string">    :param theta: θ</span><span class="hljs-string">    :param i: 迭代次数</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    axis_x, axis_y = get_scatter_data(x_axis, y_axis, label)    color = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]    mark = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>]    x1 = -theta / omega[<span class="hljs-number">0</span>]    x2 = -theta / omega[<span class="hljs-number">1</span>]    <span class="hljs-comment"># 仅当可以绘制一条直线时，绘图</span>    <span class="hljs-keyword">if</span> x1 != x2:        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(axis_x)):            plt.scatter(axis_x[index], axis_y[index], color=color[index], label=mark[index], alpha=<span class="hljs-number">.5</span>)        plt.xlim((-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>))        plt.ylim((-<span class="hljs-number">3</span>, <span class="hljs-number">15</span>))        plt.axline([x1, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, x2], label=<span class="hljs-string">&#x27;超平面&#x27;</span>, color=<span class="hljs-string">&#x27;black&#x27;</span>)        plt.legend()  <span class="hljs-comment"># 显示图例</span>        <span class="hljs-comment"># 将绘制的图保存到 result 目录下，用于制作 gif</span>        plt.savefig(<span class="hljs-string">&#x27;./result/images&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.jpg&#x27;</span>)        <span class="hljs-comment"># 绘制完并保存后，关闭绘图，避免所有绘图绘制在一个图上</span>        plt.close()</code></pre></div><p>为方便查看迭代过程中，随 $\omega,\theta$ 的变化而变化的超平面情况，将每次迭代后绘制超平面，然后将图片保存至  <code>result</code> 文件夹，再读取该文件夹所有文件，制作成一个 GIF，用于观看迭代变化情况。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><div class="code-wrapper"><pre><code class="hljs txt">第 0 轮：分类次数：1 θ: -0.50 w： [ 0.008806 -7.026532]分类次数：2 θ: 0.00 w： [-0.689011  -4.6952615]分类次数：3 θ: 0.50 w： [-0.485659 -1.161594]分类次数：4 θ: 1.00 w： [-0.0604425  2.298573 ]分类次数：5 θ: 0.50 w： [-0.734034 -4.289177]分类次数：6 θ: 1.00 w： [-0.1456275 -2.705667 ]分类次数：7 θ: 1.50 w： [-0.4289305  0.1688345]分类次数：8 θ: 1.00 w： [-0.140668  -5.7206265]分类次数：9 θ: 1.50 w： [-1.20291  -4.384391]分类次数：10 θ: 2.00 w： [-1.0449175 -2.6224145]分类次数：11 θ: 2.50 w： [-1.238079  -0.6277715]分类次数：12 θ: 3.00 w： [-0.639777  1.848154]分类次数：13 θ: 2.50 w： [-0.7773875 -2.9236695]分类次数：14 θ: 3.00 w： [-1.0002265 -1.275018 ]分类次数：15 θ: 3.50 w： [-0.4791155  1.7775595]分类次数：16 θ: 3.00 w： [-0.169722  -3.3829335]分类次数：17 θ: 3.50 w： [ 0.244545 -2.044911]分类次数：18 θ: 4.00 w： [0.359273 0.916058]分类次数：19 θ: 3.50 w： [ 0.8392155 -4.86161  ]分类次数：20 θ: 4.00 w： [ 1.5928545 -2.347677 ]分类次数：21 θ: 4.50 w： [1.64269   1.0702425]分类次数：22 θ: 4.00 w： [ 1.814694 -4.2885  ]分类次数：23 θ: 4.50 w： [ 2.707658  -0.4291775]分类次数：24 θ: 4.00 w： [ 2.711255  -4.9670735]分类次数：25 θ: 4.50 w： [ 3.7921    -0.2106735]分类次数：26 θ: 4.00 w： [ 3.1437585 -6.014453 ]分类次数：27 θ: 4.50 w： [ 2.4750225 -5.7802835]分类次数：28 θ: 5.00 w： [ 2.4013605 -4.3428605]分类次数：29 θ: 5.50 w： [ 3.0613325 -3.2572465]分类次数：30 θ: 6.00 w： [ 4.0894405 -0.747256 ]分类次数：31 θ: 6.50 w： [3.663624  1.4405895]分类次数：32 θ: 6.00 w： [ 4.4186475 -1.5904065]分类次数：33 θ: 6.50 w： [ 3.8689185 -0.7462695]分类次数：34 θ: 6.00 w： [ 3.1688675 -7.06066  ]分类次数：35 θ: 6.50 w： [ 4.0452885 -4.326577 ]分类次数：36 θ: 7.00 w： [ 3.70539  -3.716312]分类次数：37 θ: 7.50 w： [ 2.6209945 -3.644496 ]第 1 轮：分类次数：38 θ: 8.00 w： [ 1.9231775 -1.3132255]分类次数：39 θ: 8.50 w： [2.1265295 2.220442 ]分类次数：40 θ: 8.00 w： [ 1.7928325 -4.150284 ]分类次数：41 θ: 8.50 w： [ 2.218049 -0.690117]分类次数：42 θ: 8.00 w： [ 1.5444575 -7.277867 ]分类次数：43 θ: 8.50 w： [ 2.132864 -5.694357]分类次数：44 θ: 9.00 w： [ 1.849561  -2.8198555]分类次数：45 θ: 9.50 w： [1.8374585 0.256056 ]分类次数：46 θ: 9.00 w： [ 2.125721 -5.633405]分类次数：47 θ: 9.50 w： [ 1.063479  -4.2971695]分类次数：48 θ: 10.00 w： [ 1.2214715 -2.535193 ]分类次数：49 θ: 10.50 w： [ 1.02831 -0.54055]分类次数：50 θ: 10.00 w： [ 0.4158785 -6.33423  ]分类次数：51 θ: 10.50 w： [ 1.0141805 -3.8583045]分类次数：52 θ: 11.00 w： [ 0.7913415 -2.209653 ]分类次数：53 θ: 11.50 w： [1.3124525 0.8429245]分类次数：54 θ: 11.00 w： [ 1.621846  -4.3175685]分类次数：55 θ: 11.50 w： [ 1.736574  -1.3565995]分类次数：56 θ: 11.00 w： [ 2.4915975 -4.3875955]分类次数：57 θ: 11.50 w： [ 3.9966725 -0.1867125]分类次数：58 θ: 11.00 w： [ 3.2966215 -6.501103 ]分类次数：59 θ: 11.50 w： [ 4.1730425 -3.76702  ]第 2 轮：分类次数：60 θ: 12.00 w： [ 3.4752255 -1.4357495]分类次数：61 θ: 11.50 w： [ 3.19052  -6.210127]分类次数：62 θ: 12.00 w： [ 3.6157365 -2.74996  ]分类次数：63 θ: 12.50 w： [3.3324335 0.1245415]分类次数：64 θ: 12.00 w： [ 3.620696  -5.7649195]分类次数：65 θ: 12.50 w： [ 2.558454 -4.428684]分类次数：66 θ: 13.00 w： [ 2.7164465 -2.6667075]分类次数：67 θ: 13.50 w： [3.2375575 0.38587  ]分类次数：68 θ: 13.00 w： [ 3.546951 -4.774623]分类次数：69 θ: 13.50 w： [ 3.661679 -1.813654]分类次数：70 θ: 13.00 w： [ 2.751131 -6.955649]分类次数：71 θ: 13.50 w： [ 4.256206 -2.754766]分类次数：72 θ: 14.00 w： [ 3.8328875 -0.8302285]分类次数：73 θ: 13.50 w： [ 3.1328365 -7.144619 ]分类次数：74 θ: 14.00 w： [ 4.0092575 -4.410536 ]第 3 轮：分类次数：75 θ: 14.50 w： [ 3.3114405 -2.0792655]第 4 轮：</code></pre></div><p>超平面：</p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225958.png"><p>迭代过程：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230114.png"></p><h2 id="实验心得体会"><a href="#实验心得体会" class="headerlink" title="实验心得体会"></a>实验心得体会</h2><p>将数学公式转化成代码模型还是具有一定的难度呀，光看数学公式理解起来还是比较清晰的，但是如果靠自己将公式转化为代码模型就无从下手，只得先借鉴他人的成果，比如前文中的算法步骤，才好轻松进行转换。</p><p>其次是绘图的小问题，自己的想法是先绘制出散点图，再将直线加上去，然后获取第二张图，结果发现似乎没法实现。就只能每次都绘制散点，绘制直线，同时尽可能地减少代码的重复性。</p><p>后面调用 <code>table_line()</code> 函数绘制多个图时，发现，下一张图比上一张图多了一条直线，竟是每次在上一张图的基础上进行绘制，以致于图片全部作废，经了解，需要加上 <code>ptl.close()</code> “关闭” 图表，才好绘制新的图表。</p><h2 id="实验参考"><a href="#实验参考" class="headerlink" title="实验参考"></a>实验参考</h2><ul><li><a href="https://www.cnblogs.com/zhizhan/p/5615947.html">Python–matplotlib绘图可视化知识点整理</a></li><li><a href="https://blog.csdn.net/weixin_43568160/article/details/85680497">python读取某文件下的所有图片并制作成gif图</a></li><li><a href="https://blog.csdn.net/qq_45261963/article/details/118086413">Python数据可视化之散点图(基础篇—图文并茂详细版！！！)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 通路与回路</title>
    <link href="/discrete-mathematics-path-circuit/"/>
    <url>/discrete-mathematics-path-circuit/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/tonglu.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学笔记 —— 图的基本概念</title>
    <link href="/discrete-mathematics-basic-concept-graph/"/>
    <url>/discrete-mathematics-basic-concept-graph/</url>
    
    <content type="html"><![CDATA[<p style="text-align:center;color:#ff6444;font-size:1.5em;font-weight: bold;">由于没法很好的渲染出复杂的数学公式，选择了直接贴图</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/math_img/basic-concept-graph.png"></p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性判别分析 —— 献血预测</title>
    <link href="/ml-lda/"/>
    <url>/ml-lda/</url>
    
    <content type="html"><![CDATA[<h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p><strong>线性判别分析（LDA）</strong></p><p>LDA 的思想非常朴素: 给定训练样例，设法将样例投影到一条直线上，使得同样例的投影点尽可能接近、异类样例的投影点尽可能远离;在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定新样本的类别.</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225538.png"></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225610.png"></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225634.png"></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225650.png"></p><h3 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h3><ul><li>输血服务中心数据集：<code>data/输血服务中心数据集/blood_data.txt</code></li><li>该实验是个分类问题。本数据集共有 <code>748</code> 个样本，<code>5</code> 个属性，详见 <code>data/输血服务中心数据集/blood_names.txt</code></li></ul><table><thead><tr><th align="center">属性名</th><th align="center">中文属性名</th><th align="left">意义</th></tr></thead><tbody><tr><td align="center">R</td><td align="center">近期</td><td align="left">距离上次献血的月数</td></tr><tr><td align="center">F</td><td align="center">频率</td><td align="left">捐献的总次数</td></tr><tr><td align="center">M</td><td align="center">度量</td><td align="left">捐献的总血量</td></tr><tr><td align="center">T</td><td align="center">时间</td><td align="left">距离首次献血的月数</td></tr><tr><td align="center">Donate</td><td align="center">一个二进制变量</td><td align="left">表示他&#x2F;她在是否在2007年3月献血（1：献血</td></tr></tbody></table><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><ol><li>划分测试集（<code>600</code>）和训练集（<code>148</code>），对数据集进行线性判别分析</li><li>将模型结果的投影方向 <code>w</code> 进行输出</li><li>输出测试集的准确率 <code>acc</code></li><li>最好能够将数据的分析结果进行可视化</li><li><code>5</code> 月 <code>12</code> 日晚上 <code>12:00</code> 之前将代码（<code>.py</code> 或者 <code>.ipynb</code> 文件）、实验报告（ <code>doc</code> 或 <code>pdf</code> 文件）一并打包上传至邮箱。</li></ol><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><p>本部分主要工作：</p><ol><li>从 txt 文件中读取数据集</li><li>将数据集分为 <strong>训练集</strong> 和 <strong>测试集</strong></li><li>将 <strong>训练集</strong> 和 <strong>测试集</strong> 分为 <code>x</code>， <code>y</code> 两个部分</li></ol><p>主要代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">file_path, df_columns</span>):    <span class="hljs-comment"># 读取 txt 到 datadfram。并加入列名</span>    data = pd.read_csv(file_path, header=<span class="hljs-literal">None</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)    data.columns = df_columns    <span class="hljs-keyword">return</span> data<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">file_path</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    加载数据集，并划分训练集和测试集</span><span class="hljs-string">    &quot;&quot;&quot;</span>    data_columns = [<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;Donate&#x27;</span>]    data_df = read_data(file_path, data_columns)    <span class="hljs-comment"># 训练集</span>    training_data = data_df.head(<span class="hljs-number">600</span>)    <span class="hljs-comment"># 训练集 x, y</span>    training_x, training_y = training_data.iloc[:, :(training_data.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)], training_data.iloc[:, -<span class="hljs-number">1</span>]    <span class="hljs-comment"># 测试集</span>    testing_data = data_df.tail(<span class="hljs-number">148</span>)    <span class="hljs-comment"># 测试集 x, y</span>    testing_x, testing_y = testing_data.iloc[:, :(testing_data.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)], testing_data.iloc[:, -<span class="hljs-number">1</span>]    <span class="hljs-keyword">return</span> training_x, training_y, testing_x, testing_y</code></pre></div><h4 id="编写-LDA-算法"><a href="#编写-LDA-算法" class="headerlink" title="编写 LDA 算法"></a>编写 LDA 算法</h4><p>本部分主要是计算下列的结果：</p><ol><li>计算类内散度矩阵 $S_w$</li><li>计算类间散度矩阵 $S_b$</li><li>计算矩阵 $S_w^{-1}S_b$</li><li>计算 $S_w^{-1}S_b$ 的最大的 d 个特征值和对应的 d 个特征向量 （$w_1$, $w_2$, … $w_d$），得到投影矩阵 $W$</li></ol><p><strong>主要代码：</strong><br>将 LDA 模型封装为一个类，该类需要传入三个参数：数据特征，数据标签以及降维后的维度。</p><ul><li>数据特征：training_x</li><li>数据标签: training_y</li></ul><p>变量定义：</p><ul><li><code>self.mu</code>：样本的均值向量，$\mu$ </li><li><code>self.new_data</code>：降维后的样本</li><li><code>self.swt_sb</code>：矩阵，$S_w^{-1}*S_b$，用于计算投影矩阵</li><li><code>self.w</code>：投影矩阵</li><li><code>self.Sw</code>：类内散度矩阵 $S_w$</li><li><code>self.Sb</code>：类间散度矩阵 $S_b$</li><li><code>self.St</code>：全局散度矩阵 $S_t$</li><li><code>self.labels</code>：数据标签，<code>training_y</code> 有的类型，本实验中共两种：<code>0</code>，<code>1</code></li><li><code>self.classify</code>：第 $i$ 类的样本，$X_i$</li><li><code>self.class_mu</code>：第 $i$ 类样本的均值向量，$\mu_{i}$</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LDAModel</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    线性判别分析</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data, target, d</span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        数据特征 数据标签 降维后的维度</span><span class="hljs-string">        &quot;&quot;&quot;</span>        self.data = data        self.target = target        self.d = d        self.labels = <span class="hljs-built_in">set</span>(target)        <span class="hljs-comment"># 列的平均值 μ</span>        <span class="hljs-comment"># 所有样本的均值向量</span>        self.mu = self.data.mean(<span class="hljs-number">0</span>)        self.new_data = <span class="hljs-literal">None</span>        self.swt_sb = <span class="hljs-literal">None</span>        self.w = <span class="hljs-literal">None</span>        self.Sw = <span class="hljs-literal">None</span>        self.Sb = <span class="hljs-literal">None</span>        self.St = <span class="hljs-literal">None</span>        self.classify, self.class_mu = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span></code></pre></div><p>将样本根据标签进行分类：方便 $\mu_i$ 的计算</p><ul><li>$X_1$：献血的样本集，标签 <code>1</code></li><li>$X_2$：未献血的样本集，标签 <code>0</code><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_divide_to_vectors</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：将传入的数据集按 target 分成不同的类别集合并求出对应集合的均值向量</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.classify, self.class_mu = &#123;&#125;, &#123;&#125;    <span class="hljs-comment"># 根据结果的值【0，1】，将训练样本分类：【0】一类，【1】一类</span>    <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> self.labels:        <span class="hljs-comment"># 分类</span>        self.classify[label] = self.data[self.target == label]        <span class="hljs-comment"># 均值向量(平均值)</span>        self.class_mu[label] = self.classify[label].mean(<span class="hljs-number">0</span>)</code></pre></div>计算全局散度矩阵：全局散度矩阵实际上就是类内散度矩阵和类间散度矩阵之和<br>$$S_t &#x3D; S_b+S_w&#x3D;\sum_{i &#x3D; 1}^{m}(x_i-\mu)(x_i-\mu)^T$$</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_st</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：计算全局散度矩阵</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.St = np.dot((self.data - self.mu).T, (self.data - self.mu))</code></pre></div><p>计算类间散度矩阵：<br>类间散度矩阵其实就是协方差矩阵乘以样本数目，即散度矩阵与协方差矩阵只是相差一个系数。<br>$$S_b &#x3D; \sum_{i&#x3D;1}^Nm_i(\mu_i-\mu)(\mu_i-\mu)^T$$</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sb</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：计算类间散度矩阵</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 创建新的数组</span>    self.Sb = np.zeros((self.data.shape[<span class="hljs-number">1</span>], self.data.shape[<span class="hljs-number">1</span>]))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.labels:        <span class="hljs-comment"># 获取类别i样例的集合</span>        class_i = self.classify[i]        <span class="hljs-comment"># 获取类别i的均值向量</span>        mu_i = self.class_mu[i]        self.Sb += <span class="hljs-built_in">len</span>(class_i) * np.dot((mu_i - self.mu).values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),                                         (mu_i - self.mu).values.reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>))</code></pre></div><p>计算类内散度矩阵：<br>重定义为了每个类别的散度矩阵之和。<br>$$S_w&#x3D;S_t-S_b&#x3D;\sum_{i&#x3D;1}^NS_{w_i}&#x3D;\sum_{i&#x3D;1}^N\sum_{x\in X_i}(x-\mu_i)(x-\mu_i)^T$$</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sw</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：定义类内散度矩阵</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.get_st()    self.get_sb()    <span class="hljs-comment"># St = Sw + Sb</span>    self.Sw = self.St - self.Sb</code></pre></div><p>计算 $S_w^{-1}*S_b$</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_swt_sb</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    计算 Sw^(-1)*Sb</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.data_divide_to_vectors()    self.get_sw()    self.swt_sb = np.linalg.inv(self.Sw).dot(self.Sb)</code></pre></div><p>计算 $S_w^{-1}S_b$ 的特征值和特征向量，并取最大的 d 个特征值和对应的特征向量作为投影矩阵 $w$</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_w</span>(<span class="hljs-params">self</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：计算w</span><span class="hljs-string">    &quot;&quot;&quot;</span>    self.get_swt_sb()    <span class="hljs-comment">#  特征值 和 特征向量</span>    <span class="hljs-comment"># eig_vectors[:i]与 eig_values相对应</span>    eig_values, eig_vectors = np.linalg.eig(self.swt_sb)    <span class="hljs-comment"># 寻找 d 个最大非零广义特征值</span>    top_d = (np.argsort(eig_values)[::-<span class="hljs-number">1</span>])[:self.d]    <span class="hljs-comment"># 用d个最大非零广义特征值组成的向量组成w</span>    self.w = eig_vectors[:, top_d]</code></pre></div><h4 id="对测试集进行预测"><a href="#对测试集进行预测" class="headerlink" title="对测试集进行预测"></a>对测试集进行预测</h4><p>主要代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">testing</span>():    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：对测试集进行分类并返回准确率</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 加载数据集</span>    train_x, train_y, test_x, test_y = load_data(<span class="hljs-string">&#x27;./data/blood_data.txt&#x27;</span>)    <span class="hljs-comment"># print(train_x, test_x, train_y, test_y)</span>    <span class="hljs-comment"># 创建模型</span>    lda = LDAModel(train_x, train_y, <span class="hljs-number">1</span>)    <span class="hljs-comment"># 获取投影矩阵w</span>    lda.get_result()    <span class="hljs-comment"># 对训练集进行降维</span>    train_x_handled = lda.new_data    <span class="hljs-comment"># 降维后的样本集</span>    <span class="hljs-comment"># data_df = pd.concat([pd.DataFrame(train_x_handled), train_y], axis=1)</span>    <span class="hljs-comment"># data_df.columns = [&#x27;Handled-Z1&#x27;, &#x27;Donate-Y1&#x27;]</span>    <span class="hljs-comment"># print(data_df)</span>    <span class="hljs-comment"># 获取训练集各个类别对应的高斯分布的均值和方差</span>    gauss_dist = &#123;&#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lda.labels:        category = train_x_handled[train_y == i]        <span class="hljs-comment"># 计算均值</span>        loc = category.mean()        <span class="hljs-comment"># 计算方差</span>        scale = category.std()        gauss_dist[i] = &#123;<span class="hljs-string">&#x27;loc&#x27;</span>: loc, <span class="hljs-string">&#x27;scale&#x27;</span>: scale&#125;    <span class="hljs-comment"># 测试集降维</span>    test_x_handled = np.dot(test_x, lda.w)    pred_y = np.array([judge_classification(gauss_dist, x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> test_x_handled])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">judge_classification</span>(<span class="hljs-params">gauss_dist, x</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    功能：判断样本x属于哪个类别</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 将样本带入各个类别的高斯分布概率密度函数进行计算</span>    judge_result = [[k, norm.pdf(x, loc=v[<span class="hljs-string">&#x27;loc&#x27;</span>], scale=v[<span class="hljs-string">&#x27;scale&#x27;</span>])] <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> gauss_dist.items()]    <span class="hljs-comment"># 寻找计算结果最大的类别</span>    judge_result.sort(key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)    <span class="hljs-comment"># print(judge_result)</span>    <span class="hljs-keyword">return</span> judge_result[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy_score</span>(<span class="hljs-params">y_true, y_pred</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    Compare y_true to y_pred and return the accuracy</span><span class="hljs-string">    比较 实际值 与 预测值，并返回准确度</span><span class="hljs-string">    &quot;&quot;&quot;</span>    accuracy = np.<span class="hljs-built_in">sum</span>(y_true == y_pred, axis=<span class="hljs-number">0</span>) / <span class="hljs-built_in">len</span>(y_true)    <span class="hljs-keyword">return</span> accuracy</code></pre></div><h4 id="绘制图标"><a href="#绘制图标" class="headerlink" title="绘制图标"></a>绘制图标</h4><p>绘制训练集降维后的图表，以降维结果作为横坐标，0|1作为纵坐标。</p><p>本图重在表示降维后，两类样本的位置情况。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225723.png"></p><div class="code-wrapper"><pre><code class="hljs python">plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>plt.scatter(train_x_handled[train_y == <span class="hljs-number">0</span>], np.ones((<span class="hljs-number">1</span>, train_x_handled[train_y == <span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])),            marker=<span class="hljs-string">&#x27;.&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>, label=<span class="hljs-string">&#x27;2007年3月位献血: 0&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)plt.scatter(train_x_handled[train_y == <span class="hljs-number">1</span>], np.zeros((<span class="hljs-number">1</span>, train_x_handled[train_y == <span class="hljs-number">1</span>].shape[<span class="hljs-number">0</span>])),            marker=<span class="hljs-string">&#x27;^&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>, label=<span class="hljs-string">&#x27;2007年3月献血: 1&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)plt.legend()plt.title(<span class="hljs-string">&quot;训练集降维情况&quot;</span>)plt.ylabel(<span class="hljs-string">&quot;是否献血/(1/0)&quot;</span>)plt.xlabel(<span class="hljs-string">&quot;样本降维后的参数&quot;</span>)plt.show()</code></pre></div><p>绘制测试集降维后的图表，以降维结果作为横坐标，0|1作为纵坐标。</p><p>本图重在表示降维后，两类样本的位置情况。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225740.png"></p><div class="code-wrapper"><pre><code class="hljs python">plt.scatter(test_x_handled[test_y == <span class="hljs-number">0</span>], np.ones((<span class="hljs-number">1</span>, test_x_handled[test_y == <span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])),               marker=<span class="hljs-string">&#x27;.&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>, label=<span class="hljs-string">&#x27;2007年3月未献血: 0&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)   plt.scatter(test_x_handled[test_y == <span class="hljs-number">1</span>], np.zeros((<span class="hljs-number">1</span>, test_x_handled[test_y == <span class="hljs-number">1</span>].shape[<span class="hljs-number">0</span>])),               marker=<span class="hljs-string">&#x27;^&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>, label=<span class="hljs-string">&#x27;2007年3月献血: 1&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)   plt.legend()   plt.title(<span class="hljs-string">&quot;测试集降维情况&quot;</span>)   plt.ylabel(<span class="hljs-string">&quot;是否献血/(1/0)&quot;</span>)   plt.xlabel(<span class="hljs-string">&quot;样本降维后的参数&quot;</span>)   plt.show()</code></pre></div><p>绘制测试集的预测值与真实值的比较图表。</p><p>横坐标是序号，0~148</p><p>纵坐标是 0 | -1 | +1，0表示未献血，+1 表示真实值的献血，-1表示预测值的献血</p><p>该图结果是，具有不同颜色条形的图表，当某一序号位置某颜色的条形不存在同序号位置的另一色的条形，表示该序号位置的预测值与真实值不一致。</p><p>由图可得准确率：$1-frac{\text{位置不一致的条形个数}}{148}$</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225805.png"></p><div class="code-wrapper"><pre><code class="hljs python">y1 = test_yy2 = pred_yx = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">148</span>)plt.scatter(x, y1, color=<span class="hljs-string">&#x27;#ff4eff&#x27;</span>, label=<span class="hljs-string">&#x27;test&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)plt.scatter(x, -y2, marker=<span class="hljs-string">&#x27;^&#x27;</span>, color=<span class="hljs-string">&#x27;#ba2c01&#x27;</span>, label=<span class="hljs-string">&#x27;pred&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)plt.legend()plt.title(<span class="hljs-string">&quot;真实值与预测值的比较（预测的准确率：&quot;</span> + <span class="hljs-built_in">str</span>(accuracy_score(test_y, pred_y)) + <span class="hljs-string">&quot;)&quot;</span>)plt.ylabel(<span class="hljs-string">&quot;是否献血/(1/0)&quot;</span>)plt.xlabel(<span class="hljs-string">&quot;序号&quot;</span>)plt.show()</code></pre></div><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>将投影矩阵与预测准确度写入了 <code>./output.txt</code> 中。文件内容如下：</p><div class="code-wrapper"><pre><code class="hljs txt">训练结果(w)： [[-0.59843282  0.73633892  0.00455796 -0.31569349]]预测准确度： 0.8918918918918919</code></pre></div><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>本次实验实践了线性判别分析算法。</p><p>经过查阅资料、上手实践后，对线性判别分析（LDA）算法有了一定的了解：</p><ul><li>LDA 有二分类、多分类两种情况<blockquote><p>二分类也可是多分类的特殊情况。<br>二分类和多分类在公式表达上略有不同。<br>二者的算法思路、步骤一致。</p></blockquote></li><li>LDA 步骤：<ol><li>计算类内散度矩阵 $S_w$</li><li>计算类间散度矩阵 $S_b$</li><li>计算矩阵 $S_w^{-1}S_b$</li><li>计算 $S_w^{-1}S_b$ 的最大的 d 个特征值和对应的 d 个特征向量 （$w_1$, $w_2$, … $w_d$），得到投影矩阵 $W$</li><li>计算 降维后的样本 $Z_i &#x3D; X_i * w$</li></ol></li></ul><p>实验的实现还是基于明白数学公式，这还是实验的重难点哦。</p><p>还有一点就是，选择一个合适的图表用来表示可视化的结果也是有点难度的。</p><h3 id="实验参考"><a href="#实验参考" class="headerlink" title="实验参考"></a>实验参考</h3><ul><li><a href="https://www.cnblogs.com/wj-1314/p/10234256.html">Python机器学习笔记：线性判别分析（LDA）算法</a></li><li><a href="https://blog.csdn.net/qq_42103091/article/details/109786330">机器学习(三)：一文读懂线性判别分析（LDA）</a></li><li><a href="https://blog.csdn.net/weixin_44916097/article/details/105809242">机器学习实战笔记5——线性判别分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>决策树 —— 隐形眼镜数据集预测</title>
    <link href="/ml-decision-tree/"/>
    <url>/ml-decision-tree/</url>
    
    <content type="html"><![CDATA[<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><hr><h3 id="决策树思想"><a href="#决策树思想" class="headerlink" title="决策树思想"></a>决策树思想</h3><p>决策树学习的本质：<strong>从训练数据集中归纳出一组分类规则</strong>。</p><blockquote><ul><li><p>可能这种决策规则一个也没有</p></li><li><p>也可能有多个决策规则</p></li></ul></blockquote><p>此时需要选择一个<strong>与数据集矛盾较小</strong>的决策树规则，同时有需要很好的泛化效果。</p><h3 id="学习算法原理"><a href="#学习算法原理" class="headerlink" title="学习算法原理"></a>学习算法原理</h3><ol><li>构造<strong>根节点</strong>，将<strong>所有的训练数据集放入根节点</strong></li><li>选择一个<strong>最优特征</strong>，将训练集<strong>分割成子集</strong>，使得训练及在当前条件下有最好的分类</li><li>如果这些子集已经可能很好的分类，那么构建叶子节点；如果还不能很好的分类，继续对其分割，构造相应的节点</li><li><strong>重复（递归）</strong>进行上述步骤，直至所有训练数据集<strong>被基本正确分类</strong>，或者<strong>没有合适的特征</strong>为止</li></ol><p>经过以上过程，决策树可能对训练集有了很好的分类能力，但是对未知数据不一定同样有很好的分类效果。</p><p>所以，为了避免<strong>过拟合</strong>现象，还需要对生成的树进行<strong>剪枝</strong>，将树变得更简单，以实现更好的泛化能力。</p><p>从上面可以看出，一个决策树学习算法需要包括<strong>特征选取</strong>、<strong>决策树生成</strong>和<strong>决策树剪枝</strong>过程。</p><blockquote><p>常用的学习算法有：</p><ul><li><p><code>ID3</code> [Quinlan, 1986]：最优特征选择标准是<strong>信息增益</strong></p></li><li><p><code>ID4.5</code> [Quinlan, 1993]：最优特征选择标准是<strong>信息增益率</strong></p></li><li><p><code>CART</code> [Breiman, 1984]：最有特征选择标准是<strong>节点方差的大小</strong></p></li></ul></blockquote><h3 id="决策树学习基本算法"><a href="#决策树学习基本算法" class="headerlink" title="决策树学习基本算法"></a>决策树学习基本算法</h3><h3 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h3><p>增益率（gain ratio）<br>$$<br>Gain_ratio(D,a)&#x3D;\frac{Gain(D,a)}{IV(a)}<br>$$<br>其中<br>$$<br>IV(a)&#x3D;-\sum_{v&#x3D;1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}<br>$$<br>称为属性 a 的“固有值”（intrinsic value）[Quinlan, 1993]。</p><p>属性 a 的可能取值数目越多（即 V 越大），则 IV(a) 的值通常会越大。</p><blockquote><p>近看上述公式，并不是很明白增益率如何计算。查阅资料后知，分为几步：</p><ol><li>计算整体的信息熵<br>$$<br>H(X) &#x3D; -\sum_{i &#x3D; 1}^{m}p_ilog_2(p_i)<br>$$</li></ol><ul><li>$m$: 训练数据集结果的标签数</li><li>$p_i$: 第 $i$ 类标签的比例</li></ul><ol start="2"><li>计算某特征的条件熵<br>$$<br>H(X|Y)&#x3D;\sum_{y\in Y}p(y)H(X|Y&#x3D;y)<br>$$</li></ol><ul><li><p>$H(X|Y&#x3D;y)$: 该特征中某标签的条件熵<br>$$<br>H(X|Y &#x3D; y_i) &#x3D;-\sum_{i&#x3D;1}^{n}p_ilog_2(p_i)<br>$$</p></li><li><p>$n$: 在条件为该特征中某标签下，结果的标签数</p></li><li><p>$p_i$: 在条件为该特征中某标签下，第 $i$ 类结果标签的比例</p></li></ul><ol start="3"><li><p>计算某特征的信息增益<br>$$<br>g(X,Y)&#x3D;H(X)-H(X|Y)<br>$$</p></li><li><p>计算某特征的内部信息（Intrinsic Information of an Attribute）<br>其实就是<strong>特征的信息熵</strong><br>$$<br>Intl(X,Y)&#x3D;-\sum_{i&#x3D;1}^{m}\frac{|Y_i|}{|X|}log_2(\frac{|Y_i|}{|X|})<br>$$</p></li></ol><ul><li>$Y$: 表示某个特征的随机变量</li><li>$Y_i$: 该特征的第 $i$  类的个数</li><li>$X$: 表示样本的总个数</li><li>$\frac{|Y_i|}{|X|}$: 表示该特征的第 $i$ 类占样本的比例</li></ul><ol start="5"><li>计算某特征的信息增益率<br>$$<br>g(X|Y)&#x3D;\frac{g(X,Y)}{Intl(X,yY)}<br>$$</li></ol></blockquote><blockquote><p>结合实例理解请详见：<a href="https://blog.csdn.net/u010916338/article/details/94653402">信息增益率</a></p></blockquote><h3 id="决策树算法框架"><a href="#决策树算法框架" class="headerlink" title="决策树算法框架"></a>决策树算法框架</h3><ol><li><p><strong>决策树主函数</strong></p><p>各类决策树的主函数都大同小异，本质上是一个<strong>递归函数</strong>。</p><p>该函数的主要功能是按照某种规则生长出决策树的各个分支节点，并根据终止条件结束算法。</p><p>一般来讲，主函数需要完成如下几个功能：</p><ol><li>输入需要分类的数据集和类别标签</li><li>根据<strong>某种分类规则</strong>得到<strong>最优的划分特征</strong>，并创建特征的划分节点 —— 计算最优特征子函数</li><li>按照该特征的每个取值<strong>划分数据</strong>集为若干部分 —— 划分数据集子函数</li><li>根据划分子函数的计算结果构建出新的节点，作为树生长出的新分支</li><li><strong>检验是否符合递归的终止条件</strong></li><li>将划分的新节点包含的数据集和类别标签作为输入，<strong>递归执行</strong>上述步骤。</li></ol></li><li><p><strong>计算最优特征子函数</strong></p><p>计算最优特征子函数是除主函数外最重要的函数。</p><p>每种决策树之所以不同，一般都是因为<strong>最优特征选择的标准</strong>不同，不同的标准导致不同类型的决策树。如：</p><blockquote><ul><li><p><code>ID3</code> [Quinlan, 1986]：最优特征选择标准是<strong>信息增益</strong></p></li><li><p><code>ID4.5</code> [Quinlan, 1993]：最优特征选择标准是<strong>信息增益率</strong></p></li><li><p><code>CART</code> [Breiman, 1984]：最有特征选择标准是<strong>节点方差的大小</strong></p></li></ul></blockquote></li><li><p><strong>划分数据集子函数</strong></p><p>划分数据集函数的主要功能是分隔数据集，有的需要删除某个特征轴所在的数据列，返回剩余的数据集；有的干脆将数据集一分为二。</p></li><li><p><strong>分类器</strong></p><p>所有的机器学习算法都要勇于分类或回归预测。</p><p>决策树的分类器就是通过遍历整个决策树，使测试集数据找到决策树中叶子节点对应的类别标签。这个标签就是返回的结果。</p></li></ol><h2 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h2><hr><ul><li><p><strong>数据集</strong>：<code>隐形眼镜数据集/lenses_data.txt</code><br>共有 24 个样本:</p><ul><li>4 个<strong>输入变量</strong>(数据集中第一列为<strong>样本编号</strong>)</li><li>1 个输出变量(数据集中最后一列)</li></ul></li><li><p><strong>数据集信息</strong>:</p><ul><li>3 类结果标签：<ul><li><code>1</code>：患者应佩戴硬隐形眼镜</li><li><code>2</code>：患者应佩戴软性隐形眼镜</li><li><code>3</code>：患者不应佩戴隐形眼镜</li></ul></li><li>4 类特征及其标签<ul><li>年龄：<ul><li><code>1</code>：青年</li><li><code>2</code>：中年</li><li><code>3</code>：老年</li></ul></li><li>症状：<ul><li><code>1</code>：近视</li><li><code>2</code>：远视</li></ul></li><li>散光：<ul><li><code>1</code>：否</li><li><code>2</code>：是</li></ul></li><li>眼泪数量：<ul><li><code>1</code>：减少</li><li><code>2</code>：正常</li></ul></li></ul></li><li>详见 <code>隐形眼镜数据集/lenses_names.txt</code></li></ul></li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><hr><ul><li><code>Python</code> 版本：<code>Python 3.6</code></li><li>编辑器：<code>PyCharm</code></li><li>扩展包：<code>numpy</code>、<code>pandas</code>、<code>matplotlib</code> 等<strong>基础扩展包</strong><blockquote><p>不可使用 <code>sklearn</code>、<code>kreas</code> 等<strong>机器学习包</strong></p></blockquote></li></ul><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><hr><ol><li>采用 <code>C4.5</code> 算法建立决策树模型</li><li>将每个特征的信息增益率打印输出</li><li>输出最后建立的决策树模型结构图（可以用 <code>字典结构</code> 表示，也可以用 <code>matplotlib</code> 等图形库绘制出树形图）<blockquote><ul><li>字典表示：<img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230841.png"></li><li>树形图表示：   <img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231217.png" width="60%"/></li></ul></blockquote></li></ol><h2 id="实验代码详解"><a href="#实验代码详解" class="headerlink" title="实验代码详解"></a>实验代码详解</h2><hr><h3 id="读取数据文件"><a href="#读取数据文件" class="headerlink" title="读取数据文件"></a>读取数据文件</h3><p>简单的使用 <code>numpy.loadtxt</code> 读取 <code>txt</code> 的后五行数据。</p><p>一开始读取完数据后还分一下训练集、测试集的，后面发现，这数据是有规律的，就像是四类特征的标签进行了笛卡尔积运算一行，结果的标签也具有一点点的规律。</p><p>又仔细看了看<strong>实验要求</strong>，没说需要预测，只是说需要 <strong>信息增益率</strong> + <strong>决策树结构</strong>。</p><p>所以就，不分训练集和测试集。</p><h3 id="最优特征子函数-——-信息增益率计算"><a href="#最优特征子函数-——-信息增益率计算" class="headerlink" title="最优特征子函数 —— 信息增益率计算"></a>最优特征子函数 —— 信息增益率计算</h3><p>该部分主要是计算各特征的信息增益率，并进行比较，<strong>返回</strong>信息增益率最大的特征的<strong>索引</strong>。</p><p>该计算也分为几步：</p><ol><li>计算标签信息熵：对应函数 <code>get_info_entropy(x)</code></li><li>计算条件信息熵：对应函数 <code>get_conditional_info_entropy(feature, x)</code></li><li>计算信息增益率：对应函数 <code>get_info_gain_ratio(feature, x)</code></li><li><strong>获取最佳信息增益率的索引</strong>：对应函数 <code>get_best_feature(data, label, is_print)</code></li></ol><blockquote><p>计算均按照上述公式</p></blockquote><h3 id="数据集划分子函数"><a href="#数据集划分子函数" class="headerlink" title="数据集划分子函数"></a>数据集划分子函数</h3><p>该部分就是在递归时，获取作为递归参数 —— 数据集。</p><p>该数据集的特征有：</p><ul><li>缺少上一次递归时最佳特征所在的那一列</li><li>缺少的这一列的值均相同</li></ul><blockquote><p>就是：</p><p>该函数会根据最佳特征的标签的情况将数据集划分为 $m$ 类。</p><p>$m$ 是最佳特征标签的个数。</p><p>每类子数据集都是最佳特征标签相同的其他特征数据的集合。</p></blockquote><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">split_dataset</span>(<span class="hljs-params">data, index, value</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    对数据集进行分片</span><span class="hljs-string">    :param data: 需要分片的数据集</span><span class="hljs-string">    :param index: 新数据集不需要的某列的索引</span><span class="hljs-string">    :param value: 用于确定新数据集需要某行在 某列[index]对应的值</span><span class="hljs-string">    :return: 新的数据集</span><span class="hljs-string">    &quot;&quot;&quot;</span>    has_split_dataset = []    <span class="hljs-keyword">for</span> col_data <span class="hljs-keyword">in</span> data:        <span class="hljs-comment"># 选择特定行的数据进行切片</span>        <span class="hljs-keyword">if</span> col_data[index] == value:            <span class="hljs-comment"># 取 第 index 个前的所有元素</span>            has_split_col = col_data[:index].tolist()            <span class="hljs-comment"># 再加上第 index 个后面的所有元素</span>            has_split_col.extend(col_data[index + <span class="hljs-number">1</span>:].tolist())            <span class="hljs-comment"># 再将其加入 新的 数据集</span>            has_split_dataset.append(has_split_col)    <span class="hljs-keyword">return</span> np.array(has_split_dataset)</code></pre></div><h3 id="决策树主函数"><a href="#决策树主函数" class="headerlink" title="决策树主函数"></a>决策树主函数</h3><p>获取数据集中的标签数据：<code>labels = [item[-1] for item in data]</code></p><h4 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h4><ol><li><p>子节点的样本属于同一类标签</p><p>返回该类标签</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels)):    <span class="hljs-keyword">return</span> labels[<span class="hljs-number">0</span>]</code></pre></div></li><li><p>子节点样本的特征标签相同，或是没有了样本</p><p> 返回出现次数最多的标签</p> <div class="code-wrapper"><pre><code class="hljs python">    <span class="hljs-comment"># 特征集为空 或是 特征集上的取值相同，停止分类</span>    <span class="hljs-comment"># 返回出现次数最多的 标签</span>    <span class="hljs-comment"># len(data[0]) == 1 就是数据集里只剩下标签，没有特征了</span>    <span class="hljs-comment"># len(set(data[:, 0])) == 1 特征集上的取值相同</span>    <span class="hljs-comment"># not feature_label 特征集空了</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data[<span class="hljs-number">0</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(data[:, <span class="hljs-number">0</span>])) == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> most_label(labels)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">most_label</span>(<span class="hljs-params">data</span>):        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        返回，出现次数最大多的标签</span><span class="hljs-string">        &quot;&quot;&quot;</span>        label = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(data))        most = <span class="hljs-string">&#x27;&#x27;</span>        most_count = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> item_label <span class="hljs-keyword">in</span> label:            count = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> item_data <span class="hljs-keyword">in</span> data:                <span class="hljs-keyword">if</span> item_label == item_data:                    count += <span class="hljs-number">1</span>            most = item_label <span class="hljs-keyword">if</span> count &gt; most_count <span class="hljs-keyword">else</span> most            most_count = count        <span class="hljs-keyword">return</span> most    ```Glasses<span class="hljs-number">3.</span> 特征集为空      返回出现次数最多的标签   ```python       <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> feature_label:           <span class="hljs-keyword">return</span> most_label(labels)</code></pre></div></li></ol><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><ul><li>通过最优特征子函数获取最优特征的索引</li><li>根据索引从特征集中获取最有特征</li><li>将最优特征添加到决策树中</li><li>删除特征集中的最优特征<blockquote><p>该删除并非真的删除，而是进入递归时，进入递归的特征集不包含最优特征</p></blockquote></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 从特征标签中选择最优划分标签</span><span class="hljs-comment"># 选择最优标签</span>best_index = get_best_feature(data[:, <span class="hljs-number">0</span>:-<span class="hljs-number">1</span>], np.array(labels), <span class="hljs-literal">False</span>)<span class="hljs-comment"># 获取最优的标签</span>best_feature_label = feature_label[best_index]<span class="hljs-comment"># 根据最优特征的标签生成树</span>decision_tree = &#123;best_feature_label: &#123;&#125;&#125;<span class="hljs-comment"># 删除已使用的标签</span><span class="hljs-comment"># del (feature_label[best_index])</span></code></pre></div><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><ul><li>获取数据集中最优特征的所有数据</li><li>根据数据获取特征标签</li><li>根据特征标签创建分支</li><li>进入递归：<ul><li>划分数据集，作为递归中的数据集参数</li><li>划分特征集，作为递归中的特征集参数</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 得到训练集中所有最优特征的标签</span>feat_value = [item[best_index] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data]<span class="hljs-comment"># 去掉重复值</span><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(feat_value):    decision_tree[best_feature_label][value] = create_decision_tree(        split_dataset(data, best_index, value),         split_feature(feature_label, best_index))</code></pre></div><p>两个划分函数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">split_dataset</span>(<span class="hljs-params">data, index, value</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    对数据集进行分片</span><span class="hljs-string">    :param data: 需要分片的数据集</span><span class="hljs-string">    :param index: 新数据集不需要的某列的索引</span><span class="hljs-string">    :param value: 用于确定新数据集需要某行在 某列[index]对应的值</span><span class="hljs-string">    :return: 新的数据集</span><span class="hljs-string">    &quot;&quot;&quot;</span>    has_split_dataset = []    <span class="hljs-keyword">for</span> col_data <span class="hljs-keyword">in</span> data:        <span class="hljs-comment"># 选择特定行的数据进行切片</span>        <span class="hljs-keyword">if</span> col_data[index] == value:            <span class="hljs-comment"># 取 第 index 个前的所有元素</span>            has_split_col = col_data[:index].tolist()            <span class="hljs-comment"># 再加上第 index 个后面的所有元素</span>            has_split_col.extend(col_data[index + <span class="hljs-number">1</span>:].tolist())            <span class="hljs-comment"># 再将其加入 新的 数据集</span>            has_split_dataset.append(has_split_col)    <span class="hljs-keyword">return</span> np.array(has_split_dataset)<span class="hljs-keyword">def</span> <span class="hljs-title function_">split_feature</span>(<span class="hljs-params">label, index</span>):    error_deal = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(label)):        <span class="hljs-keyword">if</span> i != index:            error_deal.append(label[i])    <span class="hljs-keyword">return</span> error_deal</code></pre></div><h4 id="返回决策树"><a href="#返回决策树" class="headerlink" title="返回决策树"></a>返回决策树</h4><p>当分支创建完毕后，就返回决策树。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><hr><p>实验结果输出<strong>各特征的信息增益率</strong>和<strong>决策树模型</strong>（<code>元组结构</code>）。</p><p>信息增益率：</p><div class="code-wrapper"><pre><code class="hljs txt">第 1 个特征的信息增益率为 0.02485642633702430第 2 个特征的信息增益率为 0.03951083542356582第 3 个特征的信息增益率为 0.37700523001147723第 4 个特征的信息增益率为 0.54879494069539858</code></pre></div><p>决策树模型（手动进行了格式化处理）：</p><div class="code-wrapper"><pre><code class="hljs txt">&#123;    &#x27;眼泪数量&#x27;:     &#123;        1: 3,         2:         &#123;            &#x27;散光&#x27;:             &#123;                1:                 &#123;                    &#x27;年龄&#x27;:                     &#123;                        1: 2,                         2: 2,                         3:                         &#123;                            &#x27;症状&#x27;:                             &#123;                                1: 3,                                 2: 2                            &#125;                        &#125;                    &#125;                &#125;,                 2:                 &#123;                    &#x27;症状&#x27;:                     &#123;                        1: 1,                         2:                         &#123;                            &#x27;年龄&#x27;:                             &#123;                                1: 1,                                 2: 3,                                 3: 3                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><blockquote><p>文件中显示的为：</p><p>{‘眼泪数量’: {1: 3, 2: {‘散光’: {1: {‘年龄’: {1: 2, 2: 2, 3: {‘症状’: {1: 3, 2: 2}}}}, 2: {‘症状’: {1: 1, 2: {‘年龄’: {1: 1, 2: 3, 3: 3}}}}}}}}</p></blockquote><blockquote><p>结果均输出在 <code>output.txt</code> 文件中。</p></blockquote><h2 id="实验心得体会"><a href="#实验心得体会" class="headerlink" title="实验心得体会"></a>实验心得体会</h2><hr><p>实验就，很有意思。</p><h3 id="遇到的问题及解决办法"><a href="#遇到的问题及解决办法" class="headerlink" title="遇到的问题及解决办法"></a>遇到的问题及解决办法</h3><hr><p>主要是递归终止条件上的问题，未能很好的明确递归终止的条件，经过一番查询及自己思考后，明确了四个条件：</p><ol><li><strong>子节点的样本属于同一类标签</strong>：返回该类标签</li><li><strong>子节点样本的特征标签相同</strong>：返回出现次数最多的标签</li><li><strong>子节点没有样本</strong>：返回出现次数最多的标签</li><li><strong>特征集为空</strong>：返回出现次数最多的标签</li></ol><p>总的就算两种情况下的终止条件：</p><ol><li>返回出现次数最多的标签：<strong>子节点样本的特征标签相同</strong>、<strong>子节点没有样本</strong>、<strong>特征集为空</strong></li><li>返回该类标签：<strong>子节点的样本属于同一类标签</strong></li></ol><p>还有一个问题就是，也是浪费时间比较多的问题：<strong>特征集在递归中会提前为空，以至于在子节点中的样本还没有完全分类时，就提前结束了递归，返回了决策树</strong>。</p><p>此时的实验结果是：</p><p>{‘眼泪数量’:{1: 3,2:{‘散光’:{1:{‘年龄’:{1: 2,2: 2,3:{‘症状’:{1: 3,2: 2}}}},2: 1}}}}</p><p>仔细审查后发现是特征集在里层递归改变后，外层的递归中也发生了改变。虽然发现了上述问题的原因，但是并没有明白导致该问题是因为什么。</p><p>经过一番思索获得了解决问题的方法，然后得到下面的结果：</p><p>{‘眼泪数量’: {1: 3, 2: {‘散光’: {1: {‘年龄’: {1: 2, 2: 2, 3: {‘年龄’: {1: 3, 2: 2}}}}, 2: {‘症状’: {1: 1, 2: {‘年龄’: {1: 1, 2: 3, 3: 3}}}}}}}}</p><p>{‘眼泪数量’: {1: 3, 2: {‘散光’: {1: {‘年龄’: {1: 2, 2: 2, 3: {‘症状’: {1: 3, 2: 2}}}}, 2: {‘年龄’: {1: 1, 2: {‘症状’: {1: 1, 2: 3, 3: 3}}}}}}}}</p><p>但是并不能解决问题。</p><p>后面根据自己仔细地、一步步试错，发现是特征集的数据类型，在经过删除操作后，会改变其他所有后续执行中的特征集。</p><p>这也就是为什么“特征集在递归中会提前为空，以至于在子节点中的样本还没有完全分类时，就提前结束了递归，返回了决策树”。</p><p>此时便想起特征集的内存地址都是一样的，无论什么操作都是对同一内存地址上的数据进行操作，也就导致这里动、那里变，就导致“特征集提前为空”。</p><p>然后查看特征集的数据类型 —— <strong>list，列表</strong>，一查其存储方式，果然如此</p><blockquote><p>列表如何存储？</p><p>列表本质是动态的数组，列表存储的是每个元素在内存中的地址（即引用），当列表中空白占位低于1&#x2F;3时，会在内存中开辟一块更大的空间，并将旧列表中存储的地址复制到新列表中，旧列表则被销毁，这样就实现了扩容。因为列表存储的是元素的引用这个特性，而引用所占的内存空间是相同的，这样便可以同时存放不同类型的数据了。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><ul><li><a href="https://zhuanlan.zhihu.com/p/126294494">决策树算法</a></li><li><a href="https://blog.csdn.net/sumatch/article/details/103680771">(python)列表和字典的存储方式</a></li><li><a href="https://www.jianshu.com/p/d153130b813f">决策树的基本结构及三个终止条件</a></li><li><a href="https://blog.csdn.net/u010916338/article/details/94653402">信息增益率</a></li><li><a href="https://www.cnblogs.com/EnzoDin/p/12417184.html">机器学习-决策树的基本思想</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【水博客】Ubuntu Update 失败：Release file is not valid yet</title>
    <link href="/ubuntu-update-failed/"/>
    <url>/ubuntu-update-failed/</url>
    
    <content type="html"><![CDATA[<p>ᕕ( ᐛ )ᕗ</p><p>(ノﾟ∀ﾟ)ノ举高高</p><p>( へ ﾟ∀ﾟ)べ摔低低</p><p>(&#96;ヮ´ ) 开摆！</p><p>↙(&#96;ヮ´ )↗ 开摆！</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>该问题是在 <code>Windows</code> 下使用 <code>Linux</code> 子系统 <code>Ubuntu</code> 时，执行了 <code>sudo apt update</code> 命令后，就出现问题：</p><p><img src="https://s1.ax1x.com/2022/05/09/OGlyCD.png"></p><div class="code-wrapper"><pre><code class="hljs awk">E: Release file <span class="hljs-keyword">for</span> https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span>dists<span class="hljs-regexp">/focal-updates/</span>InRelease is not valid yet (invalid <span class="hljs-keyword">for</span> another <span class="hljs-number">5</span>h <span class="hljs-number">35</span>min <span class="hljs-number">12</span>s). Updates <span class="hljs-keyword">for</span> this repository will not be applied.E: Release file <span class="hljs-keyword">for</span> https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span>dists<span class="hljs-regexp">/focal-backports/</span>InRelease is not valid yet (invalid <span class="hljs-keyword">for</span> another <span class="hljs-number">5</span>h <span class="hljs-number">36</span>min <span class="hljs-number">30</span>s). Updates <span class="hljs-keyword">for</span> this repository will not be applied.E: Release file <span class="hljs-keyword">for</span> https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span>dists<span class="hljs-regexp">/focal-security/</span>InRelease is not valid yet (invalid <span class="hljs-keyword">for</span> another <span class="hljs-number">5</span>h <span class="hljs-number">34</span>min <span class="hljs-number">27</span>s). Updates <span class="hljs-keyword">for</span> this repository will not be applied.</code></pre></div><p>意思就是：<strong>发布文件尚未生效（在另一个 5 小时 35 分钟 12 秒内无效）。不会应用此存储库的更新。</strong></p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>经过一番搜索后发现了问题 —— 咱 <code>Ubuntu</code> 上的时间与清华大学 <code>TUNA</code> 的软件源镜像的时间不一致，咱的系统时间比它慢了几个小时。</p><blockquote><p>错误的原因是系统上的时间和现实世界的时间不同。</p></blockquote><p>为啥会出现这种问题呢？</p><p>咱电脑安装了双系统的，<code>windows 11</code> + <code>manjaro</code>，上午的时候玩了一会 <code>manjaro</code>，整了一会后，回到 <code>windows 11</code>，发现咱的时间晚了 8 小时，但是咱没有注意到时间的变化，就安装了咱们的 <code>ubuntu</code>，因而该系统的时间也是跟着咱 <code>windows 11</code> 的时间一样，慢了 8 小时。但是这会，咱执行 <code>sudo apt update</code> 是没问题的哦。后来咱就发现电脑时间不对，就赶紧更新了电脑时间，后重新启动了 <code>ubuntu</code>，仍旧执行了 <code>sudo apt update</code> 命令，这会就出现问题了。</p><p>提示：<strong>发布文件尚未生效（在另一个 5 小时 35 分钟 12 秒内无效）。不会应用此存储库的更新。</strong></p><p>执行 <code>date</code> 命令查看时间：</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">date</span></code></pre></div><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628221558.png"></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>想要解决问题呀，简单的改一下 <code>ubuntu</code> 的时间就好，改成和 <code>windows 11</code> 时间一样就行。</p><p>执行 <code>sudo date -s xxxxxx</code> 设置系统时间</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> date -s <span class="hljs-number">12</span>:<span class="hljs-number">40</span>:<span class="hljs-number">50</span></code></pre></div><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628221120.png"></p><blockquote><p>我这知识时间不对，因而仅修改了时间。<br>若是日期也不对就需要执行：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> date -s <span class="hljs-number">2022</span>-<span class="hljs-number">5</span>-<span class="hljs-number">9</span> <span class="hljs-number">12</span>:<span class="hljs-number">40</span>:<span class="hljs-number">50</span></code></pre></div></blockquote><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628222226.png"></p><p>OK! 问题成功解决。</p><p>(&#96;ヮ´ ) 开摆！</p><p>↙(&#96;ヮ´ )↗ 开摆！</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows PowerShell 美化</title>
    <link href="/powershell-beauty/"/>
    <url>/powershell-beauty/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这是属于颜狗的胜利，丑不拉几的都不是咱们颜狗想要的，终端也是可以花里胡哨的，人家 <code>linux</code> 可以使用 <code>oh-my-zsh</code>，将他们的 terminal 打扮的花里胡哨的，咱们 <code>windows</code> 下的 <code>terminal</code> 也要站起来。所以大佬们就站出来了，他们做出来了 <code>oh-my-posh</code>，让咱们 <code>windows</code> 也可以使用漂漂亮亮的终端。</p><blockquote><p><code>windows terminal</code> 也可以装饰咱们的终端，但是，不够呀，咱们想要做成 <code>oh-my-zsh</code> 那样的漂漂亮亮。知道<strong>提示符（Prompt）</strong>也需要烧烧的。</p></blockquote><p><a href="https://ohmyposh.dev/">Oh My Posh</a> —— A prompt theme engine for any shell.</p><p><a href="https://ohmyposh.dev/">Oh My Posh</a> 正是这样一款终端 <code>Prompt</code> 个性化工具，虽然肇始于同类工具 <code>Oh My Zsh</code>，但当更新到 <code>5.0</code> 版本时，重新设计的 <code>Oh my posh</code> 已经摆脱平台的桎梏，支持了 <code>Windows、GNU/Linux（WSL）</code>、<code>macOS</code> 三个系统上的 <code>PowerShell</code>、<code>bash</code>、<code>zsh</code> 等终端。</p><p><strong>需要使用</strong> <code>WindowsTerminal</code>。</p><h3 id="安装-Oh-My-Posh"><a href="#安装-Oh-My-Posh" class="headerlink" title="安装 Oh My Posh"></a>安装 Oh My Posh</h3><p>官方文档上写到，<code>Oh My Posh</code> 在 <code>windows</code> 下有三种安装途径：<code>winget</code>、<code>scoop</code>、<code>manual</code>。本文通过 <code>scoop</code> 进行安装。</p><blockquote><p>想使用其他方法的可进官方文档查看 —— <a href="https://ohmyposh.dev/docs/installation/windows">Windows Install Oh My Posh</a></p></blockquote><h4 id="Scoop"><a href="#Scoop" class="headerlink" title="Scoop"></a>Scoop</h4><p>在安装 <code>Oh My Posh</code> 之前，还需要安装一个 <code>Windows</code> 下的包管理工具 —— <code>Scoop</code>。</p><blockquote><p><a href="https://scoop.sh/#/">Scoop</a> 是 Windows 下的一款十分强大的包管理器，可以用来下载和管理各种软件包<br>首次需要打开并运行 <code>PowerShell terminal</code> (version 5.1 or later)。</p></blockquote><p>然后使用下列命令进行安装：</p><div class="code-wrapper"><pre><code class="hljs shell">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser <span class="hljs-meta prompt_"># </span><span class="language-bash">Optional: Needed to run a remote script the first time</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">Invoke-WebRequest get.scoop.sh | Invoke-Expression</code></pre></div><h4 id="Oh-My-Posh"><a href="#Oh-My-Posh" class="headerlink" title="Oh My Posh"></a>Oh My Posh</h4><p>通过 <code>scoop</code> 进行安装：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231646.png"></p><p>当出现图示内容（绿色）时，说明安装成功。</p><blockquote><p>除了使用官方文档提到的方式进行安装。还可以使用 <code>scoop install oh-my-posh</code> 进行安装。<br>这是 <a href="https://scoop.sh/#/apps?q=oh-my-posh">scoop apps</a>中所提到的。<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231715.png"><br>使用此种方法时，要跟着文档的方法走哦。<br>安装成功截图：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231734.png"></p></blockquote><blockquote><p>如果想要卸载 Oh My Posh 的话，可以使用命令 <code>scoop uninstall oh-my-posh</code>，进行卸载。<br>卸载成功截图：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231750.png"></p></blockquote><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231811.png"></p><p><a href="https://ohmyposh.dev/docs/installation/windows">Oh My Posh</a> 提示到** 要显示所有图标，我们建议使用 <code>Nerd Font</code>。**</p><p>所以咱就下载 <a href="https://www.nerdfonts.com/font-downloads">Nerd Font</a> 字体吧。</p><p>如果不适用 <code>Nerd Font</code> 的话，就会出现这种情况：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231833.png"></p><p>可见 icon 们均没有正常显示，而是显示的方框，这也是为什么要使用 <code>Nerd Font</code> 的原因了。</p><blockquote><p>人家自己也说了—— “To display all icons, we recommend the use of a Nerd Font.”</p></blockquote><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231854.png"></p><p>进入官网后选择一个中意的字体下载就行。我自己使用的 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip">Hack Nerd Font</a>（点击可直接下载该字体）</p><p>然后进行安装啦，打开压缩包，选择喜欢的（细、粗）字体，然后点击安装。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231910.png"></p><blockquote><p>也可以使用 <code>scoop</code> 安装 <code>Nerd Font</code> 字体：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop bucket add nerd-fonts</code></pre></div><p>再在 <a href="https://github.com/matthewjberger/scoop-nerd-fonts/tree/master/bucket">nerd fonts 字体库</a> 找到需要安装的字体。<br>然后就执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop install Hack-NF</code></pre></div><p>安装完成后需要重启 Windows Terminal 才可以设置字体哦，否则会设置失败。</p></blockquote><p>最后，在 <code>windows terminal</code> 中将字体选择为 <code>Hack Nerd Font</code>，即可。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231927.png"></p><h4 id="posh-git"><a href="#posh-git" class="headerlink" title="posh-git"></a>posh-git</h4><p><a href="https://github.com/dahlbyk/posh-git">posh-git</a> 可以在 <code>PowerShell</code> 中显示 <code>Git</code> 状态的摘要信息并自动补全 <code>Git</code> 命令。</p><p>通过 <code>scoop</code> 来安装，依次执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop bucket add extras</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628231945.png"></p><div class="code-wrapper"><pre><code class="hljs shell">scoop install posh-git</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232008.png"></p><h4 id="Terminal-Icons"><a href="#Terminal-Icons" class="headerlink" title="Terminal-Icons"></a>Terminal-Icons</h4><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232029.png"></p><p><a href="https://github.com/devblackops/Terminal-Icons">Terminal-Icons</a> 可以在 <code>PowerShell</code> 中显示项目图标并以颜色区分。让你的 <code>Powershell</code> 变得更加的花哨。</p><p>通过 <code>scoop</code> 来安装，依次执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">scoop bucket add extras</code></pre></div><blockquote><p>前文中已执行过该命令，此次可不在执行。</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">scoop install terminal-icons</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232046.png"></p><blockquote><p>安装完成后，还贴心的提示了如何使用呢。</p></blockquote><h3 id="配置-Oh-My-Posh"><a href="#配置-Oh-My-Posh" class="headerlink" title="配置 Oh My Posh"></a>配置 Oh My Posh</h3><p>完成上述的安装后，启动 <code>PowerShell</code> 时并不会默认加载个性化后的配置，因此需要修改 <code>PowerShell</code> 配置文件来让每次启动都加载。</p><p>执行命令打开配置文件：</p><div class="code-wrapper"><pre><code class="hljs shell">notepad $PROFILE</code></pre></div><p>若提示不存在文件，且提示是否创建文件，则直接创建，否则需要手动在 <code>PowerShell</code> 目录下创建一个配置文件再进行编辑。</p><p>若需手动创建配置文件，则依次执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">mkdir ~\Documents\WindowsPowerShell<span class="hljs-meta prompt_"># </span><span class="language-bash">创建文件夹</span>echo &quot;&quot; &gt; ~\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1<span class="hljs-meta prompt_"># </span><span class="language-bash">创建配置文件</span></code></pre></div><p>最后向配置文件中添加：</p><div class="code-wrapper"><pre><code class="hljs ps1"><span class="hljs-comment"># 使用 oh my posh</span><span class="hljs-built_in">oh</span><span class="hljs-literal">-my-posh</span> init pwsh | <span class="hljs-built_in">Invoke-Expression</span><span class="hljs-comment"># 使用 Terminal-Icons</span><span class="hljs-built_in">Import-Module</span> Terminal<span class="hljs-literal">-Icons</span><span class="hljs-comment"># 使用 posh-git</span><span class="hljs-built_in">Import-Module</span> posh<span class="hljs-literal">-git</span></code></pre></div><p>最后重新启动 <code>PowerShell</code>，或者是输入命令 <code>powershell</code> 即可查看美化后的界面。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232107.png"></p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>完成全部安装和配置后，使用的是默认主题，如果想要切换成其它主题，可以去 <a href="https://ohmyposh.dev/docs/themes">官方主题目录</a> 查看各种主题的效果，同时这些主题也被安装在 <code>Oh My Pos</code>h 的主题目录下。</p><p>通过 <code>scoop</code> 安装后的主题目录为：</p><div class="code-wrapper"><pre><code class="hljs shell">~\scoop\apps\oh-my-posh\current\themes</code></pre></div><p>所有主题配置文件都放在这里，并以 <code>.omp.json</code> 结尾，从其它地方下载的主题配置文件也需要放在这里。</p><p>在终端中执行以下命令，就可以查看所有主题在终端中的效果：</p><div class="code-wrapper"><pre><code class="hljs shell">Get-PoshThemes ~\scoop\apps\oh-my-posh\current\themes</code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232123.png"></p><p>选择一个主题的名字，如 <code>paradox</code>，然后编辑 <code>PowerShell</code> 的配置文件，执行命令：</p><div class="code-wrapper"><pre><code class="hljs shell">notepad $PROFILE</code></pre></div><p>将其中的 <code>oh-my-posh init pwsh | Invoke-Expression</code> 加上 <code>--config [主题路径]</code> 参数：</p><div class="code-wrapper"><pre><code class="hljs applescript">oh-<span class="hljs-keyword">my</span>-posh init pwsh <span class="hljs-comment">--config ~\scoop\apps\oh-my-posh\current\themes\paradox.json | Invoke-Expression</span></code></pre></div><p>最后重新启动 <code>PowerShell</code>，或者是输入命令 <code>powershell</code> 即可查看美化后的界面。</p><h3 id="配置-VS-code"><a href="#配置-VS-code" class="headerlink" title="配置 VS code"></a>配置 VS code</h3><p>在 <code>VS code</code> 中也能打开 <code>PowerShell</code> 终端，但是由于没有配置终端字体，因为 icon 们还是没有正常显示，而是显示的方框。</p><p>因此需要设置 <code>VSCode</code> 的终端字体为 <code>Hack Nerd Font</code> 才能正常显示。</p><p>首先打开<strong>设置</strong>，搜索 <code>Terminal &gt; Integrated &gt; Font Family</code>。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232142.png"></p><p>然后添加 <code>Hack Nerd Font</code>。</p><p>最后重新打开终端，或是执行 <code>powershell</code>，即可查看美化界面。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232205.png"></p><h3 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h3><p>完成上述配置，以及对 <code>Windows Terminal</code> 的配置文件进行修改后，咱就获得了一个花哨的 <code>PowerShell</code>:</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232221.png"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://ohmyposh.dev/">Oh My Posh | A prompt theme engine for any shell</a></li><li><a href="https://scoop.sh/#/">Scoop | A command-line installer for Windows</a></li><li><a href="https://sspai.com/post/69911">Oh My Posh：全平台终端提示符个性化工具</a></li><li><a href="https://www.raimis.me/archives/80/">使用 Oh My Posh 来个性化终端</a></li><li><a href="https://blog.davidz.cn/beauty-is-productivity-windows-terminal/">颜值是第一生产力 - Windows Terminal</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd716f5">果然颜值才是第一生产力……power-shell美化</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Terminal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Beauty</tag>
      
      <tag>Terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多元线性回归 —— 波士顿房价预测</title>
    <link href="/ml-boston-housing/"/>
    <url>/ml-boston-housing/</url>
    
    <content type="html"><![CDATA[<h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p><strong>多元线性回归——最小二乘法</strong></p><h3 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h3><p><strong>波士顿房价数据集</strong></p><p>数据集的获得:</p><ul><li><p><a href="https://www.kaggle.com/datasets/altavish/boston-housing-dataset?resource=download">下载</a> </p></li><li><p>通过包导入</p><blockquote><p>下载获得数据集有点小问题，因而我是用的 <code>包导入</code>。<br>  <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasetsboston = datasets.load_boston()<span class="hljs-comment"># 将房价信息转成dataFrame格式</span>df_boston_house_data = pd.DataFrame(boston.data, columns=boston.feature_names)df_boston_house_data[<span class="hljs-string">&#x27;PRICE&#x27;</span>] = boston.target<span class="hljs-comment"># 查看数据是否存在空值，从结果来看数据不存在空值。</span><span class="hljs-comment"># print(df_boston_house_data.isnull().sum())</span><span class="hljs-comment"># 查看数据大小</span><span class="hljs-comment"># print(df_boston_house_data.shape)</span><span class="hljs-comment"># 显示数据前5行</span><span class="hljs-comment"># print(df_boston_house_data.head())</span><span class="hljs-comment"># 将数据集写入csv文件</span>df_boston_house_data.to_csv(<span class="hljs-string">&quot;boston_housing_data.csv&quot;</span>, index=<span class="hljs-literal">False</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)</code></pre></div></p></blockquote></li><li><p>该数据集是一个回归问题。每个类的观察值数量是均等的，共有 506 个观察，13 个输入变量（数据集中前13列）和1个输出变量（最后一列）。</p></li><li><p>每条数据包含房屋以及房屋周围的详细信息。其中包含城镇犯罪率，一氧化氮浓度，住宅平均房间数，到中心区域的加权距离以及自住房平均房价等等。</p></li></ul><table><thead><tr><th align="center">属性名</th><th align="center">解释</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">CRIM</td><td align="center">该镇的人均犯罪率</td><td align="center">连续值</td></tr><tr><td align="center">ZN</td><td align="center">占地面积超过25,000平方呎的住宅用地比例</td><td align="center">连续值</td></tr><tr><td align="center">INDUS</td><td align="center">非零售商业用地比例</td><td align="center">连续值</td></tr><tr><td align="center">CHAS</td><td align="center">是否邻近 Charles River（查尔斯河）</td><td align="center">离散值，1&#x3D;邻近；0&#x3D;不邻近</td></tr><tr><td align="center">NOX</td><td align="center">一氧化氮浓度</td><td align="center">连续值</td></tr><tr><td align="center">RM</td><td align="center">每栋房屋的平均客房数</td><td align="center">连续值</td></tr><tr><td align="center">AGE</td><td align="center">1940年之前建成的自用单位比例</td><td align="center">连续值</td></tr><tr><td align="center">DIS</td><td align="center">到波士顿5个就业中心的加权距离</td><td align="center">连续值</td></tr><tr><td align="center">RAD</td><td align="center">到径向公路的可达性指数</td><td align="center">连续值</td></tr><tr><td align="center">TAX</td><td align="center">全值财产税率</td><td align="center">连续值</td></tr><tr><td align="center">PTRATIO</td><td align="center">学生与教师的比例</td><td align="center">连续值</td></tr><tr><td align="center">B</td><td align="center">$1000(BK - 0.63)^2$，其中BK为黑人占比</td><td align="center">连续值</td></tr><tr><td align="center">LSTAT</td><td align="center">低收入人群占比</td><td align="center">连续值</td></tr><tr><td align="center">MEDV</td><td align="center">同类房屋价格的中位数</td><td align="center">连续值</td></tr></tbody></table><h3 id="实验详解"><a href="#实验详解" class="headerlink" title="实验详解"></a>实验详解</h3><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230435.png"><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230614.png"></p><p>简单的说就是，本次实验需要求得是：<br>$$<br>f(x)&#x3D;w_1x_1 + w_2x_2+…+w_dx_d+b<br>$$<br>中的 $w_1,w_2,…,w_d,b(d&#x3D;13)$，然后通过这 14 个参数与测试集的前 13 个变量进行计算，求得预测的房价。</p><p>参数使用下列算式计算：<br>$$<br>w^* &#x3D; (X^TX)^{-1}X^Ty<br>$$<br>其中：</p><ul><li>$w^*$：是所求的参数组成的一列矩阵</li><li>$X$: 训练集前 13 列变量组成的矩阵</li><li>$y$: 训练集第 14 列变量组成的矩阵</li><li>$X^T$：$X$ 的转置矩阵</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>Python 3.9</li><li>编辑器：<code>Pycharm</code></li><li>可使用 <code>numpy</code>、<code>pandas</code>、<code>matplotlib</code> 等基础扩展包，建议使用 <code>anaconda</code> 安装</li><li>不可使用 <code>sklearn</code>、<code>pytorch</code> 等机器学习包</li></ul><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><ol><li>将数据集拆分成训练集（前 450 个样本）和测试集（后 56 个样本）</li><li>利用多元线性回归模型（<strong>最小二乘法</strong>或者<strong>梯度下降法</strong>均可）对训练数据进行拟合</li><li>对拟合得到的模型在测试集上进行测试，使用均方误差作为实验的准确结果并输出。</li></ol><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><ol><li>数据集获得<br>使用 <code>sklearn</code> 包导入数据集，但是仅仅是导入，写入 csv 文件，后续使用的数据集均是从 csv 文件读取的。<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasetsboston = datasets.load_boston()<span class="hljs-comment"># 将房价信息转成dataFrame格式</span>df_boston_house_data = pd.DataFrame(boston.data, columns=boston.feature_names)df_boston_house_data[<span class="hljs-string">&#x27;PRICE&#x27;</span>] = boston.target<span class="hljs-comment"># 查看数据是否存在空值，从结果来看数据不存在空值。</span><span class="hljs-comment"># print(df_boston_house_data.isnull().sum())</span><span class="hljs-comment"># 查看数据大小</span><span class="hljs-comment"># print(df_boston_house_data.shape)</span><span class="hljs-comment"># 显示数据前5行</span><span class="hljs-comment"># print(df_boston_house_data.head())</span><span class="hljs-comment"># 将数据集写入csv文件</span>df_boston_house_data.to_csv(<span class="hljs-string">&quot;boston_housing_data.csv&quot;</span>, index=<span class="hljs-literal">False</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)</code></pre></div></li><li>读取数据集<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">file_path</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"> 从文件路径中读取数据集</span><span class="hljs-string"> :param file_path: 文件路径</span><span class="hljs-string"> :return: 返回一个 dataFrame</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-keyword">return</span> pd.read_csv(file_path, sep=<span class="hljs-string">&#x27;,&#x27;</span>)</code></pre></div></li><li>数据集拆分为训练集和测试集<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_training_data</span>(<span class="hljs-params">df, num</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"> 从 df 中获得训练集</span><span class="hljs-string"> :param num:</span><span class="hljs-string"> :param df:</span><span class="hljs-string"> :return:</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-comment"># 取测试集的前450项</span> df_training = df.head(num) <span class="hljs-keyword">return</span> df_training <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_test_data</span>(<span class="hljs-params">df, num</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"> 从 df 中获取测试集</span><span class="hljs-string"> :param df:</span><span class="hljs-string"> :param num:</span><span class="hljs-string"> :return:</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-comment"># 取数据集的后50项</span> df_test = df.tail(num) <span class="hljs-keyword">return</span> df_test</code></pre></div></li><li>计算学习的模型<br>通过公式进行计算。<br>$$w^* &#x3D; (X^TX)^{-1}X^Ty$$<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">model_calculation</span>(<span class="hljs-params">df_x, df_y</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"> 计算模型</span><span class="hljs-string"> :param df_x:</span><span class="hljs-string"> :param df_y:</span><span class="hljs-string"> :return:</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-comment"># 定义大小为 450 的全1数组，用于在 X 矩阵前插入一列全 1 的数</span> one_matrix = np.full(<span class="hljs-built_in">len</span>(df_x), <span class="hljs-number">1</span>, dtype=<span class="hljs-built_in">int</span>) <span class="hljs-comment"># X 第一列插入 一列 1，获得 X 矩阵</span> x_matrix = np.insert(dataframe_to_matrix(df_x), <span class="hljs-number">0</span>, values=one_matrix, axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># y 矩阵</span> y_matrix = dataframe_to_matrix(df_y) <span class="hljs-comment"># X，y 通过计算获得 β 参数</span> beta = np.dot(np.linalg.inv(np.dot(x_matrix.T, x_matrix)), np.dot(x_matrix.T, y_matrix))  <span class="hljs-keyword">return</span> beta</code></pre></div></li><li>通过模型获得房价预测值<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_estimate</span>(<span class="hljs-params">beta, df_test</span>): <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"></span><span class="hljs-string"> :param beta: β的矩阵</span><span class="hljs-string"> :param df_test: 测试集</span><span class="hljs-string"> :return: 返回预测价格的矩阵（数组）</span><span class="hljs-string"> &quot;&quot;&quot;</span> <span class="hljs-comment"># 先定义预测值的数组，大小等于测试样例大小，用0填充</span> estimate = np.full(<span class="hljs-built_in">len</span>(df_test), <span class="hljs-number">0</span>, dtype=<span class="hljs-built_in">int</span>) <span class="hljs-comment"># 定义大小为56的全1数组，用于在 X 矩阵前插入一列全 1 的数</span> one_matrix = np.full(<span class="hljs-built_in">len</span>(df_test), <span class="hljs-number">1</span>, dtype=<span class="hljs-built_in">int</span>) <span class="hljs-comment"># 将测试集中的前13项作为 矩阵 X 的数</span> test_matrix = dataframe_to_matrix(get_not_last_column(df_test)) <span class="hljs-comment"># X 第一列插入 一列 1</span> test_matrix = np.insert(test_matrix, <span class="hljs-number">0</span>, values=one_matrix, axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># print(np.size(test_matrix, 0))</span> <span class="hljs-comment"># X 中每一行同 β进行计算，获得预测的价格</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(np.size(test_matrix, <span class="hljs-number">0</span>)):     estimate[i] = np.dot(beta, test_matrix[i]) <span class="hljs-comment"># print(estimate)</span> <span class="hljs-keyword">return</span> estimate</code></pre></div></li><li>绘制房价实际值和预测值的比较图<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 绘制预测值与真实值图</span> <span class="hljs-comment"># 规定字体，避免乱码</span> plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">u&#x27;SimHei&#x27;</span>] plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span> plt.plot(true_value_price, color=<span class="hljs-string">&quot;r&quot;</span>, label=<span class="hljs-string">&quot;实际价格&quot;</span>)  <span class="hljs-comment"># 颜色表示</span> plt.plot(estimate_value_price, color=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), label=<span class="hljs-string">&quot;预测价格&quot;</span>) plt.xlabel(<span class="hljs-string">&quot;测试序号&quot;</span>)  <span class="hljs-comment"># x轴命名表示</span> plt.ylabel(<span class="hljs-string">&quot;价格&quot;</span>)  <span class="hljs-comment"># y轴命名表示</span> plt.title(<span class="hljs-string">&quot;实际值与预测值折线图&quot;</span>) plt.legend()  <span class="hljs-comment"># 增加图例</span> plt.show()  <span class="hljs-comment"># 显示图片</span></code></pre></div></li></ol><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628230727.png"></p><p>分析：</p><p>上述结果仅是一次学习的结果，可见 50 组实际值与预测值之间出入较大，大部分的实际值与预测值之间存在较大的差别。</p><p>不过好在获得了想要的结果。</p><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>本次实验是机器学习中的第一次尝试，简单又不是难度。</p><p>简单在于，了解实验如何运作后，实现起来还是特别简单的，确实不需要什么数学，当然，前提是，能够看懂如何从数学转换到 python 的代码。</p><p>难度在于，“万事开头难”，以及需要看懂最小二乘法是怎么运作的。</p><p>最后，机器学习还是非常的有趣，值得一直取尝试。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/qq_39384184/article/details/112464468">数理统计：波士顿房地产业的多元线性回归分析</a><blockquote><p>用于看懂<strong>最小二乘法</strong>的使用</p><p>就是看懂如何利用<strong>最小二乘法</strong>预测房价</p></blockquote></li><li><a href="https://blog.csdn.net/qq_43299522/article/details/108704221">机器学习入门实践——线性回归模型（波士顿房价预测）</a><blockquote><p>为实验的实现提供了思路： 如何绘图、数据集来源（之前有发现下载的数据集存在问题，如读取困难或存在错值）</p></blockquote></li><li><a href="https://blog.csdn.net/xwmrqqq/article/details/115354091">Python 矩阵基本运算【numpy】</a> <blockquote><p>python 中矩阵的计算</p></blockquote></li><li><a href="https://blog.csdn.net/windyhigh/article/details/105374996">Python实现最小二乘法的详细步骤</a> <blockquote><p>最小二乘法的使用？</p></blockquote></li></ul><h3 id="实验完整代码"><a href="#实验完整代码" class="headerlink" title="实验完整代码"></a>实验完整代码</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<span class="hljs-comment"># 数据集下载地址：https://www.kaggle.com/datasets/altavish/boston-housing-dataset?resource=download</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_boston_house_data</span>():    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    从包中加载波士顿房价数据集</span><span class="hljs-string">    （本不知道有这种包，但是发现下载的数据集在操作上都存在一些问题，因而找到这种方法）</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 加载波士顿房价数据集信息</span>    boston = datasets.load_boston()    <span class="hljs-comment"># 将房价信息转成dataFrame格式</span>    df_boston_house_data = pd.DataFrame(boston.data, columns=boston.feature_names)    df_boston_house_data[<span class="hljs-string">&#x27;PRICE&#x27;</span>] = boston.target    <span class="hljs-comment"># 查看数据是否存在空值，从结果来看数据不存在空值。</span>    <span class="hljs-comment"># print(df_boston_house_data.isnull().sum())</span>    <span class="hljs-comment"># 查看数据大小</span>    <span class="hljs-comment"># print(df_boston_house_data.shape)</span>    <span class="hljs-comment"># 显示数据前5行</span>    <span class="hljs-comment"># print(df_boston_house_data.head())</span>    <span class="hljs-comment"># 将数据集写入csv文件</span>    df_boston_house_data.to_csv(<span class="hljs-string">&quot;boston_housing_data.csv&quot;</span>, index=<span class="hljs-literal">False</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)    <span class="hljs-comment"># return df_boston_house_data</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data_describe</span>(<span class="hljs-params">df</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"></span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 查看数据的描述信息，在描述信息里可以看到每个特征的均值，最大值，最小值等信息</span>    df.describe()<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">file_path</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    从文件路径中读取数据集</span><span class="hljs-string">    :param file_path: 文件路径</span><span class="hljs-string">    :return: 返回一个 dataFrame</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> pd.read_csv(file_path, sep=<span class="hljs-string">&#x27;,&#x27;</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_training_data</span>(<span class="hljs-params">df, num</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    从 df 中获得训练集</span><span class="hljs-string">    :param num:</span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 取测试集的前450项</span>    df_training = df.head(num)    <span class="hljs-comment"># print(df_training)</span>    <span class="hljs-keyword">return</span> df_training<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_test_data</span>(<span class="hljs-params">df, num</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    从 df 中获取测试集</span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :param num:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 取数据集的后50项</span>    df_test = df.tail(num)    <span class="hljs-comment"># print(df_test)</span>    <span class="hljs-keyword">return</span> df_test<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_last_column</span>(<span class="hljs-params">df</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    获取df最后一列的数据</span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># print(df.iloc[:, -1])</span>    <span class="hljs-keyword">return</span> df.iloc[:, -<span class="hljs-number">1</span>]<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_not_last_column</span>(<span class="hljs-params">df</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    获取df的除最后一列的所有数据</span><span class="hljs-string">    :param df:</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># print(len(df))</span>    <span class="hljs-comment"># print(df.iloc[:, :(df.shape[1] - 1)])</span>    <span class="hljs-keyword">return</span> df.iloc[:, :(df.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)]<span class="hljs-keyword">def</span> <span class="hljs-title function_">dataframe_to_matrix</span>(<span class="hljs-params">df</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    将df转换为多维矩阵</span><span class="hljs-string">    其实就是转为 numpy 数组</span><span class="hljs-string">    :param df: 需要转换的 df</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> df.to_numpy()<span class="hljs-keyword">def</span> <span class="hljs-title function_">model_calculation</span>(<span class="hljs-params">df_x, df_y</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    计算模型</span><span class="hljs-string">    :param df_x: 训练集的前13列</span><span class="hljs-string">    :param df_y: 训练集的第14列</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 定义大小为 450 的全1数组，用于在 X 矩阵前插入一列全 1 的数</span>    one_matrix = np.full(<span class="hljs-built_in">len</span>(df_x), <span class="hljs-number">1</span>, dtype=<span class="hljs-built_in">int</span>)    <span class="hljs-comment"># X 第一列插入 一列 1，获得 X 矩阵</span>    x_matrix = np.insert(dataframe_to_matrix(df_x), <span class="hljs-number">0</span>, values=one_matrix, axis=<span class="hljs-number">1</span>)    <span class="hljs-comment"># y 矩阵</span>    y_matrix = dataframe_to_matrix(df_y)    <span class="hljs-comment"># X，y 通过计算获得 β 参数</span>    beta = np.dot(np.linalg.inv(np.dot(x_matrix.T, x_matrix)), np.dot(x_matrix.T, y_matrix))    <span class="hljs-comment"># print(beta)</span>    <span class="hljs-keyword">return</span> beta<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_estimate</span>(<span class="hljs-params">beta, df_test</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string"></span><span class="hljs-string">    :param beta: β的矩阵</span><span class="hljs-string">    :param df_test: 测试集</span><span class="hljs-string">    :return: 返回预测价格的矩阵（数组）</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 先定义预测值的数组，大小等于测试样例大小，用0填充</span>    estimate = np.full(<span class="hljs-built_in">len</span>(df_test), <span class="hljs-number">0</span>, dtype=<span class="hljs-built_in">int</span>)    <span class="hljs-comment"># 定义大小为56的全1数组，用于在 X 矩阵前插入一列全 1 的数</span>    one_matrix = np.full(<span class="hljs-built_in">len</span>(df_test), <span class="hljs-number">1</span>, dtype=<span class="hljs-built_in">int</span>)    <span class="hljs-comment"># 将测试集中的前13项作为 矩阵 X 的数</span>    test_matrix = dataframe_to_matrix(get_not_last_column(df_test))    <span class="hljs-comment"># X 第一列插入 一列 1</span>    test_matrix = np.insert(test_matrix, <span class="hljs-number">0</span>, values=one_matrix, axis=<span class="hljs-number">1</span>)    <span class="hljs-comment"># print(np.size(test_matrix, 0))</span>    <span class="hljs-comment"># X 中每一行同 β进行计算，获得预测的价格</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(np.size(test_matrix, <span class="hljs-number">0</span>)):        estimate[i] = np.dot(beta, test_matrix[i])    <span class="hljs-comment"># print(estimate)</span>    <span class="hljs-keyword">return</span> estimate<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    path = <span class="hljs-string">&#x27;boston_housing_data.csv&#x27;</span>    <span class="hljs-comment"># 读取csv文件，存入 df</span>    df_housing_data = read_data(path)    <span class="hljs-comment"># 获取训练集</span>    df_training_data = get_training_data(df_housing_data, <span class="hljs-number">450</span>)    <span class="hljs-comment"># 获取测试集</span>    df_test_data = get_test_data(df_housing_data, <span class="hljs-number">56</span>)    <span class="hljs-comment"># 获取训练来的 参数</span>    beta_matrix = model_calculation(get_not_last_column(df_training_data), get_last_column(df_training_data))    <span class="hljs-comment"># 测试集与训练结果参数计算获得 预测价格</span>    estimate_value_price = get_estimate(beta_matrix, df_test_data)    <span class="hljs-comment"># 实际价格</span>    true_value_price = dataframe_to_matrix(get_last_column(df_test_data))    <span class="hljs-comment"># 绘制预测值与真实值图</span>    <span class="hljs-comment"># 规定字体，避免乱码</span>    plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">u&#x27;SimHei&#x27;</span>]    plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>    plt.plot(true_value_price, color=<span class="hljs-string">&quot;r&quot;</span>, label=<span class="hljs-string">&quot;实际价格&quot;</span>)  <span class="hljs-comment"># 颜色表示</span>    plt.plot(estimate_value_price, color=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), label=<span class="hljs-string">&quot;预测价格&quot;</span>)    plt.xlabel(<span class="hljs-string">&quot;测试序号&quot;</span>)  <span class="hljs-comment"># x轴命名表示</span>    plt.ylabel(<span class="hljs-string">&quot;价格&quot;</span>)  <span class="hljs-comment"># y轴命名表示</span>    plt.title(<span class="hljs-string">&quot;实际值与预测值折线图&quot;</span>)    plt.legend()  <span class="hljs-comment"># 增加图例</span>    plt.show()  <span class="hljs-comment"># 显示图片</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下 VS code 配置 C/C++ 环境</title>
    <link href="/vscode-env-c-new/"/>
    <url>/vscode-env-c-new/</url>
    
    <content type="html"><![CDATA[<h2 id="阅读本文后应该可以顺利的在-Windows-系统下配置好-VS-code-的-C-x2F-C-环境。"><a href="#阅读本文后应该可以顺利的在-Windows-系统下配置好-VS-code-的-C-x2F-C-环境。" class="headerlink" title="阅读本文后应该可以顺利的在 Windows 系统下配置好 VS code 的 C&#x2F;C++ 环境。"></a>阅读本文后应该可以顺利的在 Windows 系统下配置好 VS code 的 C&#x2F;C++ 环境。</h2><p>若是继续快速配置环境，可直接到 <strong><a href="#%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">可直接使用的配置文件</a></strong> 处复制代码到对应文件，然后即可使用。</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>默认已经安装好 <code>VS code</code> 和 Windows 下的 <code>C/C++</code> 编译器 —— <code>MinGW</code>。</p><p>若是未能安装，那就自行安装吧。<del>（自己找教程去）</del></p><p>(&#96;ヮ´ ) 开摆！</p><p>安装好了的话，那就开整。</p><p>ᕕ( ᐛ )ᕗ</p><h3 id="所需插件"><a href="#所需插件" class="headerlink" title="所需插件"></a>所需插件</h3><p>配置环境只需要两个插件：</p><ul><li><code>C/C++</code> : 让 <code>VS code</code> 支持 <code>C/C++</code> 语法和编译调试</li><li><code>C/C++ Extension Pack</code> : 暂时不知道</li></ul><h3 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h3><p>配置好 <code>C/C++</code> 环境大致也就需要几个步骤：</p><h4 id="使用-VS-code-打开一个文件夹作为工作路径"><a href="#使用-VS-code-打开一个文件夹作为工作路径" class="headerlink" title="使用 VS code 打开一个文件夹作为工作路径"></a>使用 <code>VS code</code> 打开一个文件夹作为<strong>工作路径</strong></h4><p>   该文件夹可以包含子文件夹，或是创建子文件夹，配置好环境后，该文件夹会多一个 <code>.vscode</code>，该文件夹会有几个 <code>json</code> 文件。</p><h4 id="在该文件夹目录中创建-C-C-文件，并进行编辑"><a href="#在该文件夹目录中创建-C-C-文件，并进行编辑" class="headerlink" title="在该文件夹目录中创建 C/C++ 文件，并进行编辑"></a>在该文件夹目录中创建 <code>C/C++</code> 文件，并进行编辑</h4><p>   简单的编辑一下就好，比如输出个 Hello World。</p><h4 id="首先进行配置生成任务"><a href="#首先进行配置生成任务" class="headerlink" title="首先进行配置生成任务"></a>首先进行配置生成任务</h4><p>   选择已经编辑好的 C&#x2F;C++ 文件，点击顶部菜单栏的 <code>终端(T) &gt; 配置任务</code>。</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172419.png"></p><p>   在选择 <code>C/C++: gcc.exe 生成活动文件</code>。</p><blockquote><p>因为自己使用 <code>C</code> 文件进行配置任务，因为配置任务时显示的是 <code>gcc.exe</code>。<br>若是使用 <code>C++</code> 文件进行配置任务，会显示 <code>g++.exe</code>。<br><code>gcc.exe</code> 是 <code>C</code> 的编译器<br><code>g++.exe</code> 是 <code>C++</code> 的编译器，但是也可以编译 <code>C</code><br>不过这一点没什么大问题，都可以在后续的 <code>json</code> 文件中修改</p></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172452.png"></p><p>   之后会自动生成一个 <code>tasks.json</code> 文件，位于 <code>.vacode</code> 文件夹，如图：</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172512.png"></p><p>   进入 <code>tasks.json</code>:</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172535.png"></p><p>   其中：</p><ul><li><p>type: 要自定义的任务类型<br>  可支持类型： <code>cppbuild</code>, <code>shell</code>, <code>process</code>.</p></li><li><p>label: 任务名称。即是你将在任务列表中看到的值（就是上上上图中可见的：C&#x2F;C++：gcc.exe 生成活动文件）；你可以给它取任何你喜欢的名字。</p><blockquote><p>该值还和后续调试任务有关</p></blockquote></li><li><p>command: 执行编译器或编译脚本的路径。</p></li><li><p>args: 其他要传给编译器或者编译脚本的参数。</p></li><li><p><del>options：其他命令选项。</del></p><ul><li><del>cwd: 已执行程序或脚本的当前工作目录。如果省略，则使用当前代码的工作区根。</del></li></ul></li><li><p>problemMatcher: 要使用的问题匹配程序。可以是一个字符串或一个问题匹配程序定义，也可以是一个字符串数组和多个问题匹配程序。</p></li><li><p>group: build: 将任务标记为可通过“运行生成任务”命令访问的生成任务。</p></li><li><p>detail: 任务的其他详细信息。</p></li></ul><p>   <code>tasks.json</code>:<br>   <div class="code-wrapper"><pre><code class="hljs json">  <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppbuild&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/MinGW/bin/gcc.exe&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 彩色警告</span><span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span>                         <span class="hljs-comment">// 编译器编译时，产生调试信息</span><span class="hljs-string">&quot;$&#123;file&#125;&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-comment">// 当前文件名(含有文件路径)</span><span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span>                         <span class="hljs-comment">// 编译时输出的位置</span><span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>                                         <span class="hljs-comment">// 编译输出的可执行文件</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;$gcc&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;detail&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;编译器: C:/MinGW/bin/gcc.exe&quot;</span>   <span class="hljs-punctuation">&#125;</span>   <span class="hljs-punctuation">]</span>  <span class="hljs-punctuation">&#125;</span></code></pre></div></p><p>   然后点击 <code>终端(T) &gt; 运行生成任务</code>，如图：</p><blockquote><p>当然可以使用快捷键 <code>Shift + Ctrl + B</code>，快速 <code>运行生成任务</code>。</p></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172556.png"></p><p>   此时，VS code 下部的终端就会显示 <code>Executing task</code>， 即开始编译 C 文件并获得 exe 文件。</p><blockquote><p>从图中可见，运行的任务将 tasks.json 中的部分内容显示出来。<br>如：</p><ul><li>label</li><li>编译的指令<blockquote><p>成功执行指令后，会显示<code>生成已成功完成</code>。<br>未能成功执行时，则会显示<code>错误信息</code>。</p></blockquote></li></ul></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172612.png"></p><p>   成功之后，在文件夹中会多出对应的 exe 文件，如图：</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172629.png"></p><p>   强调一下，将上述任务完成后，我们只是利用 tasks.json 配置文件将 C 文件编译成了可执行的 exe 文件后续没有执行 该 exe 文件。想要查看运行结果的话：有两种办法：</p><ul><li>在 VS code 的终端中输入相应的指令以执行文件</li><li>到对应的文件夹中找到该 exe 文件，直接执行。</li></ul><p>   若是需要对代码进行调试，就需要配置接下来的 <code>launch.json</code> 文件。</p><h4 id="其次进行配置调试任务"><a href="#其次进行配置调试任务" class="headerlink" title="其次进行配置调试任务"></a>其次进行配置调试任务</h4><p>   点击 <code>运行(R) &gt; 添加配置</code>，如图:</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172731.png"></p><p>   再次点击图中选项</p><blockquote><p>由于不明原因，我这点击该选项后，直接生成了 launch.json 文件，但是是空的，和其他教程不一样，不过问题不大，就是配置复杂了一点。<br>↙(&#96;ヮ´ )↗ 开摆！</p></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172748.png"><br>   生成 launch.json 文件。<br>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172803.png"></p><p>   空的？没事，点击右边的 <code>添加配置</code>，选择 <code>C/C++: (gdb) 启动</code>。</p><blockquote><p>之所以选择该选项，是在我尝试了各选项的配置后做出的决定。<br>原因吗：</p><ul><li>功能刚好，基本满足要求</li><li>没有复杂 <del>（可能无用的）</del> 的配置选项</li></ul></blockquote><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172825.png"></p><p>   然后生成的配置文件大致如图所示，不过还不能直接用，还需要修改其中部分字段。<br>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172846.png"></p><p>   各字段的作用：</p><ul><li><code>name</code>: 配置名称，用于显示在启动配置的下拉菜单中。</li><li><code>type</code>: 配置类型。</li><li><code>request</code>: 请求配置类型。可是 <code>启动</code> 或 <code>附加</code>，对应 <code>launch</code> 和 <code>attach</code>。</li><li><code>program</code>: 程序可执行的完整路径。</li><li><code>args</code>: 传递给程序的命令行参数。</li><li><code>stopAtEntry</code>: 可选参数。如果是为 <code>true</code>，则调试程序就会在目标的入口点处停止。如果传递了 <code>processId</code>，则不起任何作用。</li><li><code>cwd</code>: 目标的工作目录。</li><li><code>environment</code>: 要添加到程序环境的环境变量。</li><li><code>externalConsole</code>: 如果为 <code>true</code>，则为调试对象启动控制台；为 <code>false</code>，则会在 <code>linux</code> 和 <code>Windows</code> 上显示在集成控制台中。<blockquote><p>意思就是：<br><code>true</code>: 额外开启一个控制台来显示结果。<br><code>false</code>: 直接在 VS code 的集成终端显示结果。 </p></blockquote></li><li><code>MIMode</code>: 指示 <code>MIDebugEngine</code> 要连接到的控制台调试程序。允许的值，<code>gdb</code>、<code>lldb</code>。</li><li><code>miDubuggerPath</code>: <code>MI</code> 调试程序（如 <code>gdb</code>）的路径。如若未指定（如 <code>gdb.exe</code>），将首先在路径中搜索调试程序。</li><li><code>setupCommands</code>: 为了安装基础调试程序而执行一个或多个 <code>GDB/LLDB</code> 命令。<ul><li><code>description</code>: 此命令的可选说明。</li><li><code>text</code>: 要执行的调试命令。</li><li><code>ignoreFailures</code>: 如果为 <code>true</code>，则会忽略该命令执行失败。默认值：<code>false</code>。</li></ul></li></ul><p>   对 <code>program</code>、<code>miDebuggerPath</code>、<code>externalConsole</code> 等字段进行修改后。<br>   可得正常使用的 <code>launch.json</code>:</p><blockquote><p>在该文件中，加了一新的字段 <code>preLaunchTask</code>，用于调试时从新生成 exe 文件，并根据新的 exe 文件进行调试。<br>否则，在对代码进行修改后，直接使用调试功能，你会发现，执行的是之前的程序，而非修改后的程序。</p><p>preLaunchTask: 调试会话开始前要运行的任务。</p></blockquote>   <div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span> <span class="hljs-comment">// 悬停以查看现有属性的描述。</span> <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span> <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>     <span class="hljs-punctuation">&#123;</span>         <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(gdb) 启动&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 在 launch 之前的任务名，</span>                                                        <span class="hljs-comment">// 即 在launch 之前先执行 tasks.json 的任务</span>                                                        <span class="hljs-comment">// 用于调试时从新生成 exe 文件，并根据新的 exe 文件进行调试</span>                                                        <span class="hljs-comment">// 因而该字段内容需和 tasks.json 中的 label 一样，如此才能正确的先生成再调试</span>         <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/MinGW/bin/gdb.exe&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>               <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>               <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>               <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span>  <span class="hljs-string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>                <span class="hljs-punctuation">&#125;</span>            <span class="hljs-punctuation">]</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>   此时会到 C 文件，就可以点击 <code>运行(R) &gt; 启动调试</code> 来调试程序，快捷键：<code>F5</code>，或是 <code>运行(R) &gt; 以非调试模式运行</code> 来运行程序（不调试），快捷键：<code>Ctrl + F5</code>。结果如图：</p><p>   <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628172909.png"></p><p>至此，Windows 系统下 VS code 的 C&#x2F;C++ 环境算是配置完成了。</p><p>好耶！</p><p>ᕕ( ᐛ )ᕗ</p><h3 id="进阶环境配置"><a href="#进阶环境配置" class="headerlink" title="进阶环境配置"></a>进阶环境配置</h3><p>我所谓的进阶配置，主要指的是，对 <code>tasks.json</code> 中使用更多的变量参数。</p><h4 id="预定义变量-Predefined-variables"><a href="#预定义变量-Predefined-variables" class="headerlink" title="预定义变量 Predefined variables"></a>预定义变量 Predefined variables</h4><p>支持以下预定义变量：</p><ul><li><code>$&#123;workspaceFolder&#125;</code> - 在 <code>VS Code</code> 中打开的文件夹的路径</li><li><code>$&#123;workspaceFolderBasename&#125;</code> - 在 <code>VS Code</code> 中打开的文件夹的名称，不带任何斜线 (&#x2F;)</li><li><code>$&#123;file&#125;</code> - 当前打开的文件</li><li><code>$&#123;fileWorkspaceFolder&#125;</code> - 当前打开文件的工作区文件夹</li><li><code>$&#123;relativeFile&#125;</code> - 当前打开的相对于 <code>workspaceFolder</code> 的文件</li><li><code>$&#123;relativeFileDirname&#125;</code> - 当前打开文件相对于 <code>workspaceFolder</code> 的目录名</li><li><code>$&#123;fileBasename&#125;</code> - 当前打开文件的基本名称</li><li><code>$&#123;fileBasenameNoExtension&#125;</code> - 当前打开的文件的基本名称，没有文件扩展名</li><li><code>$&#123;fileDirname&#125;</code> - 当前打开文件的目录名</li><li><code>$&#123;fileExtname&#125;</code> - 当前打开文件的扩展名</li><li><code>$&#123;cwd&#125;</code> - 启动 <code>VS Code</code> 时任务运行器的当前工作目录</li><li><code>$&#123;lineNumber&#125;</code> - 活动文件中当前选定的行号</li><li><code>$&#123;selectedText&#125;</code> - 活动文件中当前选定的文本</li><li><code>$&#123;execPath&#125;</code> - 正在运行的 <code>VS Code</code> 可执行文件的路径</li><li><code>$&#123;defaultBuildTask&#125;</code> - 默认构建任务的名称</li><li><code>$&#123;pathSeparator&#125;</code> - 操作系统用来分隔文件路径中的组件的字符</li></ul><h5 id="预定义变量示例-Predefined-variables-examples"><a href="#预定义变量示例-Predefined-variables-examples" class="headerlink" title="预定义变量示例 Predefined variables examples"></a>预定义变量示例 Predefined variables examples</h5><p>假设您有以下要求：</p><ol><li>位于 <code>/home/your-username/your-project/folder/file.ext</code> 的文件在您的编辑器中打开；</li><li>目录 <code>/home/your-username/your-project</code> 作为您的根工作区打开。</li></ol><p>因此，每个变量都将具有以下值：</p><ul><li><code>$&#123;workspaceFolder&#125;</code> - <code>/home/your-username/your-project</code></li><li><code>$&#123;workspaceFolderBasename&#125;</code> - <code>你的项目</code></li><li><code>$&#123;file&#125;</code> - <code>/home/your-username/your-project/folder/file.ext</code></li><li><code>$&#123;fileWorkspaceFolder&#125;</code> - <code>/home/your-username/your-project</code></li><li><code>$&#123;relativeFile&#125;</code> - <code>folder/file.ext</code></li><li><code>$&#123;relativeFileDirname&#125;</code> - <code>folder</code></li><li><code>$&#123;fileBasename&#125; - file.ext</code></li><li><code>$&#123;fileBasenameNoExtension&#125;</code> - <code>file</code></li><li><code>$&#123;fileDirname&#125;</code> - <code>/home/your-username/your-project/folder</code></li><li><code>$&#123;fileExtname&#125;</code> - <code>.ext</code></li><li><code>$&#123;lineNumber&#125;</code> - 光标的行号</li><li><code>$&#123;selectedText&#125;</code> - 在代码编辑器中选择的文本</li><li><code>$&#123;execPath&#125;</code> - Code.exe 的位置</li><li><code>$&#123;pathSeparator&#125;</code> - <code>/</code> 在 macOS 或 linux 上，<code>\</code> 在 Windows 上</li></ul><blockquote><p>Tip:<br>在 tasks.json 和 launch.json 的字符串值中使用 IntelliSense 以获取预定义变量的完整列表</p></blockquote><h5 id="每个工作区文件夹范围内的变量-Variables-scoped-per-workspace-folder"><a href="#每个工作区文件夹范围内的变量-Variables-scoped-per-workspace-folder" class="headerlink" title="每个工作区文件夹范围内的变量 Variables scoped per workspace folder"></a>每个工作区文件夹范围内的变量 Variables scoped per workspace folder</h5><p>通过将根文件夹的名称附加到变量（用冒号分隔），可以访问工作区的同级根文件夹。 如果没有根文件夹名称，则该变量的作用域为使用它的同一文件夹。</p><p>例如，在具有文件夹 <code>Server</code> 和 <code>Client</code> 的多根工作区中，<code>$&#123;workspaceFolder:Client</code>} 指的是 <code>Client</code> 根的路径。</p><h4 id="环境变量-Environment-variables"><a href="#环境变量-Environment-variables" class="headerlink" title="环境变量 Environment variables"></a>环境变量 Environment variables</h4><p>您还可以通过 <code>$&#123;env:Name&#125;</code> </p><p>语法（例如，<code>$&#123;env:USERNAME&#125;</code>）引用环境变量。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Launch Program&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/app.js&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;$&#123;env:USERNAME&#125;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h3 id="可直接使用的配置文件"><a href="#可直接使用的配置文件" class="headerlink" title="可直接使用的配置文件"></a>可直接使用的配置文件</h3><blockquote><p>PS:<br>该配置文件暂时仅是支持单个文件的编译<br>多个文件的编译请详细阅读本篇文章</p></blockquote><p>简要介绍一下两个文件表示的工作流程：</p><ul><li><code>tasks.json</code> 是将 C&#x2F;C++ 文件编译成 exe 文件，其路径与 C&#x2F;C++ 文件相同，即在同一文件夹</li><li><code>launch.json</code> 会先将文件编译成 exe 可执行文件，然后再进行调试</li></ul><p>所以，使用流程：</p><ul><li>在工作文件夹下创建 <code>.vscode</code> 文件夹，</li><li>再在 <code>.vscide</code> 下创建俩文件，并将下述代码复制进去<ul><li><code>tasks.json</code></li><li><code>launch.json</code></li></ul></li><li>按 <code>F5</code> 进行调试</li><li>按 <code>Ctrl + F5</code> 非调试运行</li></ul><p><code>tasks.json</code>:</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppbuild&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/MinGW/bin/g++.exe&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 编译器路径</span>                                            <span class="hljs-comment">// 需要自行修改</span>                     <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span>                         <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span>                         <span class="hljs-comment">// 编译时输出的位置</span><span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>                                          <span class="hljs-comment">// 编译输出的可执行文件</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;$gcc&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;detail&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;编译器: C:/MinGW/bin/g++.exe&quot;</span>   <span class="hljs-punctuation">&#125;</span>   <span class="hljs-punctuation">]</span>   <span class="hljs-punctuation">&#125;</span></code></pre></div><p><code>launch.json</code>:</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(gdb) 启动&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe 生成活动文件&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 在 launch 之前的任务名，</span>                                                           <span class="hljs-comment">// 即 在launch 之前先执行 tasks.json 的任务</span>                                                           <span class="hljs-comment">// 用于调试时从新生成 exe 文件，并根据新的 exe 文件进行调试</span>                                                           <span class="hljs-comment">// 因而该字段内容需和 tasks.json 中的 label 一样，如此才能正确的先生成再调试</span>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/MinGW/bin/gdb.exe&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 调试器的路径</span>                                                      <span class="hljs-comment">// 需要自行修改</span>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                  <span class="hljs-punctuation">&#123;</span>                     <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span>                     <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span>                     <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>                  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-punctuation">&#123;</span>                     <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span>  <span class="hljs-string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="hljs-punctuation">,</span>                     <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span>                     <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>                   <span class="hljs-punctuation">&#125;</span>               <span class="hljs-punctuation">]</span>           <span class="hljs-punctuation">&#125;</span>       <span class="hljs-punctuation">]</span>   <span class="hljs-punctuation">&#125;</span></code></pre></div><p>ᕕ( ᐛ )ᕗ</p><p>现在你就可以畅想 vscode 的 C 语言编程了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://code.visualstudio.com/docs/cpp/config-mingw#_build-helloworldcpp">Visual Studio Code 官方文档 | GCC on Windows</a></li><li><a href="https://code.visualstudio.com/docs/editor/variables-reference">Visual Studio Code 官方文档 | Variables Reference</a></li><li><a href="https://blog.51cto.com/u_14202100/5188327">【开发环境】Ubuntu 中使用 VSCode 开发 C&#x2F;C++ ⑤ ( tasks.json 中的 args 数组配置分析 | 编译并执行 C++ 程序 )</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VS code</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【水博客】VS code Markdown 导出 PDF 时，数学公式未能正确导出</title>
    <link href="/vscode-markdown-pdf-math-latex-error/"/>
    <url>/vscode-markdown-pdf-math-latex-error/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>本次出现的是问题是在写作业时发现的。</p><p>虽然已经用 <code>MarkDown</code> 很久了，也时常将 MD 文件导出成 PDF，但是之前使用的都是实时渲染的软件，如 <code>Typora</code> 等，来完成上述的工作，所以就没有出现本文博客需要解决的问题。</p><p>后续由于 <code>Typora</code> 收费 <del>（当然你还可以去官网找 <code>1.0</code> 版本之前的版本，是不收费）</del>，以及其导出的 PDF 并不是很合我的审美<del>（颜狗去死吧）</del>，，我就放弃使用 <code>Typora</code>，经过几天的查找后，还是发现 <code>VS code</code> + 插件导出的 PDF 最好看，也非常符合我的审美。所以就开始使用 VS code 导出 PDF。</p><p>每次都是使用实时渲染的软件写好文档，然后保存 MD 文件，再用 <code>VS code</code> 打开 + 导出，就很棒。</p><p>但是今天就翻车了，因为在 MD 中使用了<strong>数学公式</strong>，再使用相同的方法导出时，就出了问题 —— 数学公式未能正确导出，还是 MD 语法的表示形式。如图：</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628173919.png"></p><p>就挺懵逼的。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>然后就求助于万能的搜索引擎。开始查找解决办法。</p><p>先讲述一个失败的方法，不不不，也不是失败的方法，就是导出来的文件不符合我的审美，我就直接拒绝了它。</p><h3 id="方法一（不喜欢）"><a href="#方法一（不喜欢）" class="headerlink" title="方法一（不喜欢）"></a>方法一（不喜欢）</h3><ul><li><p>安装两个插件：</p><ul><li><code>Markdown Preview Enhance</code>：预览插件</li><li><code>Markdown + Math</code>：支持数学公式插件</li></ul></li><li><p>然后使用上述插件预览</p></li><li><p>预览页面鼠标右键，选择导出为 html 文件</p></li><li><p>浏览器打开 html 文件，右键选择打印</p></li></ul><p>问题是可以解决，但是过程复杂了，而且排版和界面不好看呀。</p><p>( ᑭ&#96;д´)ᓀ))д´)ᑫ</p><h3 id="方法二（完美）"><a href="#方法二（完美）" class="headerlink" title="方法二（完美）"></a>方法二（完美）</h3><p>所以就去寻找另外的方法。</p><p>ᕕ( ᐛ )ᕗ</p><p>还是需要两个插件哈，不过都是之前用着的插件，用于 VS code 使用 <code>Markdown</code>。</p><ul><li><p><code>Markdown All in One</code></p><p>该插件提供了一些 <code>Markdown</code> 书写过程中非常便捷性的一些操作，同时支持了 <code>latex</code> 公式，能够让你的 <code>VS code markdown Preview</code> 识别你所书写的公式。</p></li><li><p><code>Markdown PDF</code></p><p> 该插件提供了将 <code>Markdown</code> 文件输出为可预览的不同格式文件，包括 <code>html</code>， <code>pdf</code> 等。</p><p> <img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628173942.png"></p></li></ul><p>光安装两插件还不足及解决问题，接下来就需要给加点小动作了。</p><p>ᕕ( ᐛ )ᕗ</p><p>找到 <code>Markdown PDF</code> 插件中的一个文件 —— <code>template.html</code>。</p><p>文件路径：<code>C://Users/&lt;username&gt;/.vscode/extensions/yzane.markdown-pdf-1.4.1/template/template.html</code></p><blockquote><p>实在找不到可以使用 <code>everything</code> 搜索一下。</p><ul><li><a href="https://www.voidtools.com/zh-cn/">everything</a></li></ul></blockquote><p>然后使用编辑器，如 <code>VS code</code> 打开该文件，在如图位置加入两行代码。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="language-javascript"> <span class="hljs-title class_">MathJax</span>.<span class="hljs-property">Hub</span>.<span class="hljs-title class_">Config</span>(&#123; <span class="hljs-attr">tex2jax</span>: &#123;<span class="hljs-attr">inlineMath</span>: [[<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>]]&#125;, <span class="hljs-attr">messageStyle</span>: <span class="hljs-string">&quot;none&quot;</span> &#125;);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628174007.png"></p><p>最后再重新导出 PDF 就可以啦。</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628174029.png"></p><p>可见问题完美解决。</p><p>好耶。又水了一篇。</p><p>ᕕ( ᐛ )ᕗ</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>法一：<a href="https://blog.csdn.net/weijifen000/article/details/84257434">vscode下markdown转PDF</a></li><li>法二：<a href="https://blog.csdn.net/qq_18506419/article/details/103461825">VScode中Markdown PDF无法正确输出包含公式的pdf解决方案</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>水博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VS code</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【水博客】解决 Windows Powershell 中 SSH 远程连接失败问题</title>
    <link href="/cannot-ssh-connect-with-ps/"/>
    <url>/cannot-ssh-connect-with-ps/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>终端出现：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225106.png"></p><blockquote><p>上图使用的是他人的问题图片，自己这边忘记截图了。</p></blockquote><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</p><p>就是：</p><p>警告：远程主机标识已更改！</p><p>此报错是由于远程的主机的公钥发生了变化导致的。 </p><p>ssh 服务是通过公钥和私钥来进行连接的，它会把每个曾经访问过计算机或服务器的公钥（public key），记录在 <code>~/.ssh/known_hosts</code> 中，当下次访问曾经访问过的计算机或服务器时，ssh 就会核对公钥，如果和上次记录的不同，<code>OpenSSH</code> 会发出警告。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>使用命令清楚所连接的 IP：</p><div class="code-wrapper"><pre><code class="hljs shell">ssh-keygen -R xx.xx.xx.xx<span class="hljs-meta prompt_"># </span><span class="language-bash">xx.xx.xx.xx 是需要使用 ssh 连接的 ip</span></code></pre></div><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225125.png"></p><p>然后重新连接：</p><div class="code-wrapper"><pre><code class="hljs shell">ssh name@xx.xx.xx.xx -p 22<span class="hljs-meta prompt_"># </span><span class="language-bash">name：用户名</span><span class="hljs-meta prompt_"># </span><span class="language-bash">xx.xx.xx.xx: ip</span><span class="hljs-meta prompt_"># </span><span class="language-bash">-p 22：使用端口 22</span></code></pre></div><p>这是会出现有一局：</p><p>Are you sure you want to continue connecting (yes&#x2F;no)?</p><p>输入：yes，并按回车。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628225148.png"></p><p>然后就能够成功建立远程连接，后续输入 <code>用户名</code> + <code>密码</code> 登录系统就行。</p><p>最后，在终端断开 ssh 连接而不关闭终端的方法：</p><ul><li>方法一：<code>Ctrl + D</code></li><li>方法二：输入 <code>logout</code> (部分情况下需要多次输入)</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/wangguchao/article/details/85614914">问题解决——SSH时出现WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</a></li><li><a href="https://blog.csdn.net/weixin_39366112/article/details/78175873">在终端ssh的断开方法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>水博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSH</tag>
      
      <tag>PoweerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows Terminal 使用及美化记录</title>
    <link href="/terminal-useing/"/>
    <url>/terminal-useing/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用来记录使用 Windows Terminal 一路上遇到的问题以及解决的办法。</p><p>写本文时，运行 Windows Terminal 的环境：</p><ul><li>Windows 11</li><li>自带的 Windows Terminal</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>Windows 10<br>  Windows 10 可以从系统自带的 MicroSoft Store 进行下载安装，搜索 Windows Terminal，点击安装即可。</li><li>Windows 11<br>  Windows 11 直接自带 Windows Terminal，并将其作为默认的命令行工具——无论是 PowerShell 还是 CMD，或者是用户自己后续安装的如 Git Bash 等等均会直接使用 Windows Terminal 进行打开，怎么说就，十分舒适。</li></ul><p>总所周知，Windows Terminal 是可以进行美化的，而这意味着什么？</p><p>我们可以将不忍直视的 CMD 或者 Git Bash 界面做成让我们自己赏心悦目的样子，可以极大的愉悦我们的心情。</p><h2 id="Windows-Terminal-美化"><a href="#Windows-Terminal-美化" class="headerlink" title="Windows Terminal 美化"></a>Windows Terminal 美化</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>简单的说就是，Windows Terminal 通过修改<strong>配置文件</strong>中的内容，获得不一样的视觉效果。</p><p>配置文件包含三块部分：</p><ol><li>常规</li><li>外观 —— 设置字体、窗口样式、配色方案、透明度、背景图片等</li><li>高级</li></ol><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><blockquote><p>Windows 10、早期的 Windows 11 的 Terminal 的配置文件还是分为上述的三部分<br>不过，在 22 年 4 月份的时候，Terminal 的配置文件部分就发生了一点变化。<br>首先就是界面部分变得和 Windows 11 设置一样的 UI 风格<br>其次，常规部分变成了如图所示样子：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232410.png"><br>外观 + 高级则隶属于其他设置（内容大致没有变化）。</p></blockquote><blockquote><p>本文根据当前样式进行介绍。</p></blockquote><p>该部分共有 6 个字段：</p><ul><li><p>名称：下拉列表中显示的配置文件名称。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232435.png"></p></li><li><p>命令行：在配置文件中所使用的可执行文件。</p><p> 简单说就是，需要用到的命令行的可执行文件（路径），如：</p><ul><li><code>cmd</code>：就是 <code>cmd.exe</code></li><li><code>git</code>：就是 <code>git.exe</code></li></ul><p> 等等。</p></li><li><p>启动目录：加载配置文件时启动的目录。</p><blockquote><p>用人话说就是：打开该命令行后，所在的文件路径。<br>默认值：<code>&quot;%USERPROFILE%&quot;</code>，该值是用户名的文件夹，即：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232455.png"></p></blockquote><blockquote><p>备注：<br>反斜杠需要转义。 例如，应以 <code>C:\\Users\\USERNAME\\Documents</code> 的形式输入 <code>C:\Users\USERNAME\Documents</code>。</p></blockquote></li><li><p>图标：配置文件中所使用的图标的表情符号或图像文件位置。</p><blockquote><p>这将设置在选项卡、下拉菜单、跳转列表和选项卡切换器中显示的图标。<br>由此就可以将图标设置成喜欢的样子，例如：</p></blockquote><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232521.png"></p><p>将 powershell 的图标设置成这个样子了。</p></li><li><p>选项卡标题：将配置文件名称替换为标题，以在启动时传递给外壳。</p><blockquote><p>设置后就会如图所示，标题一直是<code>cmd</code>、<code>powershell</code>。</p></blockquote><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232542.png"><br><del>似乎没有那么好看了，不过这是看情况的</del></p></li><li><p>从下拉菜单中隐藏：如果启用，配置文件将不会显示在配置文件列表中。</p><blockquote><p>这可用于<strong>隐藏</strong> <code>默认配置文件</code> 和 <code>动态生成的配置文件</code>，同时将他们保留在设置文件中。</p></blockquote><p>  <img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232556.png"></p></li></ul><p>更多关于该部分的信息，请详见 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/profile-general"><strong>Windows 终端中的常规配置文件设置</strong></a>。</p><h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>外观是咱们 Windows Terminal 美化的主战场，主要就是自定义修改<strong>字体</strong>、<strong>配色方案</strong>、<strong>背景图片</strong>、<strong>亚克力效果</strong>（透明度）等等。</p><p>共有两种修改方式：</p><ol><li>使用图形界面的设置 —— 就是进入 Windows Terminal 的设置里一点点的调整</li><li>修改配置文件（JSON文件）—— 这个会比第一种复杂不少，因为是需要自己文件中的一点点设置啦</li></ol><p>不过两者各有所长，至少配置文件可以用来保存设置好的美化方案，方便分享或是重装系统后的恢复。</p><p>通过修改上述的几点设置后，咱们的终端界面就会有很大的不同了，看起来就有那么一点点的赏心悦目。</p><p>现在从配色方案、字体、背景图片、亚克力效果进行说明。</p><p>更多关于该部分的信息，请详见 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/profile-appearance"><strong>Windows 终端中的外观配置文件设置</strong></a>。</p><blockquote><p>注意：<br>可设置选项请以所使用的 Windows Terminal 显示的为主。</p></blockquote><h4 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h4><p>配色方案就好比一个主题，有着不同的风格（颜色），可以使得咱们的 Terminal 看起来具有别样的美感，同时也可以根据个人的喜好，获取自己别样的美学享受。<del>瞎扯ing</del></p><p>但是，使用、获取一个配色方案很简单，使用、获取一个合适的配色方案就不是那么简单了。</p><blockquote><p>一个合适的配色方案需要考虑到多种因素，如背景图片、亚克力效果等等。<br>他们有机组合在一起才可以获取一个美观、清楚、清晰的美化效果。<br>不然呀，就会发现，某某地方怎么不清楚、看不到了呢？整体看着那么别扭呢？<br>不过，俺也就在这简单的说一说，具体怎么实现美观、清楚、清晰的效果，俺还不知道，后续更新去了。</p></blockquote><p>Windows Terminal 中有几个默认的配色方案可供使用：</p><ul><li><code>Campbell</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232612.png"></li><li><code>Campbell Powershell</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232636.png"></li><li><code>One Half Dark</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232650.png"></li><li><code>One Half Light</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232710.png"></li><li><code>Solarized Dark</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232727.png"></li><li><code>Solarized Light</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232742.png"></li><li><code>Tango Dark</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232757.png"></li><li><code>Tango Light</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232811.png"></li><li><code>Vintage</code><br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232826.png"></li></ul><p>如果默认的配色方案没法满足你的需求，还可以自己设置想要的配色方案哦（有时候可能会有一点点困难）。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232840.png"></p><p>选择合适的终端颜色、系统颜色，再保存，就拥有自己喜欢的配色方案了。</p><p>不过具体的效果就不知道如何了。</p><p>如果自己设置的配色方案还是没法满足自己的需要，咋办？</p><p>没事，有大佬们设计了很多很多种华丽的配色方案: <a href="https://windowsterminalthemes.dev/">Windows Terminal Themes</a></p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232855.png"></p><p>一共有几十共不同的配色方案，一种配色方案还有 <code>Dark</code>，<code>Light</code> 两种选择，共有一款会是你喜欢的，或者是适合你的。</p><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>字体，字体选择也会对终端的界面有很大的改变。</p><p>这里没有太多好说的，主要是需要使用<strong>等宽字体</strong>，不要使用中文字体，如宋体、幼圆、黑体。</p><p>这是使用了<strong>黑体</strong>的结果，就一个字 —— 丑。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232915.png"></p><p>不过 terminal 也提供了很多不错的字体，如 <code>Cascadia Code</code>、<code>Cascadia Mono</code>、<code>Consolas</code> 等等。</p><p>当然你还可以自己安装你喜欢的字体，如 <a href="https://www.jetbrains.com/zh-cn/lp/mono/">JetBrains Mono</a>。</p><blockquote><p>该字体有很多种系列，如细体、特细、细、正常、中等、半粗体、粗体、超粗体，同时还有对应的斜体。<br>怎么说，就很丰富。</p></blockquote><p>而我自己使用的字体，是 <a href="https://www.nerdfonts.com/font-downloads">Nerd Font</a> 字体系列中的 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip">Hack Nerd Font</a>。（点击后会直接下载该字体哦)</p><blockquote><p>该系列的字体会比 JetBrains 的字体好一点，因为他们有图标，可以显示某些主题的一下图标。</p></blockquote><p>可以自己找到喜欢的字体，然后安装，就可以设置该字体作为终端的字体了。</p><h4 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h4><p>背景图片可以让你的终端看起来更加的花里胡哨。</p><p>你可以选择自己想要的图片，或者是桌面壁纸。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628232959.png"></p><p>选择使用背景图片后，还可以设置图片的一些属性：</p><ul><li>背景图像拉升模式</li><li>背景图像对齐</li><li>背景图像不透明度</li></ul><p>可自行调试上述的属性。</p><blockquote><p>注意：<br>使用背景图片使用时，要注意与配色方案的协调性——就是避免背景图片的某些部分影响了文字的可读性，就如上图中，是灰色的字体，部分地方因为背景图片而看的不甚清楚。<br>当图片会影响到文字的阅读时，可能需要更换其他合适的图片，或者是调整<strong>背景图像不透明度</strong>，这一属性，使得终端看起来舒服些。</p></blockquote><h4 id="亚克力效果、透明效果"><a href="#亚克力效果、透明效果" class="headerlink" title="亚克力效果、透明效果"></a>亚克力效果、透明效果</h4><p>设置该配置文件的窗口透明度。效果如下：</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628233024.png"></p><blockquote><p>可以看见窗口下层关于 <code>Windows Terminal Themes</code> 的内容。<br>透明度也是需要适当设置的，不然也会影响文字的阅读。<br>这一点也是需要和配色方案协调起来，比如某些颜色的字更容易看清楚。<br>不过更多的是与 terminal 下层的窗口有关系，它的颜色很容易影响文字的阅读。<br>所以，最好还是合理的hi用该透明的效果。</p></blockquote><p>不过还有<strong>亚克力效果</strong>可以缓解上述问题：当启用亚克力效果时，终端会创建一个模糊的背景——应用一个半透明的纹理。</p><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628233052.png"></p><blockquote><p>如图，窗口下层依然是关于 <code>Windows Terminal Themes</code> 的内容，但是仅能隐约的看到相关内容。</p></blockquote><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>看了一下，似乎没有什么和美化有关的内容，所以就不在此叙述。</p><p>更多关于该部分的信息，请详见 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/profile-advanced"><strong>Windows 终端中的高级配置文件设置</strong></a>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>本篇文章仅仅只是介绍了 Windows Terminal 对于终端的美化，设置图片、字体、配色方案、透明度之类的。</p><p>或许你也发现，文中配图的 powershell 不太一样，这是因为我使用了 <a href="https://ohmyposh.dev/">oh my posh</a>(A prompt theme engine for any shell.)</p><p>会在下篇文章介绍 oh my posh 的使用。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/terminal/">Windows Terminal 官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Terminal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Beauty</tag>
      
      <tag>Terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【水博客】解决 Github Pages + hexo 网页无法显示图片问题</title>
    <link href="/cannot-display-pictrue/"/>
    <url>/cannot-display-pictrue/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">2022-06-28 更新：现已不使用该文章提示的方法托管博文图片，而是使用 github + picgo ~~+ coding~~，不过 coding 出了点小问题。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>md 文件中加入图片链接后，在网页上无法显示图片。  </p><!--more--><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>找到一个免费的图床——如 <a href="https://imgtu.com/">路过图床</a>。</p></li><li><p><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628224255.png"></p></li><li><p>将需要放置在 <code>MarkDown</code> 文件中的图片上传到图床中，结果如下：<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628224341.png"></p></li><li><p>选择上述合适的语句，粘贴到 <code>MarkDown</code> 文件中合适的位置（要配合使用 MD 语法哦）。<br><img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628224400.png"></p></li><li><p>解决后的效果<br> <img src="https://raw.githubusercontent.com/Muxiner/BlogImages/main/posts/20220628224424.png"></p><p> 就成功显示了。<br> 完美<del>（暂时）</del>解决问题，前提是电脑联网了或者图床没跑路。</p></li></ol><h3 id="紫薯布丁"><a href="#紫薯布丁" class="headerlink" title="紫薯布丁"></a>紫薯布丁</h3><p>不保证方法百分百解决您的问题，仅仅提供一个方案（能解决我的问题的方案），无法解决的话，请您继续百度以查看他人的方法。  </p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.dazhuanlan.com/2019/10/16/5da647c849379/">github+hexo博客无法显示图片解决办法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>水博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言 —— 链表的创建</title>
    <link href="/C-create-link/"/>
    <url>/C-create-link/</url>
    
    <content type="html"><![CDATA[<h2 id="单链表的创建"><a href="#单链表的创建" class="headerlink" title="单链表的创建"></a>单链表的创建</h2><p>编辑时间：2021-3-29</p><p>创建的方法——（有无头结点）头插法、（有无头结点）尾插法。</p><h4 id="定义链表结点"><a href="#定义链表结点" class="headerlink" title="定义链表结点"></a>定义链表结点</h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-type">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>&#125;;</code></pre></div><h4 id="有头结点"><a href="#有头结点" class="headerlink" title="有头结点"></a>有头结点</h4><h5 id="1-头插法"><a href="#1-头插法" class="headerlink" title="1.头插法"></a>1.头插法</h5><p>从一个空链表开始，重复读入数据，生成新的结点，将读入的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头结点之后，直至读入结束标志。</p><blockquote><p>链表中数据的关系：</p><p>先读取的数据离头结点越远。  链表输出数据的顺序与输入顺序相反。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//形参采用二重指针形式</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    *head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">temp</span>;</span>                                      <span class="hljs-comment">//声明指针temp，用于指向新生成的链表结点</span>    (*head)-&gt;next = <span class="hljs-literal">NULL</span>;                                       <span class="hljs-comment">//head初始化为空</span>    temp = *head;                                               <span class="hljs-comment">//temp指向尾部的结点</span>    <span class="hljs-type">int</span> n; <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = temp-&gt;next; <span class="hljs-comment">//将node-&gt;next指向链表首元结点</span>                                 <span class="hljs-comment">//插入第一个结点时，node-&gt;next = NULL</span>        temp-&gt;next = node;       <span class="hljs-comment">// head-&gt;next再指向node</span>                                 <span class="hljs-comment">//完成将node插入到头结点之后</span>    &#125;&#125;<span class="hljs-comment">//node-&gt;next = temp-&gt;next</span><span class="hljs-comment">//temp-&gt;next = node</span><span class="hljs-comment">//两句顺序不能交换，交换后会失去head后面的结点</span><span class="hljs-comment">//故而先将head之后的结点链接到node之后</span><span class="hljs-comment">//再将node链接到head-&gt;next</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//返回头结点</span><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">create</span><span class="hljs-params">()</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">head</span>;</span>    head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    head-&gt;next = <span class="hljs-literal">NULL</span>;                                         <span class="hljs-comment">//head初始化为空</span>    <span class="hljs-type">int</span> n;                                                     <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = head-&gt;next;         head-&gt;next = node;           &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h5 id="2-尾插法"><a href="#2-尾插法" class="headerlink" title="2.尾插法"></a>2.尾插法</h5><p>将新结点 插到当前单链表的表尾上。增加一个尾指针Tial， 使之指向当前单链表的表尾。</p><p>保证了输入数据的顺序与链表顺序的相同。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//形参采用二重指针形式</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    *head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">Tail</span>;</span>                                     <span class="hljs-comment">//Tial尾指针</span>    Tail = *head;    <span class="hljs-type">int</span> n;                                                     <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        Tail-&gt;next = node;<span class="hljs-comment">//新结点接在Tail后面</span>        Tail = node;      <span class="hljs-comment">//尾指针指向新结点，新结点作为链表尾部</span>    &#125;    Tail-&gt;next = <span class="hljs-literal">NULL</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//返回头结点</span><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">create</span><span class="hljs-params">()</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">head</span>;</span>    head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">Tail</span> =</span> head;    <span class="hljs-type">int</span> n;                                                     <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        Tail-&gt;next = node;<span class="hljs-comment">//新结点接在Tail后面</span>        Tail = node;      <span class="hljs-comment">//尾指针指向新结点，新结点作为链表尾部</span>    &#125;    Tail-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h4 id="无头结点"><a href="#无头结点" class="headerlink" title="无头结点"></a>无头结点</h4><h5 id="1-头插法-1"><a href="#1-头插法-1" class="headerlink" title="1.头插法"></a>1.头插法</h5><p>输入顺序与输出顺序相反</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">create_noHeadNode_HeadInsert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    <span class="hljs-comment">//头插法</span>    (*head) = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));    (*head) = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">int</span> n; <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = (*head);        (*head) = node;    &#125;&#125;</code></pre></div><h5 id="2-尾插法-1"><a href="#2-尾插法-1" class="headerlink" title="2.尾插法"></a>2.尾插法</h5><p>输入顺序与输出顺序相同</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">create_noHeadNode_TailInsert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    <span class="hljs-comment">//尾插法</span>    (*head) = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));    <span class="hljs-comment">//(*head)-&gt;next = NULL;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">tail</span> =</span> (*head);<span class="hljs-comment">//tail为尾结点</span>    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        tail-&gt;next = node;        tail = node;    &#125;    (*head) = (*head)-&gt;next;<span class="hljs-comment">//head结点没有存储上数据，故直接让其指向储有第一个数据的head-&gt;next</span>    tail-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//尾结点下一个为空</span>&#125;</code></pre></div><h4 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Students</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">//char name[20];</span>    <span class="hljs-type">int</span> age;    <span class="hljs-type">float</span> marks;&#125; Student;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">next</span>;</span>&#125;;<span class="hljs-comment">//有头结点</span><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">create</span><span class="hljs-params">()</span>;               <span class="hljs-comment">//尾插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>; <span class="hljs-comment">//头插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">printNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span>;<span class="hljs-comment">//无头结点</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode_nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>; <span class="hljs-comment">//头插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">create_nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>;     <span class="hljs-comment">//尾插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">PrintNode_Nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">HeadI</span>, *<span class="hljs-title">TailI</span>;</span>     <span class="hljs-comment">//有头结点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">noHeadI</span>, *<span class="hljs-title">noTailI</span>;</span> <span class="hljs-comment">//无头结点</span>    <span class="hljs-comment">//创建链表</span>    createNode(&amp;HeadI);    printNode(HeadI);    TailI = create();    printNode(TailI);    createNode_nohead(&amp;noHeadI);    PrintNode_Nohead(noHeadI);    create_nohead(&amp;noTailI);    PrintNode_Nohead(noTailI);    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">PrintNode_Nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span>&#123;    <span class="hljs-keyword">while</span> (head)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, head-&gt;data);        head = head-&gt;next;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;<span class="hljs-comment">//头插法</span><span class="hljs-type">void</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    *head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">temp</span>;</span>                                      <span class="hljs-comment">//声明指针temp，用于指向新生成的链表结点</span>    (*head)-&gt;next = <span class="hljs-literal">NULL</span>;                                       <span class="hljs-comment">//head初始化为空</span>    temp = *head;                                               <span class="hljs-comment">//temp指向尾部的结点</span>    <span class="hljs-type">int</span> n;                                                      <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = temp-&gt;next; <span class="hljs-comment">//将node-&gt;next指向链表头结点之后的内容</span>        temp-&gt;next = node;       <span class="hljs-comment">// head-&gt;next再指向node</span>                                 <span class="hljs-comment">//完成将node插入到头结点之后</span>    &#125;&#125;<span class="hljs-comment">//尾插法</span><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">create</span><span class="hljs-params">()</span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">head</span>;</span>    head = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">//head分配地址</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">Tail</span> =</span> head;    <span class="hljs-type">int</span> n; <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        Tail-&gt;next = node;        Tail = node;    &#125;    Tail-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> head;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">printNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span>&#123;    <span class="hljs-keyword">while</span> (head-&gt;next)    &#123;        head = head-&gt;next;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, head-&gt;data);    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">createNode_nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    <span class="hljs-comment">//头插法</span>    (*head) = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));    (*head) = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">int</span> n; <span class="hljs-comment">//链表长度</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        node-&gt;next = (*head);        (*head) = node;    &#125;    <span class="hljs-comment">//(*head)-&gt;next = NULL;</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">create_nohead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode **head)</span>&#123;    <span class="hljs-comment">//尾插法</span>    (*head) = (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));    <span class="hljs-comment">//(*head)-&gt;next = NULL;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">tail</span> =</span> (*head);    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">node</span> =</span> (<span class="hljs-keyword">struct</span> ListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node-&gt;data);        tail-&gt;next = node;        tail = node;    &#125;    (*head) = (*head)-&gt;next;    tail-&gt;next = <span class="hljs-literal">NULL</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马基期末小作文之生活的意义</title>
    <link href="/mean-of-life/"/>
    <url>/mean-of-life/</url>
    
    <content type="html"><![CDATA[<p><strong>庚子年的冬天，寂寥而悲壮，萧索而又豪迈。</strong>万家阖门闭户，息交绝游；道路不通，商旅不行，喇叭声咽，都在空城……一场突如其来的灾难改变了世界的面貌，也在潜移默化中改变着人们对于生活的认识，使得人们开始重新审视、思考生活的意义。 </p><p><strong>围炉夜话一家亲——生活的意义在于相守。</strong>你或许流连于校园，或许穿梭于职场，或许像候鸟一样，南来北往，辗转流徙，抑或疲于奔命于流水线上，为口腹计，为稻粱谋……仰事俯畜的艰辛，让我们往往忽略了身边人，世间情。疫情，让全国人民居家隔离，蜗居于方丈之室。每一个人，每一个家庭，从来没有像今天一样，关心粮食和蔬菜，关心平淡而真实的家事。无奈于离别，无奈与生死不由己，也更加懂得了珍惜。疫情像一把重锤将不少人敲醒，只要家人朋友安好，任何一种生活都不再是狗血一地，而是真情一片。</p><p><strong>明月何曾是两乡——生活的意义在于相助。</strong>人民性是马克思主义最鲜明的品格，新冠肺炎疫情防控狙击战，是一场人民战争。此时此刻，每个普通中国人都在为这场战争努力付出、默默奋斗。网格员，不顾个人安危，稽查人户，测量体温，宣讲防护知识；志愿者，二十四小时值守，帐篷，红马甲，在风雪中，俨然爱的火焰。巡逻队，宵禁夜巡，一句“早点回家”，让人顿觉暖意融融。严重的疫情犹如一场战争，需要全社会一致行动。以习近平同志为核心的党中央及时部署、有力防控，从采取最全面最严格最彻底的防控措施，到前所未有地采取大规模隔离措施，前所未有地调集全国资源开展大规模医疗救治，都体现了全社会“团结”抗疫的磅礴力量。</p><p><strong>异域风月也同天——生活的意义在于相处。</strong>“天下有大勇者，卒然临之而不惊，无故加之而不怒”，面对无预之灾，中国坚决果断，及时阻止了疫情的世界传播；面对某些国家的无端指责，从容不迫，集中精力投入到世界抗疫之中。病毒变异，全球疫情的局面更加严峻，迫切需要世界各国在大是大非面前做出选择：推进多边协调还是奉行单边主义？人类命运共同体理念给予了最好的借鉴。要团结，不要分裂，团结互助是打赢疫情防控全球战最直接、最有效的途径。生活本就是人与人，人与自然之间的相处，放下隔阂和偏见，放下自私和贪婪，去拥抱人类共同更美好的未来。</p><p><strong>全国人民，为政者，一号令，课吏职，抗疫守土；为民者，令行禁止，舍小我，明大义，公忠体国。亲友相守，邻舍相助，人物相处，我们并非孑然独行，生活的意义便在于此了吧。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Write</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Write</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS code 配置 C/C++环境 (版本过低)</title>
    <link href="/vscode-env-c-old/"/>
    <url>/vscode-env-c-old/</url>
    
    <content type="html"><![CDATA[<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>该文章过时了。<del>不不不，只是内容不够完美，被我放弃了</del></p><p>后续更新了一篇比较细致的 <code>Windows</code> 下 <code>VS code</code> 配置 <code>C/C++</code> 环境。</p><p>详见 <a href="https://muxiner.github.io/2022/4/19/muxinervscode_using_gcc_with_mingw/"></a></p><h2 id="本文暂时只是给我自己回忆配置过程的，内容仅供参考，莫较真。-x3D-x3D"><a href="#本文暂时只是给我自己回忆配置过程的，内容仅供参考，莫较真。-x3D-x3D" class="headerlink" title="本文暂时只是给我自己回忆配置过程的，内容仅供参考，莫较真。 &#x3D; &#x3D;"></a><del>本文暂时只是给我自己回忆配置过程的，内容仅供参考，莫较真。 &#x3D; &#x3D;</del></h2><p>此片博文用于记录 <code>Vs code</code> 里 <code>C\C++ 环境</code> 的配置，方便以后自己能够配好环境，而不是复制原来已经配好的。</p><p>配置环境需要准备的东西—— <code>VScode</code> 、 <code>MinGW</code> 。  </p><p><code>MinGW</code> ，是 <code>Minimalist GNUfor Windows</code> 的缩写。它是一个可自由使用和自由发布的 <code>Windows</code> 特定头文件和使用GNU工具集导入库的集合，允许你在 <code>GNU/Linux和Windows</code> 平台生成本地的 <code>Windows</code> 程序而不需要第三方C运行时（ <code>C Runtime</code> ）库。<code>MinGW</code> 是一组包含文件和端口库，其功能是允许控制台模式的程序使用微软的标准C运行时（ <code>C Runtime</code> ）库（ <code>MSVCRT.DLL</code> ）,该库在所有的 <code>NT OS</code> 上有效，在所有的 <code>Windows 95</code> 发行版以上的 <code>Windows OS</code> 有效，使用基本运行时，你可以使用 <code>GCC</code> 写控制台模式的符合美国标准化组织（ <code>ANSI</code> ）程序，可以使用微软提供的 C 运行时（ <code>C Runtime</code> ）扩展，与基本运行时相结合，就可以有充分的权利既使用 <code>CRT(C Runtime)</code> 又使用 <code>WindowsAPI</code> 功能。</p><p><code>VS code</code> 下载地址 —— <a href="https://code.visualstudio.com/">Visual Studio Code</a></p><p><code>MinGW</code> 下载地址 —— <a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">MinGW</a></p><p>安装教程暂时不写，看其他人的 —— <a href="https://blog.csdn.net/wxh0000mm/article/details/100666329">MinGW的安装教程</a>。</p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>右键 <code>我的电脑</code>选择<code>属性</code>，然后如图操作，配置环境变量。(用户变量，系统变量都操作一次,主要是系统变量)</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628004329.png"></p><p><code>C:\MinGW\bin</code> —— 是 <code>gcc.exe</code> 的路径。如图：</p><blockquote><p><strong>注意：</strong>我们需要填入环境变量的路径是我们自己安装 <code>MinGW</code> 的路径下的，含有编译器的文件夹的路径，编译器有 <code>gcc.exe</code> , <code>g++.exe</code>。上述 <code>C:\MinGW\bin</code> 只是一个例子，自己的情况请先翻找对应文件（<code>MinGW</code> 安装路径）。<br><strong>注意：</strong>仅适用于 windows 系统。</p></blockquote><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628004736.png"></p><h4 id="安装C-x2F-C-扩展"><a href="#安装C-x2F-C-扩展" class="headerlink" title="安装C&#x2F;C++扩展"></a>安装C&#x2F;C++扩展</h4><p>打开 VS code，找到如图所示：<br><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628004852.png"></p><p>扩展-输入 <code>C\C++</code> - 选择 <code>C\C++</code> - 点击 <code>install</code>, 以安装C\C++扩展。</p><p>如果想要字体变成简体中文，那么搜索 <code>chinese</code>，找到如图的扩展安装并重启VScode即可。<br><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628004922.png"></p><h4 id="配置C-x2F-C-环境"><a href="#配置C-x2F-C-环境" class="headerlink" title="配置C&#x2F;C++环境"></a>配置C&#x2F;C++环境</h4><p>用 <code>VS code</code> 打开用来放置文件的文件夹，可直接通过欢迎界面的 <code>Open folder</code> 打开，也可通过菜单栏的 <code>File--&gt;Open Folder</code> 打开。</p><p>新建一个HelloWorld.c并编写：</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628005242.png"></p><h5 id="配置编译器-我的方法"><a href="#配置编译器-我的方法" class="headerlink" title="配置编译器(我的方法)"></a>配置编译器(我的方法)</h5><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628005335.png"></p><p>如图创建 <code>.vscode</code> <code>Csource</code> 文件夹，前者用来存放环境的配置文件，后者用来存放 C 语言文件。</p><p>在 <code>.vscode</code> 中创建 <code>launch.json</code> , <code>tasks.json</code>。</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628005400.png"></p><p>复制下面代码到 <code>launch.json</code></p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe - 生成和调试活动文件&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Weexe\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-comment">// workspacefolder为.vscode所在的文件夹,将要进行调试的程序的路径</span>            <span class="hljs-comment">//这个参数要和tasks.json一样,因为调试时的exe文件我们时保存在另一个路径中</span>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\MinGW\\bin\\gdb.exe&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//gdb.exe所在路径</span>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-punctuation">&#123;</span>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>                <span class="hljs-punctuation">&#125;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe build active file&quot;</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>复制下面代码到 <code>tasks.json</code></p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-comment">// 有关 tasks.json 格式的文档，请参见</span>    <span class="hljs-comment">// https://go.microsoft.com/fwlink/?LinkId=733558</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++.exe build active file&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\MinGW\\bin\\g++.exe&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//g++.exe所在路径</span>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Weexe\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\MinGW\\bin&quot;</span>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-string">&quot;$gcc&quot;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>            <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>文件夹暂时和上图相同。然后方可正常的运行C程序。</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>编写本文时，对于 C\C++ 环境配置还不是很熟，因此上述内容或多或少存在问题，后续会更新详细教程。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VS code</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：BOMB实验</title>
    <link href="/csapp-bomb/"/>
    <url>/csapp-bomb/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h3><p>炸弹实验是<code>CSAPP</code>的第二个实验，涉及到了<code>反汇编</code>、<code>读懂汇编语言</code>、<code>Linux下GDB的使用</code>及<code>C语言</code>，其中的读懂汇编语言是重难点，完整的看懂了一个函数的汇编语言时，炸弹也迎刃而解。</p><p>每个人得到的BOMB都是不一样的，大体上是每种类型的炸弹都有不同的题目，共六个<code>PHASE</code> + 一个<code>SECRET_PHASE</code>, 也就是七个炸弹。具体内容后面再说。每个人的BOMB都不一样，但是大体就那么几个在哪排列组合，所以花时间使用BAIDU GOOGLE的话还是可以找到原题的，但是并没有什么卵用，直接抄的话。按我们老师说就是学术剽窃，就是学术作弊。当然可以借鉴一下，毕竟不认真研究一下汇编，是真的不怎么好做这BOMB实验。最好还是自己慢慢看懂汇编，翻译成原来的C语言代码，再得到密码解除炸弹，这样子的收获才是最大的。</p><p>实验的资料自己都有哦，懂得都懂。  </p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h4><ul><li>逆向工程拆除“二进制炸弹”程序  </li><li>增强对程序机器级表示、汇编语言、调试器和逆向工程等理解。  </li><li>一个“Binary Bombs”（二进制炸弹，简称炸弹）是一个Linux可执行C程序，包含phase1~phase6共6个阶段。  </li><li>炸弹运行各阶段要求输入一个字符串，若输入符合程序预期，该阶段炸弹被“拆除”，否则“爆炸” 。  </li><li>你需要拆除尽可能多的炸弹。</li></ul><h4 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h4><p>每个炸弹阶段考察机器级语言程序不同方面，难度递增  </p><ul><li>阶段1：字符串比较</li><li>阶段2：循环</li><li>阶段3：条件&#x2F;分支：含switch语句</li><li>阶段4：递归调用和栈</li><li>阶段5：指针</li><li>阶段6：链表&#x2F;指针&#x2F;结构</li><li>隐藏阶段：第4阶段之后附加特定字符串后出现</li></ul><p>好家伙，老师提供的PPT里就直接说明了，以上内容，尤其是隐藏阶段，即SECRET_PHASE，在哪出现和出现的条件。 &#x3D; &#x3D;  </p><h4 id="实验技能"><a href="#实验技能" class="headerlink" title="实验技能"></a>实验技能</h4><ul><li>拆弹装备：<ul><li>熟练使用gdb调试器和objdump；</li><li>单步跟踪调试每一阶段的机器代码；</li><li>理解汇编语言代码的行为或作用；</li><li>“推断”拆除炸弹所需的目标字符串。</li><li>在各阶段的开始代码前和引爆炸弹函数前设置断点，便于调试。</li></ul></li><li>实验语言：C语言，at&amp;t汇编语言</li><li>实验环境：32位 linux</li></ul><h4 id="实验文件说明"><a href="#实验文件说明" class="headerlink" title="实验文件说明"></a>实验文件说明</h4><ul><li>炸弹文件包：（每个人的不一样）</li><li>$tar vxf bomb_2017.tar<ul><li>bomb：   bomb的可执行程序。</li><li>bomb.c：bomb程序的main函数。</li><li>README</li></ul></li><li>bomb：是一个linux下可执行程序，需要0或1个命令行参数<ul><li>不带参数运行，输出欢迎信息后，期待你按行输入                拆弹字符串，错误炸弹引爆退出，正确提示进入下一关。</li><li>带参数运行，从拆弹者的密码文件中读取用户密码</li></ul></li><li>bomb.c：bomb主程序，帮助拆弹者了解代码框架，没有细节</li></ul><h4 id="拆弹方式"><a href="#拆弹方式" class="headerlink" title="拆弹方式"></a>拆弹方式</h4><ul><li>方法1：$.&#x2F;bomb <ul><li>根据提示，逐阶段手工输入拆弹字符串（见演示）</li><li>较为繁琐，重复工作多</li></ul></li></ul><p><a href="https://imgtu.com/i/qveCUf"><img src="https://s1.ax1x.com/2022/04/06/qveCUf.md.png" alt="qveCUf.md.png"></a></p><ul><li>方法2：$.&#x2F;bomb ans.txt     （推荐）<ul><li>ans.txt为拆弹密码文本文件，名字可以自定义<ul><li>文本文件，每个拆弹字符串一行，回车结束，最多7行</li><li>除此之外不要包含任何其它字符</li></ul></li><li>程序会检查每一阶段的拆弹密码字符串来决定炸弹拆除成败。</li></ul></li></ul><p><a href="https://imgtu.com/i/qveSbt"><img src="https://s1.ax1x.com/2022/04/06/qveSbt.md.png" alt="qveSbt.md.png"></a></p><p>这样子是真的快！ </p><div class="code-wrapper"><pre><code class="hljs terminal">$ ./bomb ans.txt</code></pre></div><h3 id="开始拆弹"><a href="#开始拆弹" class="headerlink" title="开始拆弹"></a>开始拆弹</h3><p>首先反汇编<code>bomb</code></p><div class="code-wrapper"><pre><code class="hljs ter">$ objdump –d bomb &gt; asm.txt</code></pre></div><p>对bomb进行反汇编并将汇编代码输出到asm.txt中。  </p><p>然后查看汇编文件<code>asm.txt</code>。寻找<code>phase</code>所在的汇编代码段。 </p><h4 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h4><p>在<code>asm.txt</code>的<code>main</code>函数中找到如下语句<br>这里为<code>phase1</code>函数在<code>main()</code>函数中被调用的位置：</p><div class="code-wrapper"><pre><code class="hljs text">8048a9a:c7 04 24 01 00 00 00 movl   $0x1,(%esp)8048aa1:e8 ea fd ff ff       call   8048890 &lt;__printf_chk@plt&gt;8048aa6:c7 04 24 08 00 00 00 movl   $0x8,(%esp)8048aad:e8 7e fd ff ff       call   8048830 &lt;exit@plt&gt;8048ab2:e8 7c 06 00 00       call   8049133 &lt;initialize_bomb&gt;8048ab7:c7 04 24 cc a1 04 08 movl   $0x804a1cc,(%esp)8048abe:e8 2d fd ff ff       call   80487f0 &lt;puts@plt&gt;8048ac3:c7 04 24 08 a2 04 08 movl   $0x804a208,(%esp)8048aca:e8 21 fd ff ff       call   80487f0 &lt;puts@plt&gt;8048acf:e8 7d 07 00 00       call   8049251 &lt;read_line&gt;8048ad4:89 04 24             mov    %eax,(%esp)8048ad7:e8 b4 00 00 00       call   8048b90 &lt;phase_1&gt;                                                  //phase_1的位置，往下翻找即可8048adc:e8 6e 08 00 00       call   804934f &lt;phase_defused&gt;8048ae1:c7 04 24 34 a2 04 08 movl   $0x804a234,(%esp)</code></pre></div><p>然后再就是<code>phase_1</code>:  </p><div class="code-wrapper"><pre><code class="hljs text">08048b90 &lt;phase_1&gt;: 8048b90:55                   push   %ebp 8048b91:89 e5                mov    %esp,%ebp 8048b93:83 ec 18             sub    $0x18,%esp //开栈 8048b96:c7 44 24 04 84 a2 04 movl   $0x804a284,0x4(%esp)                                            //将0x804a284的内容存放到esp+4的位置 8048b9d:08  8048b9e:8b 45 08             mov    0x8(%ebp),%eax                                           //esp+8，从调用函数处取第一个参数放到eax寄中 8048ba1:89 04 24             mov    %eax,(%esp)                                           //传送到esp寄存器 8048ba4:e8 19 05 00 00       call   80490c2 &lt;strings_not_equal&gt;                                           //入口函数， 判断字符串是否相等（判断esp+4和esp+8的字符串是否相等） 8048ba9:85 c0                test   %eax,%eax                                           //当两个字符串相等时返回eax=0 8048bab:74 05                je     8048bb2 &lt;phase_1+0x22&gt;                                           //是否引爆炸弹的条件（eax=0跳到leave，否则引爆炸弹，因此通关的条件是eax=0） 8048bad:e8 25 06 00 00       call   80491d7 &lt;explode_bomb&gt; 8048bb2:c9                   leave   8048bb3:c3                   ret</code></pre></div><p>根据以上分析可知，程序先将输入的参数存放到<code>ebp+8</code>的位置，接着传送到<code>esp</code>中，然后函数在<code>0x804a284</code>这个地址取值，放到<code>esp+8</code>中。最后传送到<code>eax</code>进行比较，如果相等，返回<code>eax = 0</code>，跳到<code>leave</code>结束，不相等则返回<code>1</code>，同时调用引爆炸弹的函数。因此只要查看<code>0x804a284</code>这个地址的内容就能找到密码！用<code>GDB调试工具</code>进行查看：<br><a href="https://imgtu.com/i/qvZLCD"><img src="https://s1.ax1x.com/2022/04/06/qvZLCD.md.png" alt="qvZLCD.md.png"></a></p><p>还可以使用方法二：</p><div class="code-wrapper"><pre><code class="hljs mipsasm">Objdump --start-<span class="hljs-keyword">address=0x804a0fc </span>–s <span class="hljs-keyword">bomb </span>  <span class="hljs-comment">#方法2</span></code></pre></div><p>建议慎用 T T<br><a href="https://imgtu.com/i/qvZHUK"><img src="https://s1.ax1x.com/2022/04/06/qvZHUK.md.png" alt="qvZHUK.md.png"></a><br>密码是出来了，但是多了一长串的后面地址的内容。</p><p><code>phase_1</code>的密码：  </p><blockquote><p>Public speaking is very easy.  </p></blockquote><p>将其放入<code>ans.txt</code>中再<code>./bomb ans.txt</code>可得：<br><a href="https://imgtu.com/i/qvZ7E6"><img src="https://s1.ax1x.com/2022/04/06/qvZ7E6.md.png" alt="qvZ7E6.md.png"></a></p><p>一下简要介绍GBD在本次拆炸弹中的使用：</p><h5 id="GDB工具的使用"><a href="#GDB工具的使用" class="headerlink" title="GDB工具的使用"></a>GDB工具的使用</h5><p>terminal输入gdb bomb，即是调试bomb这个程序，显示如下：</p><div class="code-wrapper"><pre><code class="hljs text">b xxx   //在XX处设置断点ni      //单步执行机器指令x/2s    //查看地址中的两个字符串x/d     //查看地址中的整数</code></pre></div><div class="code-wrapper"><pre><code class="hljs text">GNU gdb (GDB) 7.2-ubuntuCopyright (C) 2010 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;i686-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;..../bomb/bomblab/src/bomb...done.gdb) b main        #在main函数的开始处设置断点   Breakpoint 1 at 0x80489a5: file bomb.c, line 45.(gdb) r                  #从gdb里运行bomb程序Starting program:./bomb/bomblab/src/bomb                               # 运行后，暂停在断点1处Breakpoint 1, main (argc=1, argv=0xbffff3f4) at bomb.c:4545    if (argc == 1) &#123; (gdb) ni                #单步执行机器指令0x080489a845    if (argc == 1) &#123;  (gdb) ni46infile = stdin;   #这里可以看到执行到哪一条C语句(gdb) ni73    input = read_line();             /* Get input                   */(gdb) ni                /*如果是命令行输入，这里输入你的拆弹字符串*/74    phase_1(input);                  /* Run the phase               */(gdb) x/2s 0x804a284       #查看地址0x804a0fc处两个字符串：0x804a284:&quot;Public speaking is very easy.&quot;0x804a2a2:&quot;%d %c %d&quot; (gdb) q                          #退出gdb               ```  #### Phase_2可知此次是关于循环的，不多BB直接上汇编：```text08048bb4 &lt;phase_2&gt;: 8048bb4:55                   push   %ebp 8048bb5:89 e5                mov    %esp,%ebp 8048bb7:56                   push   %esi 8048bb8:53                   push   %ebx                                           //esi和ebx为调用者保存寄存器，因为后面的循环用到了者两个寄存器，因此要压栈保存 8048bb9:83 ec 30             sub    $0x30,%esp                                            //esp - 48开栈 8048bbc:8d 45 e0             lea    -0x20(%ebp),%eax 8048bbf:89 44 24 04          mov    %eax,0x4(%esp)                                           //以上两句将ebp-32处的地址借助eax传给esp+4处 8048bc3:8b 45 08             mov    0x8(%ebp),%eax 8048bc6:89 04 24             mov    %eax,(%esp)                                           //以上两句将ebp+8处的地址传给esp 8048bc9:e8 33 06 00 00       call   8049201 &lt;read_six_numbers&gt;                                           //输入6个数 8048bce:83 7d e0 01          cmpl   $0x1,-0x20(%ebp)                                           //(ebp - 32)- 1 = 0 8048bd2:74 1e                je     8048bf2 &lt;phase_2+0x3e&gt;                                           //引爆炸弹的条件，不为1则引爆炸弹。因此ebp-32处要为1，从前面看，这是存放输入参数的位置 8048bd4:e8 fe 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048bd9:eb 17                jmp    8048bf2 &lt;phase_2+0x3e&gt; 8048bdb:8b 43 fc             mov    -0x4(%ebx),%eax 8048bde:01 c0                add    %eax,%eax 8048be0:39 03                cmp    %eax,(%ebx)                                           //以上三句将(ebx-4)传给eax，eax = eax*2                                            eax - ebx = 0就跳转，反之不为0，引爆炸弹 8048be2:74 05                je     8048be9 &lt;phase_2+0x35&gt; 8048be4:e8 ee 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048be9:83 c3 04             add    $0x4,%ebx                                           //ebx上移4，ebx+4 8048bec:39 f3                cmp    %esi,%ebx                                           // esi - ebx ！= 0 8048bee:75 eb                jne    8048bdb &lt;phase_2+0x27&gt; 8048bf0:eb 08                jmp    8048bfa &lt;phase_2+0x46&gt;                                           //当esi=ebx时跳出循环，反之继续循环。 8048bf2:8d 5d e4             lea    -0x1c(%ebp),%ebx                                           //ebp - 28传给ebx(调用者帧保存) 8048bf5:8d 75 f8             lea    -0x8(%ebp),%esi                                           //ebp - 8 传给esi(调用者帧保存) 8048bf8:eb e1                jmp    8048bdb &lt;phase_2+0x27&gt; 8048bfa:83 c4 30             add    $0x30,%esp 8048bfd:5b                   pop    %ebx 8048bfe:5e                   pop    %esi 8048bff:5d                   pop    %ebp 8048c00:c3                   ret</code></pre></div><p>栈图如下：<br><a href="https://imgtu.com/i/qvZd3Q"><img src="https://s1.ax1x.com/2022/04/06/qvZd3Q.png" alt="qvZd3Q.png"></a><br>分析：<br>显然是一个首项为1，公比为2的等比数列。</p><p>第二关密码：</p><blockquote><p>1 2 4 8 16 32</p></blockquote><h4 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h4><p>可知本关与switch有关，有分支，故而代码较长，解题选一种情况即可（看了才知道的）。<br>继续上汇编代码：</p><div class="code-wrapper"><pre><code class="hljs text">08048c01 &lt;phase_3&gt;: 8048c01:55                   push   %ebp 8048c02:89 e5                mov    %esp,%ebp 8048c04:83 ec 38             sub    $0x38,%esp                                           // esp-56开栈 8048c07:8d 45 f4             lea    -0xc(%ebp),%eax 8048c0a:89 44 24 10          mov    %eax,0x10(%esp)                                           //ebp-12 借助eax传给esp + 16 8048c0e:8d 45 ef             lea    -0x11(%ebp),%eax 8048c11:89 44 24 0c          mov    %eax,0xc(%esp)                                           //ebp-17借助eax传给esp+12 8048c15:8d 45 f0             lea    -0x10(%ebp),%eax 8048c18:89 44 24 08          mov    %eax,0x8(%esp)                                           //ebp-16借助eax传给esp+8 8048c1c:c7 44 24 04 a2 a2 04 movl   $0x804a2a2,0x4(%esp)                                           //将0x804a2a2的内容传给esp+8                                           //GDB查看发现是%d%c%d 8048c23:08</code></pre></div><p>0x804a2a2这个地址有点熟悉哦，感觉在哪见过——<br><a href="https://imgtu.com/i/qvZd3Q"><img src="https://s1.ax1x.com/2022/04/06/qvZd3Q.png" alt="qvZd3Q.png"></a><br>好家伙，查0x804a284的时候就出现0x804a2a2了，还是进入GDB再看看。<br><a href="https://imgtu.com/i/qvZa9g"><img src="https://s1.ax1x.com/2022/04/06/qvZa9g.png" alt="qvZa9g.png"></a><br>好家伙，确实是这样，需要我们输入<code>%d %c %d</code>,两个整数，一个字符。（所以这也是这个的原因）</p><blockquote><p>lea    -0x11(%ebp),%eax<br>mov    %eax,0xc(%esp)<br>&#x2F;&#x2F;ebp-17借助eax传给esp+12</p></blockquote><p>第二个参数只占一个一个字节。（这里之前想了好久。。。。。。）<br>继续看汇编：</p><div class="code-wrapper"><pre><code class="hljs text">8048c24:8b 45 08             mov    0x8(%ebp),%eax8048c27:89 04 24             mov    %eax,(%esp)                                          // ebp-8借助eax传给esp8048c2a:e8 31 fc ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;                                          //读入函数，将你输入的参数按指定格式读到相应的地址8048c2f:83 f8 02             cmp    $0x2,%eax                                          //eax接受ssacnf函数的返回值，说明sscanf函数的返回值是参数个数，如果大于2跳过炸弹，否则引爆炸弹。8048c32:7f 05                jg     8048c39 &lt;phase_3+0x38&gt;8048c34:e8 9e 05 00 00       call   80491d7 &lt;explode_bomb&gt;8048c39:83 7d f0 07          cmpl   $0x7,-0x10(%ebp)8048c3d:0f 87 e9 00 00 00    ja     8048d2c &lt;phase_3+0x12b&gt;                                          //以上两句说明ebp-16不能超过7，否则就引爆炸弹。8048c43:8b 45 f0             mov    -0x10(%ebp),%eax                                          //ebp-16赋给eax8048c46:ff 24 85 c0 a2 04 08 jmp    *0x804a2c0(,%eax,4)                                          //间接跳转，跳到*0x804a2c0这个地址，这是第三关的核心代码！</code></pre></div><p>详细分析：<br>ja : 无符号大于则跳转; 代表ebp-16中的内容只能小于等于7，大于等于0，再看上面的代码易知ebp-16是第一个参数，故设第一个参数为i，再往下看可知：</p><blockquote><p>i &#x3D; 0, 1, 2, 3, 4, 5, 6, 7</p></blockquote><p>所以就会有8个不同的密码！</p><blockquote><p>-0x10(%ebp),%eax &#x2F;&#x2F;ebp-16赋给eax</p></blockquote><p>即第一个参数赋给eax。</p><blockquote><p>jmp    *0x804a2c0(,%eax,4)</p></blockquote><p>用GDB查看*0x804a2c0,可知这个指针指向0x8048c4d。即使当i&#x3D;1的情况。<br>仔细一看发现后面的汇编大体相似，应该就是i取值不同时的不同情况。</p><div class="code-wrapper"><pre><code class="hljs text">8048c4d:b8 6d 00 00 00       mov    $0x6d,%eax                                          // eax = 0x6d8048c52:81 7d f4 f0 01 00 00 cmpl   $0x1f0,-0xc(%ebp)8048c59:0f 84 d7 00 00 00    je     8048d36 &lt;phase_3+0x135&gt;                                          // ebp-12 = 0x1f0 跳转，反之爆炸。8048c5f:e8 73 05 00 00       call   80491d7 &lt;explode_bomb&gt;8048c64:b8 6d 00 00 00       mov    $0x6d,%eax                                          // eax = 0x6d8048c69:e9 c8 00 00 00       jmp    8048d36 &lt;phase_3+0x135&gt;</code></pre></div><p>edp-12是第三个参数，为496</p><div class="code-wrapper"><pre><code class="hljs llvm"><span class="hljs-number">8048</span>d<span class="hljs-number">2</span><span class="hljs-keyword">c</span>:e<span class="hljs-number">8</span> a<span class="hljs-number">6</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">call</span>   <span class="hljs-number">80491</span>d<span class="hljs-number">7</span> &lt;explode_bomb&gt;<span class="hljs-number">8048</span>d<span class="hljs-number">31</span>:b<span class="hljs-number">8</span> <span class="hljs-number">77</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x77</span><span class="hljs-punctuation">,</span><span class="hljs-variable">%eax</span><span class="hljs-number">8048</span>d<span class="hljs-number">36</span>:<span class="hljs-number">3</span>a <span class="hljs-number">45</span> ef             cmp    <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">11</span>(<span class="hljs-variable">%ebp</span>)<span class="hljs-punctuation">,</span><span class="hljs-variable">%al</span>                                          // 比较ebp<span class="hljs-number">-17</span> 和 al寄存器中的值，相等结束，反之爆炸。<span class="hljs-number">8048</span>d<span class="hljs-number">39</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">8048</span>d<span class="hljs-number">40</span> &lt;phase_<span class="hljs-number">3</span><span class="hljs-number">+0</span><span class="hljs-keyword">x</span><span class="hljs-number">13</span>f&gt;<span class="hljs-number">8048</span>d<span class="hljs-number">3</span>b:e<span class="hljs-number">8</span> <span class="hljs-number">97</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       <span class="hljs-keyword">call</span>   <span class="hljs-number">80491</span>d<span class="hljs-number">7</span> &lt;explode_bomb&gt;<span class="hljs-number">8048</span>d<span class="hljs-number">40</span>:<span class="hljs-keyword">c</span><span class="hljs-number">9</span>                   leave  <span class="hljs-number">8048</span>d<span class="hljs-number">41</span>:<span class="hljs-keyword">c</span><span class="hljs-number">3</span>                   <span class="hljs-keyword">ret</span></code></pre></div><p>al寄存器是eax的低8位，举例</p><blockquote><p>mov eax 12345678h<br>mov al 78h<br>AX是EAX的低16位<br>AH是ax的高8位，而AL是ax的低8位  </p></blockquote><p>差不多这个意思。</p><blockquote><p>cmp    -0x11(%ebp),%al<br>je     8048d40 &lt;phase_3+0x13f&gt;</p></blockquote><p>就是第二个参数等于al中的内容，即上面eax的内容（eax &#x3D; 0x6d）<br>定义 char B;<br>B是第二个参数，B &#x3D; 0x6d。<br>查ASCII码表知   B &#x3D; m。<br><a href="https://imgtu.com/i/qvZYAf"><img src="https://s1.ax1x.com/2022/04/06/qvZYAf.md.png" alt="qvZYAf.md.png"></a></p><p>所以其中一个密码为<br>0 m 496</p><p>以下分析方法同上，就不做重复的分析：</p><div class="code-wrapper"><pre><code class="hljs text"> 8048c6e:b8 6f 00 00 00       mov    $0x6f,%eax 8048c73:81 7d f4 5a 01 00 00 cmpl   $0x15a,-0xc(%ebp) 8048c7a:0f 84 b6 00 00 00    je     8048d36 &lt;phase_3+0x135&gt; 8048c80:e8 52 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048c85:b8 6f 00 00 00       mov    $0x6f,%eax 8048c8a:e9 a7 00 00 00       jmp    8048d36 &lt;phase_3+0x135&gt; 8048c8f:b8 70 00 00 00       mov    $0x70,%eax 8048c94:83 7d f4 64          cmpl   $0x64,-0xc(%ebp) 8048c98:0f 84 98 00 00 00    je     8048d36 &lt;phase_3+0x135&gt; 8048c9e:e8 34 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048ca3:b8 70 00 00 00       mov    $0x70,%eax 8048ca8:e9 89 00 00 00       jmp    8048d36 &lt;phase_3+0x135&gt; 8048cad:b8 68 00 00 00       mov    $0x68,%eax 8048cb2:83 7d f4 3d          cmpl   $0x3d,-0xc(%ebp) 8048cb6:74 7e                je     8048d36 &lt;phase_3+0x135&gt; 8048cb8:e8 1a 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048cbd:b8 68 00 00 00       mov    $0x68,%eax 8048cc2:eb 72                jmp    8048d36 &lt;phase_3+0x135&gt; 8048cc4:b8 6f 00 00 00       mov    $0x6f,%eax 8048cc9:81 7d f4 02 02 00 00 cmpl   $0x202,-0xc(%ebp) 8048cd0:74 64                je     8048d36 &lt;phase_3+0x135&gt; 8048cd2:e8 00 05 00 00       call   80491d7 &lt;explode_bomb&gt; 8048cd7:b8 6f 00 00 00       mov    $0x6f,%eax 8048cdc:eb 58                jmp    8048d36 &lt;phase_3+0x135&gt; 8048cde:b8 6e 00 00 00       mov    $0x6e,%eax 8048ce3:81 7d f4 d5 00 00 00 cmpl   $0xd5,-0xc(%ebp) 8048cea:74 4a                je     8048d36 &lt;phase_3+0x135&gt; 8048cec:e8 e6 04 00 00       call   80491d7 &lt;explode_bomb&gt; 8048cf1:b8 6e 00 00 00       mov    $0x6e,%eax 8048cf6:eb 3e                jmp    8048d36 &lt;phase_3+0x135&gt; 8048cf8:b8 74 00 00 00       mov    $0x74,%eax 8048cfd:81 7d f4 97 01 00 00 cmpl   $0x197,-0xc(%ebp) 8048d04:74 30                je     8048d36 &lt;phase_3+0x135&gt; 8048d06:e8 cc 04 00 00       call   80491d7 &lt;explode_bomb&gt; 8048d0b:b8 74 00 00 00       mov    $0x74,%eax 8048d10:eb 24                jmp    8048d36 &lt;phase_3+0x135&gt;8048d12:b8 74 00 00 00       mov    $0x74,%eax8048d17:81 7d f4 9b 01 00 00 cmpl   $0x19b,-0xc(%ebp)8048d1e:74 16                je     8048d36 &lt;phase_3+0x135&gt;8048d20:e8 b2 04 00 00       call   80491d7 &lt;explode_bomb&gt;8048d25:b8 74 00 00 00       mov    $0x74,%eax8048d2a:eb 0a                jmp    8048d36 &lt;phase_3+0x135&gt;</code></pre></div><p>所以第三关密码为：<br>0 m 496<br>1 o 346<br>2 p 100<br>3 h 61<br>4 o 514<br>5 n 213<br>6 t 407<br>7 t 411<br>任选一组即可过关。  </p><h4 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h4><p>我们可知phase_4与递归的调用有关，不看不知道，一看吓一跳，递归在汇编里看着就是真的恶心啊。（主要还是自己看不明白（主要还是汇编学的不是很透彻））。<br>不多比比继续直接看代码：</p><div class="code-wrapper"><pre><code class="hljs text">08048da4 &lt;phase_4&gt;: 8048da4:55                   push   %ebp 8048da5:89 e5                mov    %esp,%ebp 8048da7:83 ec 28             sub    $0x28,%esp                                           //esp-40开栈 8048daa:8d 45 f4             lea    -0xc(%ebp),%eax 8048dad:89 44 24 0c          mov    %eax,0xc(%esp)                                           //ebp-12借助eax传给esp+12 8048db1:8d 45 f0             lea    -0x10(%ebp),%eax 8048db4:89 44 24 08          mov    %eax,0x8(%esp)                                           //ebp-16借助eax传给esp+8 8048db8:c7 44 24 04 57 a4 04 movl   $0x804a457,0x4(%esp)                                           //使用GDB查看知需要输入两个整型 %d %d 8048dbf:08  8048dc0:8b 45 08             mov    0x8(%ebp),%eax 8048dc3:89 04 24             mov    %eax,(%esp)                                           //ebp+8借助eax传给esp 8048dc6:e8 95 fa ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;                                           8048dcb:83 f8 02             cmp    $0x2,%eax                                           //判断参数个数是否为2，不为2，爆炸 8048dce:75 06                jne    8048dd6 &lt;phase_4+0x32&gt; 8048dd0:83 7d f0 0e          cmpl   $0xe,-0x10(%ebp)                                           //(ebp-16)-14 &lt;= 0 跳转，反之爆炸                                           //可知参数一是一个小于等于14的无符号型整数 8048dd4:76 05                jbe    8048ddb &lt;phase_4+0x37&gt; 8048dd6:e8 fc 03 00 00       call   80491d7 &lt;explode_bomb&gt;</code></pre></div><p>设参数一为A， 所以0 &lt;&#x3D; A &lt;&#x3D; 14  </p><div class="code-wrapper"><pre><code class="hljs text">8048ddb:c7 44 24 08 0e 00 00 movl   $0xe,0x8(%esp)                                          //exp+8 = 148048de2:00 8048de3:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp)                                          //esp+4 = 08048dea:00 8048deb:8b 45 f0             mov    -0x10(%ebp),%eax8048dee:89 04 24             mov    %eax,(%esp)                                          // ebp-16赋值给esp(参数1赋给esp)8048df1:e8 4c ff ff ff       call   8048d42 &lt;func4&gt;//进入递归</code></pre></div><p>进入递归Func4函数时传入了三个参数，即14，0，A（参数1）。<br> <div class="code-wrapper"><pre><code class="hljs text">8048df6:83 f8 06             cmp    $0x6,%eax                                          //eax是递归函数的返回值且为6，不为6，爆炸。8048df9:75 06                jne    8048e01 &lt;phase_4+0x5d&gt;8048dfb:83 7d f4 06          cmpl   $0x6,-0xc(%ebp)                                          //(ebp-12) - 6 = 0                                          // ebp-12是参数2，即参数2为6。                                          // 参数2为6时，结束，反之爆炸。8048dff:74 05                je     8048e06 &lt;phase_4+0x62&gt;8048e01:e8 d1 03 00 00       call   80491d7 &lt;explode_bomb&gt;8048e06:c9                   leave  8048e07:c3                   ret</code></pre></div><br> 分析到这里时，我们已经知道了<code>参数1</code>的范围<code>[0, 14]</code>, <code>参数2</code>为<code>6</code>。<br> 其实我们擦不多就可以结束phase4的分析了，差不多可以知道密码了。<br> 我们可以一个一个地带进去试验  即输入<code>i 6</code>,其中<code>i = 0, 1, 2, ..., 14</code>。<br> 最后我们可以得到第四关地密码：<br> <code>6 6  </code></p><p> 但是投机取巧并不好，万一有人问道——递归函数（func4）时怎么样的呢<br> 那么你就回答不上来了。  所以我们还要继续分析，知道全部熟络于心。<br> 但是下面的递归是真的难，真的花时间。  </p><p> 现在我们开始func4的分析：<br> <div class="code-wrapper"><pre><code class="hljs text">08048d42 &lt;func4&gt;: 8048d42:55                   push   %ebp 8048d43:89 e5                mov    %esp,%ebp 8048d45:56                   push   %esi 8048d46:53                   push   %ebx 8048d47:83 ec 10             sub    $0x10,%esp                                           //esp-16开栈 8048d4a:8b 55 08             mov    0x8(%ebp),%edx //ebp+8赋给edx，记为参数A 8048d4d:8b 45 0c             mov    0xc(%ebp),%eax //ebp+12赋给eax，记为参数B 8048d50:8b 5d 10             mov    0x10(%ebp),%ebx //ebp+16赋给ebx，记为参数C                                            8048d53:89 d9                mov    %ebx,%ecx //ebx赋给ecx 8048d55:29 c1                sub    %eax,%ecx //ecx=ecx-eax=C-B 8048d57:89 ce                mov    %ecx,%esi //ecx赋给esi 8048d59:c1 ee 1f             shr    $0x1f,%esi //esi逻辑右移31位 8048d5c:01 f1                add    %esi,%ecx //ecx=ecx+esi 8048d5e:d1 f9                sar    %ecx //ecx算术右移1位，就是C/2。 8048d60:01 c1                add    %eax,%ecx //ecx=ecx+eax</code></pre></div><br>上述汇编是对参数进行了算术运算。  </p><div class="code-wrapper"><pre><code class="hljs text">8048d62:39 d1                cmp    %edx,%ecx                                          //if(edx &lt;= ecx) 跳转到 8048d7d，否则顺序执行。8048d64:7e 17                jle    8048d7d &lt;func4+0x3b&gt;8048d66:83 e9 01             sub    $0x1,%ecx                                          // ecx=ecx-18048d69:89 4c 24 08          mov    %ecx,0x8(%esp)8048d6d:89 44 24 04          mov    %eax,0x4(%esp)8048d71:89 14 24             mov    %edx,(%esp)                                          //构造func4的参数8048d74:e8 c9 ff ff ff       call   8048d42 &lt;func4&gt;                                          //进入递归8048d79:01 c0                add    %eax,%eax                                          //eax=eax+eax                                          //递归返回值加倍8048d7b:eb 20                jmp    8048d9d &lt;func4+0x5b&gt;8048d7d:b8 00 00 00 00       mov    $0x0,%eax                                          //eax=08048d82:39 d1                cmp    %edx,%ecx                                          if(edx &gt;= ecx) 递归终止，否则顺序执行。8048d84:7d 17                jge    8048d9d &lt;func4+0x5b&gt;8048d86:89 5c 24 08          mov    %ebx,0x8(%esp)8048d8a:83 c1 01             add    $0x1,%ecx                                          //ecx=ecx+18048d8d:89 4c 24 04          mov    %ecx,0x4(%esp)8048d91:89 14 24             mov    %edx,(%esp)                                          //构造func4的参数8048d94:e8 a9 ff ff ff       call   8048d42 &lt;func4&gt;                                          //进入递归8048d99:8d 44 00 01          lea    0x1(%eax,%eax,1),%eax                                          //eax=eax*2+1                                          //递归返回值加倍后加一8048d9d:83 c4 10             add    $0x10,%esp8048da0:5b                   pop    %ebx8048da1:5e                   pop    %esi8048da2:5d                   pop    %ebp8048da3:c3                   ret</code></pre></div><p>最终可得C语言函数func4：  </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(<span class="hljs-type">int</span> ebx, <span class="hljs-type">int</span> eax, <span class="hljs-type">int</span> edx)</span>&#123;    <span class="hljs-type">int</span> esi = (ebx - eax) &gt;&gt; <span class="hljs-number">31</span>;    <span class="hljs-type">int</span> ecx = (ebx - eax + esi) &gt;&gt; <span class="hljs-number">1</span>;    ecx = ecx + eax;    <span class="hljs-keyword">if</span> (edx == ecx)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (edx &gt; ecx)        <span class="hljs-keyword">return</span> func4(ebx, ecx + <span class="hljs-number">1</span>, edx) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> func4(ecx - <span class="hljs-number">1</span>, eax, edx) * <span class="hljs-number">2</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">14</span>; i++)    &#123;        <span class="hljs-keyword">if</span> (func4(<span class="hljs-number">14</span>, <span class="hljs-number">0</span>, i) == <span class="hljs-number">6</span>)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);            getchar();            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    getchar();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>于是可得需要输入的第一个参数为<code>6</code>。<br>故phase_4的密码为：<br>6 6  </p><h4 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h4><div class="code-wrapper"><pre><code class="hljs text">08048e08 &lt;phase_5&gt;: 8048e08:55                   push   %ebp 8048e09:89 e5                mov    %esp,%ebp 8048e0b:83 ec 28             sub    $0x28,%esp                                       //esp-40开栈 8048e0e:8d 45 f4             lea    -0xc(%ebp),%eax 8048e11:89 44 24 0c          mov    %eax,0xc(%esp) 8048e15:8d 45 f0             lea    -0x10(%ebp),%eax 8048e18:89 44 24 08          mov    %eax,0x8(%esp)                                       //两个参数的赋值，分别为参数1，参数2，可知本关需要输入两个参数 8048e1c:c7 44 24 04 57 a4 04 movl   $0x804a457,0x4(%esp)                                       //使用GDB可知为%d %d，故需要输入两个整型参数 8048e23:08  8048e24:8b 45 08             mov    0x8(%ebp),%eax 8048e27:89 04 24             mov    %eax,(%esp) 8048e2a:e8 31 fa ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt; 8048e2f:83 f8 01             cmp    $0x1,%eax 8048e32:7f 05                jg     8048e39 &lt;phase_5+0x31&gt; 8048e34:e8 9e 03 00 00       call   80491d7 &lt;explode_bomb&gt;                                       //这一段的意思就是（前几关说过）                                       //需要输入大于一个的参数个数，否则爆炸 8048e39:8b 45 f0             mov    -0x10(%ebp),%eax                                       //参数1赋给eax 8048e3c:83 e0 0f             and    $0xf,%eax                                       //按位与操作，即eax = eax &amp; 0xf                                       //按位与后eax 必然小于等于 0x0000 000f 8048e3f:89 45 f0             mov    %eax,-0x10(%ebp)                                       //eax 赋给ebp-16 8048e42:83 f8 0f             cmp    $0xf,%eax                                       //if ((ebp-16) - 15 == 0) 爆炸，否则顺序执行。                                       //故经过按位与和比较后可知参数1小于15                                        8048e45:74 28                je     8048e6f &lt;phase_5+0x67&gt; 8048e47:b9 00 00 00 00       mov    $0x0,%ecx 8048e4c:ba 00 00 00 00       mov    $0x0,%edx 8048e51:83 c2 01             add    $0x1,%edx                                       //令ecx = 0; edx = 0;                                       // edx += 1;循环的次数 8048e54:8b 04 85 e0 a2 04 08 mov    0x804a2e0(,%eax,4),%eax                                       //使用GDB知0x804a2e0为一维数组的首地址                                       //操作为 eax = array[eax]                                       //首次的eax = 输入的参数一</code></pre></div><p>经GDB得数组为<code>array[16]=&#123;10,2,14,7,8,12,15,11,0,4,1,13,3,9,6,5&#125;</code>。</p><div class="code-wrapper"><pre><code class="hljs text">8048e5b:01 c1                add    %eax,%ecx                                      //ecx = ecx + array[eax]8048e5d:83 f8 0f             cmp    $0xf,%eax                                      //当eax!=15时继续循环，否则跳出循环。                                      //跳出循环时eax=158048e60:75 ef                jne    8048e51 &lt;phase_5+0x49&gt;8048e62:89 45 f0             mov    %eax,-0x10(%ebp)                                      //(ebp-16)=eax8048e65:83 fa 0f             cmp    $0xf,%edx                                      //当循环次数小于15次时顺序执行，否则爆炸。8048e68:75 05                jne    8048e6f &lt;phase_5+0x67&gt;8048e6a:3b 4d f4             cmp    -0xc(%ebp),%ecx                                      //if (参数2 == ecx) 结束，否则爆炸。8048e6d:74 05                je     8048e74 &lt;phase_5+0x6c&gt;8048e6f:e8 63 03 00 00       call   80491d7 &lt;explode_bomb&gt;8048e74:c9                   leave  8048e75:c3                   ret</code></pre></div><p> 分析：<br> 分析得参数2 &#x3D; 循环时数组元素的和，即sum +&#x3D; array[eax]，开始进行循环时 eax &#x3D; array[参数1]，循环时eax的取值为 0 - 14，循环结束时 eax &#x3D; 15，15是读取数组得来的。想要知道参数1的值就需要逆向推理求sum的过程，由<code>0x804a2e0(,%eax,4),%eax</code>可得也就是<code>eax=array[eax]</code>，所以就是当eax&#x3D;15是逆向运算，直到eax为参数1即可结束，参数2也是循环过程中所得array[eax]的和。<br> 逆向过程：</p><blockquote><p>array[6] &#x3D; 15;<br>array[14] &#x3D; 6;<br>array[2] &#x3D; 14;<br>array[1] &#x3D; 2;<br>array[10] &#x3D; 1;<br>array[0] &#x3D; 10;<br>array[8] &#x3D; 0;<br>array[4] &#x3D; 8;<br>array[9] &#x3D; 4;<br>array[13] &#x3D; 9;<br>array[11] &#x3D; 13;<br>array[7] &#x3D; 11;<br>array[3] &#x3D; 7;<br>array[12] &#x3D; 3;<br>以上时循环时的变化<br>array[参数1] &#x3D; 12;<br>看数组知array[5] &#x3D; 12 所以参数1 &#x3D; 5</p></blockquote><p>所以参数2为上述数组元素之和 &#x3D; 115，参数1 &#x3D; 5。<br>phase_5密码：<br>5 115  </p><h4 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h4><p>phase_6是一个关于链表的关卡，需要输入6个数字。</p><div class="code-wrapper"><pre><code class="hljs text">08048e76 &lt;phase_6&gt;: 8048e76:55                   push   %ebp 8048e77:89 e5                mov    %esp,%ebp 8048e79:56                   push   %esi 8048e7a:53                   push   %ebx                                       ////以上两个为调用者保存寄存器，后面的循环用到，故压栈保存(寄存器数量有限，要将原来的状态保存，因为要复原） 8048e7b:83 ec 40             sub    $0x40,%esp                                       //esp-64开栈 8048e7e:8d 45 c8             lea    -0x38(%ebp),%eax 8048e81:89 44 24 04          mov    %eax,0x4(%esp)                                       //ebp-56借助eax传给esp+4 8048e85:8b 45 08             mov    0x8(%ebp),%eax 8048e88:89 04 24             mov    %eax,(%esp)                                       //ebp+8 借助eax传给esp 8048e8b:e8 71 03 00 00       call   8049201 &lt;read_six_numbers&gt;                                       ////读入6个数 8048e90:be 00 00 00 00       mov    $0x0,%esi //清零 8048e95:8b 44 b5 c8          mov    -0x38(%ebp,%esi,4),%eax                                       // eax = (ebp-64) + 4*esi                                       //当前esi=0，亦即把ebp-64赋给eax，对于不同的esi，就是从ebp-64向上找第esi个数赋给eax。 8048e99:83 e8 01             sub    $0x1,%eax //eax -= 1 8048e9c:83 f8 05             cmp    $0x5,%eax                                         //if (5 &gt;= eax-1) 跳转，否则爆炸                                       //jbe是无符号数操作，故推知eax的范围为1-6 8048e9f:76 05                jbe    8048ea6 &lt;phase_6+0x30&gt; 8048ea1:e8 31 03 00 00       call   80491d7 &lt;explode_bomb&gt; 8048ea6:83 c6 01             add    $0x1,%esi                                        //esi += 1;                                       //(取第二个数） 8048ea9:83 fe 06             cmp    $0x6,%esi                                        //if (esi - 6 != 0) 跳转，否则顺序执行                                        //判断取的数是否超过6个，若大于6个引爆炸弹。从而推知循环结束的条件是esi=6。 8048eac:75 07                jne    8048eb5 &lt;phase_6+0x3f&gt; 8048eae:bb 00 00 00 00       mov    $0x0,%ebx //ebx = 0 8048eb3:eb 3a                jmp    8048eef &lt;phase_6+0x79&gt; 8048eb5:89 f3                mov    %esi,%ebx // ebx = esi 8048eb7:8b 44 9d c8          mov    -0x38(%ebp,%ebx,4),%eax                                       //eax = (ebp-64) + 4*ebx 8048ebb:39 44 b5 c4          cmp    %eax,-0x3c(%ebp,%esi,4)                                       // if (eax - ((ebx-64) + 4*esi)!=0)跳转，否则爆炸 8048ebf:75 05                jne    8048ec6 &lt;phase_6+0x50&gt; 8048ec1:e8 11 03 00 00       call   80491d7 &lt;explode_bomb&gt; 8048ec6:83 c3 01             add    $0x1,%ebx //ebx+=1 8048ec9:83 fb 05             cmp    $0x5,%ebx //if (5 &lt;= ebx) 跳转，否则顺序执行 8048ecc:7e e9                jle    8048eb7 &lt;phase_6+0x41&gt; 8048ece:66 90                xchg   %ax,%ax //交换16位寄存器中的内容 8048ed0:eb c3                jmp    8048e95 &lt;phase_6+0x1f&gt; 8048ed2:8b 52 08             mov    0x8(%edx),%edx // edx+8赋给edx 8048ed5:83 c0 01             add    $0x1,%eax //eax += 1 8048ed8:39 c8             p-&gt;  cmp    %ecx,%eax //if (ecx - eax != 0) 跳转，否则顺序执行 8048eda:75 f6                jne    8048ed2 &lt;phase_6+0x5c&gt; 8048edc:eb 05                jmp    8048ee3 &lt;phase_6+0x6d&gt; 8048ede:ba 3c c1 04 08       mov    $0x804c13c,%edx                                       //0x804c13c中的内容赋给edx                                       //用GDB查看发现它是链表表头的首地址，推知第六关是对链表进行操作 8048ee3:89 54 b5 e0          mov    %edx,-0x20(%ebp,%esi,4)                                       //（ebp-32）+ sei*4 = edx 8048ee7:83 c3 01             add    $0x1,%ebx //ebx+=1 8048eea:83 fb 06             cmp    $0x6,%ebx //ebx = 6跳转，否则顺序执行 8048eed:74 17                je     8048f06 &lt;phase_6+0x90&gt; 8048eef:89 de                mov    %ebx,%esi //ebx赋给esi 8048ef1:8b 4c 9d c8          mov    -0x38(%ebp,%ebx,4),%ecx                                        //ecx=(ebp-64)+4*ebx 8048ef5:83 f9 01             cmp    $0x1,%ecx                                       //if(1&lt;=ecx)跳转，否则顺序执行 8048ef8:7e e4                jle    8048ede &lt;phase_6+0x68&gt; 8048efa:b8 01 00 00 00       mov    $0x1,%eax // eax=1 8048eff:ba 3c c1 04 08       mov    $0x804c13c,%edx                                        //0x804c13c中的值赋给edx                                       //用GDB查看发现它是链表表头的首地址，推知第六关是对链表进行操作 8048f04:eb cc                jmp    8048ed2 &lt;phase_6+0x5c&gt; 8048f06:8b 5d e0             mov    -0x20(%ebp),%ebx                                        //ebp-32赋给ebx 8048f09:8d 45 e4             lea    -0x1c(%ebp),%eax                                       //ebp-28赋给eax 8048f0c:8d 75 f8             lea    -0x8(%ebp),%esi                                       //ebp-8赋给esi 8048f0f:89 d9                mov    %ebx,%ecx                                         //ebx赋给ecx 8048f11:8b 10                mov    (%eax),%edx                                       //edx = eax中的内容 8048f13:89 51 08             mov    %edx,0x8(%ecx)                                        //edx赋给ecx+8 8048f16:83 c0 04             add    $0x4,%eax //eax += 4 8048f19:39 f0                cmp    %esi,%eax                                        // esi = eax跳转，否则顺序执行 8048f1b:74 04                je     8048f21 &lt;phase_6+0xab&gt; 8048f1d:89 d1                mov    %edx,%ecx//edx赋给ecx 8048f1f:eb f0                jmp    8048f11 &lt;phase_6+0x9b&gt; 8048f21:c7 42 08 00 00 00 00 movl   $0x0,0x8(%edx)                                       //edx+8=0 8048f28:be 05 00 00 00       mov    $0x5,%esi                                       //esi=5 8048f2d:8b 43 08             mov    0x8(%ebx),%eax                                       //ebx+8赋给eax 8048f30:8b 00                mov    (%eax),%eax                                       //eax = eax中的内容 8048f32:39 03                cmp    %eax,(%ebx)                                       // eax &lt;= ebx中的内容 跳转，否则爆炸 8048f34:7e 05                jle    8048f3b &lt;phase_6+0xc5&gt; 8048f36:e8 9c 02 00 00       call   80491d7 &lt;explode_bomb&gt; 8048f3b:8b 5b 08             mov    0x8(%ebx),%ebx                                       //ebx+8 赋给ebx 8048f3e:83 ee 01             sub    $0x1,%esi //esi-1 &gt; 0跳回到循环中 8048f41:75 ea                jne    8048f2d &lt;phase_6+0xb7&gt; 8048f43:83 c4 40             add    $0x40,%esp 8048f46:5b                   pop    %ebx 8048f47:5e                   pop    %esi 8048f48:5d                   pop    %ebp 8048f49:c3                   ret</code></pre></div><p> 将上面分析得<br> 用GDB查看链表中的内容是（链表首地址是0x804c13c,下一个链表地址是上一个链表的地址+12）<br><a href="https://imgtu.com/i/qvZ8Bt"><img src="https://s1.ax1x.com/2022/04/06/qvZ8Bt.png" alt="qvZ8Bt.png"></a></p><blockquote><p>1 0x146<br>2 0x2dc<br>3 0x2f7<br>4 0x0a3<br>5 0x26c<br>6 0x225</p></blockquote><p>从小到大排序得  </p><blockquote><p>4 0x0a3<br>1 0x14f<br>6 0x225<br>5 0x26c<br>2 0x2dc<br>3 0x2fc</p></blockquote><p>故phase_6得密码为<br>4 1 6 5 2 3  </p><h4 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h4><p>由于老师、助教提供的实验、资料，他们在介绍实验的PPT里说明了——还有这个<code>secret_phase</code>关卡，也说明了——进入第七关需要在第四关后面输入一个字符串。<br>所以减少了的工作，但是我们还是要明白为什么是这样。  （还是实验前我并没有认真看PPT或者是我忘记了提示过还有个隐藏关卡，所以做到phase_6时，看着对应的汇编代码发现下面还有个<code>secret_phase</code>）  </p><p>当我们发现了还有个隐藏关卡时，发现了第一个问题——怎么进入<code>secret_phase</code>，毕竟输入完前六关的密码时，炸弹就全部解开了，没给我们输入什么的机会。所以该怎么进入呢。  </p><p>前六个都是在Main函数中顺序排好的，那我们就去看看main函数对应汇编代码会不会有线索。然而并没有发现与<code>secret_phase</code>有关的内容，但是发现每个phase_x后都有一个<code>phase_defused</code>。</p><div class="code-wrapper"><pre><code class="hljs text">call   xxxxxxx &lt;phase_x&gt;call   xxxxxxx &lt;phase_defused&gt;</code></pre></div><p>那么能否进入隐藏关卡是否与其有关呢。于是在查看<code>phase_defused</code>的汇编代码，发现<code>80493c9:e8 cf fb ff ff       call   8048f9d &lt;secret_phase&gt;</code>，这不就出现了嘛，那就看看里面是什么意思。</p><div class="code-wrapper"><pre><code class="hljs text">0804934f &lt;phase_defused&gt;: 804934f:55                   push   %ebp 8049350:89 e5                mov    %esp,%ebp 8049352:81 ec 88 00 00 00    sub    $0x88,%esp                                       //esp-128开栈 8049358:65 a1 14 00 00 00    mov    %gs:0x14,%eax</code></pre></div><p> 这意味着从地址gs：0x14的内存中读取4个字节到eax。 gs是一个段寄存器。最有可能的是线程本地存储(AKA TLS)通过该寄存器引用。(百度的，我不懂，搜索了很多，还是没怎么看明白%gs的意思，故而找了一个感觉对的)<br> <div class="code-wrapper"><pre><code class="hljs text">804935e:89 45 f4             mov    %eax,-0xc(%ebp) //ebp-12 = eax8049361:31 c0                xor    %eax,%eax //eax异或运算8049363:83 3d c8 c3 04 08 06 cmpl   $0x6,0x804c3c8                                       // 0x804c3c8 与 6比较                                      // 经GDB查看后发现0x804c3c8指向&lt;num_input_strings&gt;:&quot;\005&quot;                                      // 其中&quot;\005&quot;是调试时处于phase_5得到的值x                                      // 在不同得phase阶段查此地址会得到不同的&quot;\00x&quot;,x取决于第几个                                      // 所以 这一行是判断密码输入的次数是否 = 6804936a:75 6e                jne    80493da &lt;phase_defused+0x8b&gt;804936c:8d 45 a4             lea    -0x5c(%ebp),%eax 804936f:89 44 24 10          mov    %eax,0x10(%esp)                                                       // esp+16 = ebp - 928049373:8d 45 a0             lea    -0x60(%ebp),%eax8049376:89 44 24 0c          mov    %eax,0xc(%esp)                                                       // esp+12 = ebp- 96804937a:8d 45 9c             lea    -0x64(%ebp),%eax804937d:89 44 24 08          mov    %eax,0x8(%esp)                                                      // esp+8 = ebp -100                                      8049381:c7 44 24 04 b1 a4 04 movl   $0x804a4b1,0x4(%esp)                                      // GDB查看得 &quot;%d %d %s&quot;                                      // 表示需要如此输入，经提示，我们知道了在第四关以这样得格式输入。8049388:08 8049389:c7 04 24 d0 c4 04 08 movl   $0x804c4d0,(%esp)                                      // 得 &lt;input_strings + 240&gt; : &quot;6 6&quot; (有点熟悉)                                      8049390:e8 cb f4 ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;8049395:83 f8 03             cmp    $0x3,%eax                                       // 如果返回的输入个数不等于三跳转至80493ce，否则顺序执行8049398:75 34                jne    80493ce &lt;phase_defused+0x7f&gt;804939a:c7 44 24 04 ba a4 04 movl   $0x804a4ba,0x4(%esp)                                      // 易知地址中为&quot;DrEvil&quot;                                      // 不会是进入的密码呢，再往下看看80493a1:08 80493a2:8d 45 a4             lea    -0x5c(%ebp),%eax80493a5:89 04 24             mov    %eax,(%esp) //esp=ebp-9280493a8:e8 15 fd ff ff       call   80490c2 &lt;strings_not_equal&gt;                                      // 字符比较80493ad:85 c0                test   %eax,%eax //应该是判断输入的字符是否为&quot;DrEvil&quot;80493af:75 1d                jne    80493ce &lt;phase_defused+0x7f&gt;80493b1:c7 04 24 80 a3 04 08 movl   $0x804a380,(%esp)                                       80493b8:e8 33 f4 ff ff       call   80487f0 &lt;puts@plt&gt;80493bd:c7 04 24 a8 a3 04 08 movl   $0x804a3a8,(%esp)80493c4:e8 27 f4 ff ff       call   80487f0 &lt;puts@plt&gt;80493c9:e8 cf fb ff ff       call   8048f9d &lt;secret_phase&gt;                                      //以上就是发现secret_phase需要进行得操作80493ce:c7 04 24 e0 a3 04 08 movl   $0x804a3e0,(%esp)80493d5:e8 16 f4 ff ff       call   80487f0 &lt;puts@plt&gt;80493da:8b 45 f4             mov    -0xc(%ebp),%eax80493dd:65 33 05 14 00 00 00 xor    %gs:0x14,%eax80493e4:74 05                je     80493eb &lt;phase_defused+0x9c&gt;80493e6:e8 d5 f3 ff ff       call   80487c0 &lt;__stack_chk_fail@plt&gt;80493eb:c9                   leave  80493ec:8d 74 26 00          lea    0x0(%esi,%eiz,1),%esi80493f0:c3                   ret    80493f1:66 90                xchg   %ax,%ax80493f3:66 90                xchg   %ax,%ax80493f5:66 90                xchg   %ax,%ax80493f7:66 90                xchg   %ax,%ax80493f9:66 90                xchg   %ax,%ax80493fb:66 90                xchg   %ax,%ax80493fd:66 90                xchg   %ax,%ax80493ff:90                   nop</code></pre></div><br>上面几个地址中存在的值如图<br><a href="https://imgtu.com/i/qvZAn1"><img src="https://s1.ax1x.com/2022/04/06/qvZAn1.png" alt="qvZAn1.png"></a></p><p>经分析可知，secret_phase的进入需要我们成功解除了前六个炸弹后并在第四关以”%d %d %s”的格式输入”6 6 DrEvil”。</p><div class="code-wrapper"><pre><code class="hljs text">08048f9d &lt;secret_phase&gt;: 8048f9d:55                   push   %ebp 8048f9e:89 e5                mov    %esp,%ebp 8048fa0:53                   push   %ebx 8048fa1:83 ec 14             sub    $0x14,%esp//开栈 8048fa4:e8 a8 02 00 00       call   8049251 &lt;read_line&gt; 8048fa9:c7 44 24 08 0a 00 00 movl   $0xa,0x8(%esp) //esp+8 = 10 8048fb0:00  8048fb1:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp) //esp+4=0 8048fb8:00  8048fb9:89 04 24             mov    %eax,(%esp)  8048fbc:e8 0f f9 ff ff       call   80488d0 &lt;strtol@plt&gt; 8048fc1:89 c3                mov    %eax,%ebx 8048fc3:8d 40 ff             lea    -0x1(%eax),%eax 8048fc6:3d e8 03 00 00       cmp    $0x3e8,%eax //if 0x3e8 &lt;= eax,跳转，否则爆炸 8048fcb:76 05                jbe    8048fd2 &lt;secret_phase+0x35&gt; 8048fcd:e8 05 02 00 00       call   80491d7 &lt;explode_bomb&gt; 8048fd2:89 5c 24 04          mov    %ebx,0x4(%esp)                                       //ebx中值为输入的参数 8048fd6:c7 04 24 88 c0 04 08 movl   $0x804c088,(%esp)                                       //进入递归的参数 8048fdd:e8 68 ff ff ff       call   8048f4a &lt;fun7&gt; 8048fe2:83 f8 05             cmp    $0x5,%eax  8048fe5:74 05                je     8048fec &lt;secret_phase+0x4f&gt; 8048fe7:e8 eb 01 00 00       call   80491d7 &lt;explode_bomb&gt;                                       //只有当递归的返回值等于5时，不引爆炸弹 8048fec:c7 04 24 20 a3 04 08 movl   $0x804a320,(%esp) 8048ff3:e8 f8 f7 ff ff       call   80487f0 &lt;puts@plt&gt; 8048ff8:e8 52 03 00 00       call   804934f &lt;phase_defused&gt; 8048ffd:83 c4 14             add    $0x14,%esp 8049000:5b                   pop    %ebx 8049001:5d                   pop    %ebp 8049002:c3                   ret     8049003:66 90                xchg   %ax,%ax 8049005:66 90                xchg   %ax,%ax 8049007:66 90                xchg   %ax,%ax 8049009:66 90                xchg   %ax,%ax 804900b:66 90                xchg   %ax,%ax 804900d:66 90                xchg   %ax,%ax 804900f:90                   nop</code></pre></div><p>分析得secret_phase需要我们输入一个值，该值与0x804c088中的值一起进入递归函数，需使得递归返回值 &#x3D; 5。  </p><p>分析Func7 ：</p> <div class="code-wrapper"><pre><code class="hljs text">08048f4a &lt;fun7&gt;: 8048f4a:55                   push   %ebp 8048f4b:89 e5                mov    %esp,%ebp 8048f4d:53                   push   %ebx 8048f4e:83 ec 14             sub    $0x14,%esp 8048f51:8b 55 08             mov    0x8(%ebp),%edx //最开始是0x804c088中的值，记作参数one 8048f54:8b 4d 0c             mov    0xc(%ebp),%ecx //最开始是我们需要的参数，记作参数two 8048f57:85 d2                test   %edx,%edx //edx为0 返回-1 8048f59:74 37                je     8048f92 &lt;fun7+0x48&gt;------------------ 8048f5b:8b 1a                mov    (%edx),%ebx //ebx = *edx 8048f5d:39 cb                cmp    %ecx,%ebx //if ecx &lt;= ebx 跳转 8048f5f:7e 13                jle    8048f74 &lt;fun7+0x2a&gt;  8048f61:89 4c 24 04          mov    %ecx,0x4(%esp) 8048f65:8b 42 04             mov    0x4(%edx),%eax 8048f68:89 04 24             mov    %eax,(%esp)//(edx+4, ecx)两个参数进入递归 8048f6b:e8 da ff ff ff       call   8048f4a &lt;fun7&gt; 8048f70:01 c0                add    %eax,%eax//返回值=递归返回值*2 8048f72:eb 23                jmp    8048f97 &lt;fun7+0x4d&gt; ------------------ 8048f74:b8 00 00 00 00       mov    $0x0,%eax //eax = 0 8048f79:39 cb                cmp    %ecx,%ebx  8048f7b:74 1a                je     8048f97 &lt;fun7+0x4d&gt;                                        //if ecx == ebx 结束递归 8048f7d:89 4c 24 04          mov    %ecx,0x4(%esp) 8048f81:8b 42 08             mov    0x8(%edx),%eax 8048f84:89 04 24             mov    %eax,(%esp) //(*(edx+8),ecx)两个参数进入递归 8048f87:e8 be ff ff ff       call   8048f4a &lt;fun7&gt; 8048f8c:8d 44 00 01          lea    0x1(%eax,%eax,1),%eax                                       // 返回值 = 递归返回值*2 + 1 8048f90:eb 05                jmp    8048f97 &lt;fun7+0x4d&gt;-------------------- 8048f92:b8 ff ff ff ff       mov    $0xffffffff,%eax 8048f97:83 c4 14             add    $0x14,%esp 8048f9a:5b                   pop    %ebx 8048f9b:5d                   pop    %ebp 8048f9c:c3                   ret</code></pre></div><p>进行一波困难的逆向得Func7的C语言代码:  </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func7</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> b)</span>&#123;    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">NULL</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (*a &gt; b)    <span class="hljs-keyword">if</span> (*a == b)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      <span class="hljs-keyword">else</span>      &#123;        result = func7(*(a + <span class="hljs-number">8</span>), b);        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * result + <span class="hljs-number">1</span>;      &#125;    <span class="hljs-keyword">else</span>     &#123;      result = func7(*(a + <span class="hljs-number">4</span>), b);        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * result;    &#125;&#125;</code></pre></div><p>由于最后的返回值是5，根据函数的结构可以想到这样的结构：</p><blockquote><p>a * 2 + 1 &#x3D; 5 ————&gt; b * 2 &#x3D; a ————&gt; c * 2 + 1 &#x3D; b ————&gt; c &#x3D; 0  </p></blockquote><p>即*a、b的关系为  </p><blockquote><p>*a &lt; b ————&gt; *a &gt; b ————&gt; *a &lt; b————&gt; *a &#x3D;&#x3D; b</p></blockquote><p>所以一共递归</p><blockquote><p>*a – b &gt; 0<br>*a – b &lt; 0<br>*a – b &gt; 0<br>*a – b &#x3D;&#x3D; 0</p></blockquote><p>用GDB查看<code>0x804c088</code>后得到</p><ol><li><code>0x804c088 = 0x24</code>，之后在<code>*a - b &lt; 0 (0x24 – b &lt; 0)</code>的分支中<code>*(a + 8)= 0x804c090</code>，所以<code>func7(0x804c090, b)</code>。</li><li><code>*0x804c090 = 0x32</code>，<code>*a - b &gt; 0 (0x32 - b &gt; 0)</code>，递归<code>fun7(*(0x804c090 + 4) = 0x804c094, b)</code>。</li><li><code>*0x804c094 = 0x2d</code>，<code>*a - b &lt; 0 (0x2d - b &lt; 0)</code>，<code>fun7(*(0x804c094 + 8) = 0x804c09c, b)</code>。</li><li><code>*0x804c09c = 0x2f</code>，<code>*a – b == 0 (0x2f – b == 0)</code>，所以<code>b = 0x2f</code>，递归返回。</li></ol><p>得到3个不等式和一个等式：</p><ol><li><code>0x24 – 0x2f &lt; 0</code></li><li><code>0x32 – 0x2f &gt; 0</code></li><li><code>0x2d – 0x2f &lt; 0</code></li><li><code>b = 0x2f</code><br>转为十进制 b &#x3D; 47，故隐藏关卡密码为47。</li></ol><p>淦！！！！！！！  </p><p>以上是正常情况下应该得出理解答案的结果，但是事实并不如我想象。操作后并没有得到答案。但是答案确实是47。<br>通过不断的查找，发现存着47的地址在老后面了，完全不对啊。 淦，问题真多。</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><a href="https://imgtu.com/i/qvVXmq"><img src="https://s1.ax1x.com/2022/04/06/qvVXmq.md.png" alt="qvVXmq.md.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>实验记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>Csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Github Actions 实现 Hexo 博客在 Github 上的自动部署</title>
    <link href="/using-github-actions/"/>
    <url>/using-github-actions/</url>
    
    <content type="html"><![CDATA[<p><strong>文档存在信息滞后，部分信息可能与实际不符</strong></p><p class="note note-primary">2022-06-28 更新：当前使用的 [自动部署配置文件](https://github.com/Muxiner/muxiner.github.io/blob/source/.github/workflows/acitons.yml)</p><hr><p>使用自动部署之前，我都是用的 <code>hexo deploy</code> 把每次生成的 <code>public</code> 文件夹上传到 github 上去，使用自动部署之后，就省略掉了这一步骤，但是多了这三步</p><blockquote><p>git add -A<br>git commit -m “imformaion”<br>git push</p></blockquote><p>看似并没有简化自己的操作，实际上好处很多  </p><ul><li>博客源码托管在 Github 的仓库，避免源码丢失的风险</li><li>Github 会记录每一次 <code>commit</code>，方便回溯</li><li>高逼格</li><li>……</li></ul><h3 id="关于自动化部署"><a href="#关于自动化部署" class="headerlink" title="关于自动化部署"></a>关于自动化部署</h3><p>百度词条中的<a href="https://baike.baidu.com/item/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/18750522"><u>自动化部署</u></a></p><p>以及 <code>CI/CD</code> —— CI&#x2F;CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI&#x2F;CD 的核心概念是持续集成、持续交付和持续部署。  </p><p><a href="https://github.com/features/actions"><code>github Actions</code></a> 是 <a href="https://github.com/"><code>GitHub</code></a> 的持续集成服务，于 2018 年 10 月推出。</p><p>还有一个类似的是 <a href="https://travis-ci.org/"><code>TravisCI</code></a>。  </p><p>我之前使用的就是 <code>TravisCI</code>，然后出了点小小的问题，其无法使用，然后一直配置不好，我就开始使用 <code>GitHub Actions</code>，而且有大佬说<code>觉得它非常强大，有创意，比 Travis CI 玩法更多。</code></p><p>不多介绍，就推荐几个大佬的文章</p><ul><li><a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></li><li><a href="https://blog.kaygb.com/210.html">基于 Github actions 自动部署 Hexo 博客</a></li><li><a href="https://xirikm.net/2020/313-1">使用 GitHub Actions 自动构建 Hexo 博客</a></li></ul><p>不多介绍了，直接说我怎么使用 <code>github actions</code> 的，主要 chao 了大佬的东西。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>需要一个 <code>GitHub</code> 帐号、一个 <code>GitHub Pages</code> 仓库、一个 <code>Hexo</code> 博客备份仓库&#x2F;分支。另外我们还需要获取一个 <code>GitHub Personal Access Token</code> 用来推送构建好的文件到我们的 <code>GitHub Pages</code> 仓库。具体的操作这里不再重复叙述，有需要了解的可以去看之前的文章。</p><p>点开博客备份仓库上方的 <code>Settings</code>，点到左侧的 <code>Secrets</code> 项，添加两个秘密环境变量 <code>GH_REF </code>、<code>GH_TOKEN</code>，值分别填写自己的 <code>GitHub Pages</code> 仓库地址（不包含 https:&#x2F;&#x2F; ）和刚刚申请到的 <code>GitHub Personal Access Token</code>。</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628220050.png"></p><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>准备工作做好后就可以开始编写 <code>GitHub Actions</code> 配置文件了，这里对 Hexo 博客编译部署的步骤进行拆分讲解。</p><p>配置文件的目录——在站点目录下新建 <code>.github</code> 文件夹，再在其中新建文件夹 <code>workflows</code>，在创建 <code>×××××××.yml</code> 文件，命名随意。</p><p><img src="https://munner.coding.net/p/blogpicgo/d/blogimages/git/raw/main/posts/20220628220127.png"></p><h3 id="触发条件和运行环境"><a href="#触发条件和运行环境" class="headerlink" title="触发条件和运行环境"></a>触发条件和运行环境</h3><p>我们设置在 <code>master</code> 分支上发生 <code>push</code> 操作时触发构建，使用最新的 <code>Ubuntu</code> 系统作为编译部署的环境，同时设置一个全局环境变量将时区修改为 <code>Asia/Shanghai</code> (修改原因见 <a href="https://xirikm.net/2020/215-1.html)%EF%BC%8C%E5%85%B7%E4%BD%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B%EF%BC%9A">https://xirikm.net/2020/215-1.html)，具体的配置内容如下：</a></p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Blog</span> <span class="hljs-string">CI/CD</span><span class="hljs-attr">on:</span>  <span class="hljs-attr">push:</span>    <span class="hljs-attr">branches:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><span class="hljs-attr">env:</span>  <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><span class="hljs-attr">jobs:</span>  <span class="hljs-attr">blog-cicd:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">blog</span> <span class="hljs-string">build</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">deploy</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>    <span class="hljs-attr">steps:</span></code></pre></div><h3 id="建立工作环境"><a href="#建立工作环境" class="headerlink" title="建立工作环境"></a>建立工作环境</h3><p>上面的大前提确定后就可以来开始建立我们的工作环境了（注： 后续所有步骤的配置都是接在上面 <code>steps</code> 块下的，不要弄混了层级关系）。</p><p>首先检出代码，设置一下 <code>node</code> 环境，我们这里使用 <code>12.x</code> 版本的 <code>node.js</code>：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">steps:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">codes</span>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">node</span>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span>  <span class="hljs-attr">with:</span>    <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12.x&#x27;</span></code></pre></div><p>然后设置一下缓存目录以避免每次都要重新下载，从而加快构建速度（官方不建议直接缓存 <code>node_modules</code> 目录，所以这里设置的是 <code>npm</code> 的下载缓存目录 <code>~/.npm</code> ，这样后面仍需要使用 <code>npm install</code> 来安装依赖）。这里使用的是 <code>package-lock.json</code> 文件的 <code>hash</code> 值来标识缓存是否可以命中：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">node</span> <span class="hljs-string">modules</span>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span>  <span class="hljs-attr">with:</span>    <span class="hljs-attr">path:</span> <span class="hljs-string">~/.npm</span>    <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span></code></pre></div><p>最后就是安装依赖了，这个根据自己的需要操作就行，由于我使用了 <code>gulp</code> 任务来压缩 <code>Hexo</code> 生成的文件，所以我这里除了 <code>hexo-cli</code> 还全局安装了<code>gulp</code>：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span>  <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">    npm install hexo-cli gulp -g</span><span class="hljs-string">    npm install</span></code></pre></div><h3 id="生成部署文件"><a href="#生成部署文件" class="headerlink" title="生成部署文件"></a>生成部署文件</h3><p>这一步简单点 <code>hexo g</code> 就行了，我这里多加了一步执行 gulp 任务的操作（将其放在两个 <code>step</code> 中而不是一次性执行是为了方便在日志中看到每个操作消耗的时间）：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">files</span>  <span class="hljs-attr">run:</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Execute</span> <span class="hljs-string">gulp</span> <span class="hljs-string">task</span>  <span class="hljs-attr">run:</span> <span class="hljs-string">gulp</span></code></pre></div><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><p>我们先将 <code>GitHub Pages</code> 仓库克隆过来，将其中的 <code>.git</code> 目录移到存放部署文件的 <code>public</code> 目录中（为了保留 <code>GitHub Pages</code> 仓库的提交历史），然后进入 <code>public</code> 目录设置一下提交用户名和邮箱，<code>add</code> 所有文件并提交，最后利用保存在秘密环境变量中的 <code>GitHub Personal Access Token</code> 推送到 <code>GitHub Pages</code> 仓库中就可以了：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">blog</span>  <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">    git clone &quot;https://$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; deploy_git</span><span class="hljs-string">    mv ./deploy_git/.git ./public/</span><span class="hljs-string">    cd ./public</span><span class="hljs-string">    git config user.name &quot;yourname&quot;</span><span class="hljs-string">    git config user.email &quot;youremail&quot;</span><span class="hljs-string">    git add .</span><span class="hljs-string">    git commit -m &quot;GitHub Actions Auto Builder at $(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)&quot;</span><span class="hljs-string">    git push --force --quiet &quot;https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; master:master</span></code></pre></div><h3 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h3><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Blog</span> <span class="hljs-string">CI/CD</span><span class="hljs-attr">on:</span>  <span class="hljs-attr">push:</span>    <span class="hljs-attr">branches:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><span class="hljs-attr">env:</span>  <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><span class="hljs-attr">jobs:</span>  <span class="hljs-attr">blog-cicd:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">blog</span> <span class="hljs-string">build</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">deploy</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>    <span class="hljs-attr">steps:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">codes</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">node</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12.x&#x27;</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">node</span> <span class="hljs-string">modules</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">path:</span> <span class="hljs-string">~/.npm</span>        <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">        npm install hexo-cli gulp -g</span><span class="hljs-string">        npm install</span><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">files</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Execute</span> <span class="hljs-string">gulp</span> <span class="hljs-string">task</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">gulp</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">blog</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">        git clone &quot;https://$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; deploy_git</span><span class="hljs-string">        mv ./deploy_git/.git ./public/</span><span class="hljs-string">        cd ./public</span><span class="hljs-string">        git config user.name &quot;yourname&quot;</span><span class="hljs-string">        git config user.email &quot;youremail&quot;</span><span class="hljs-string">        git add .</span><span class="hljs-string">        git commit -m &quot;GitHub Actions Auto Builder at $(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)&quot;</span><span class="hljs-string">        git push --force --quiet &quot;https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; master:master</span></code></pre></div><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://xirikm.net/2020/313-1"><u>使用 GitHub Actions 自动构建 Hexo 博客</u></a></li><li><a href="https://easyhexo.com/1-Hexo-install-and-config/1-5-continuous-integration.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90"><u>持续集成 Continuous Integration</u></a></li></ul>]]></content>
    
    
    <categories>
      
      <category>GitHub</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git push 不用每次输入用户名和密码</title>
    <link href="/git-password/"/>
    <url>/git-password/</url>
    
    <content type="html"><![CDATA[<p><strong>本文仅供参考</strong></p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>每次 <code>git push</code> 时都要输入用户名和密码，觉得很累。  就想只输入一次将用户名密码保存下来，避免每次都要重新输入。  </p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><div class="code-wrapper"><pre><code class="hljs git">git config --global credential.helper store</code></pre></div><div class="code-wrapper"><pre><code class="hljs git">git pull /git push # (这里需要输入用户名和密码，以后就不用啦)</code></pre></div><p>push你的代码 (git push), 这时会让你输入用户名和密码, 这一步输入的用户名密码会被记住, 下次再push代码时就不用输入用户名密码 ! 这一步会在用户目录下生成文件.<code>git-credential</code> 记录用户名密码的信息。</p><p>然后就可以了。</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>emmm，使用方法之前，我需要输入两次用户名密码，使用后我只需要输入一次啦，这是一次巨大的”成功“。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/LosingCarryJie/article/details/73801554">git不用每次输入用户名和密码</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统基础实验之datalab-handout</title>
    <link href="/datalab-handout/"/>
    <url>/datalab-handout/</url>
    
    <content type="html"><![CDATA[<h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><p>下载 <code>lab1-handout.tar</code></p><blockquote><p>(可由老师提供，或者在 <code>http://csapp.cs.cmu.edu/3e/labs.html</code> <a href="http://csapp.cs.cmu.edu/3e/labs.html">csapp</a>下载,获取方法是点击实验后面的 <code>Self-Study Handout</code>)，存放在下载目录</p></blockquote><span id="more"></span><p>点击左侧 <code>dock</code> 图标，键入 <code>term</code> ，打开终端</p><ul><li><code>cd ~</code>    进入主目录      键入 </li><li><code>ls</code> 查看是否有下载文件</li><li><code>tar vxf lab1-handout.tar</code>   解压代码框架  </li><li><code>cd lab1-handout</code></li><li><code>ls</code>    显示当前目录文件</li><li><code>make</code>   编译生成可执行文件</li><li><code>ls</code>  看看多了几个文件</li><li><code>./btest</code> 试试运行</li></ul><p>本实验是默认在 32 位机上进行测试。</p><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><h3 id="1-bitBor函数"><a href="#1-bitBor函数" class="headerlink" title="1. bitBor函数"></a>1. bitBor函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp; </span><span class="hljs-comment"> *   Example: bitXor(4, 5) = 1</span><span class="hljs-comment"> *   Legal ops: ~ &amp;</span><span class="hljs-comment"> *   Max ops: 14</span><span class="hljs-comment"> *   Rating: 1</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><ul><li>使用 <code>~</code> 和 <code>&amp;</code> 实现 <code>x^y</code></li></ul><p>法1：  </p><ul><li>题意：用 <code>~</code> 和 <code>&amp;</code> 运算符实现 <code>Xor</code> 运算符</li><li>思路：我们知道 <code>Xor</code> 运算符是对每一个位，相同的话返回 <code>0</code> ，不同的话返回 <code>1</code> ，即 <code>((~x)&amp;y)|(x&amp;(~y))</code> 。但不能使用 <code>|</code> 运算，故采用德摩根律将或运算转为与运算。</li></ul><p>法2：</p><ul><li>利用《数字逻辑》的知识：异或运算 德摩根律<blockquote><p>x ^ y &#x3D; (x &amp; ~y) | (~x &amp; y)<br>&#x3D; ~((x &amp; ~y) | (~x &amp; y))<br>&#x3D; ~(~(x &amp; ~y) &amp; ~(~x &amp; y))  D</p></blockquote></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-keyword">return</span> ~(~(x &amp; ~y) &amp; ~(~x &amp; y));&#125;</code></pre></div><h3 id="2-tmim函数"><a href="#2-tmim函数" class="headerlink" title="2. tmim函数"></a>2. tmim函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 4</span><span class="hljs-comment"> *   Rating: 1</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><ul><li>题意：输出反码下的最小值</li><li>思路：直接由定义得最小值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;&#125;</code></pre></div><h3 id="3-isTmax函数"><a href="#3-isTmax函数" class="headerlink" title="3. isTmax函数"></a>3. isTmax函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><span class="hljs-comment"> *     and 0 otherwise </span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><span class="hljs-comment"> *   Max ops: 10</span><span class="hljs-comment"> *   Rating: 1</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">isTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>判断一个数是否为有符号数的最大值 <code>Tmax</code> ，即  </p><blockquote><p>0x7FFFFFFF   16进制<br>2147483647   10进制<br>0111 1111 1111 1111 1111 1111 1111 1111    2进制(32位系统)</p></blockquote><blockquote><p>Tmax满足:  Tmax &#x3D; ~(Tmax + 1)    Tmax ^ (~(Tmax + 1)) &#x3D; 0<br><code>0xFFFFFFFF</code> 也满足上述关系，但 <code>0xFFFFFFFF + 1</code> 为 <code>0</code>, 所以要排除这种情况。  </p></blockquote><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">inTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;    <span class="hljs-keyword">return</span> !(x ^ ~(x + <span class="hljs-number">1</span>)) &amp; !!(x + <span class="hljs-number">1</span>); &#125;</code></pre></div><h3 id="4-allOddBits函数"><a href="#4-allOddBits函数" class="headerlink" title="4. allOddBits函数"></a>4. allOddBits函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 12</span><span class="hljs-comment"> *   Rating: 2</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>判断一个二进制数奇数位是否全为 <code>1</code><br>思路:<br>若 <code>x</code> 奇数位全为 <code>1</code>，则 <code>~x</code> 的奇数位全为 <code>0</code> ，则 <code>~x &amp; 0xaaaaaaaa</code> 使得全部为 <code>0</code>。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> !(~x &amp; <span class="hljs-number">0xaaaaaaaa</span>);&#125;</code></pre></div><h3 id="5-negate函数"><a href="#5-negate函数" class="headerlink" title="5. negate函数"></a>5. negate函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * negate - return -x </span><span class="hljs-comment"> *   Example: negate(1) = -1.</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 5</span><span class="hljs-comment"> *   Rating: 2</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>求一个数的相反数。<br>思路: <code>-x = ~x + 1</code>  (取反加一)</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> ~x + <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="6-isAsciiDigit函数"><a href="#6-isAsciiDigit函数" class="headerlink" title="6. isAsciiDigit函数"></a>6. isAsciiDigit函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><span class="hljs-comment"> *   Example: isAsciiDigit(0x35) = 1.</span><span class="hljs-comment"> *            isAsciiDigit(0x3a) = 0.</span><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 15</span><span class="hljs-comment"> *   Rating: 3</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>判断一个数字是否在 <code>0x30</code> 到 <code>0x39</code> 范围之内。<br>思路:<br>判断差值是否大于等于 <code>x - y &gt;= 0</code> 即 <code>取符号位且取逻辑反</code>  </p><blockquote><p>!(x + (<del>y + 1) &gt;&gt; 31)<br>x + (</del>y + 1) &gt;&gt; 31   取符号位</p></blockquote><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> !(x + (~<span class="hljs-number">0x30</span> + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>) &amp; !(<span class="hljs-number">0x39</span> + (~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>);&#125;</code></pre></div><h3 id="7-conditional函数"><a href="#7-conditional函数" class="headerlink" title="7. conditional函数"></a>7. conditional函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * conditional - same as x ? y : z </span><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 16</span><span class="hljs-comment"> *   Rating: 3</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：实现一个三目运算符 <code>x ? y : z</code><br>思路：用 <code>!</code> 判断 <code>x</code> 的真假；<code>x ? y : z</code> 的关系转换为 <code>(a &amp; y) | (b &amp; z)</code> ，当 <code>x</code> 为 <code>0</code> 时，<code>a</code> 为 <code>0x0</code> ，<code>b</code> 为 <code>0xffffffff</code> ；当 <code>x</code> 非零时，<code>a</code> 为<code>0xffffffff</code> , <code>b</code> 为 <code>0x0</code> 。即  </p><blockquote><p>0x0 &amp; 0xaaa &#x3D; 0<br>0xffffffff &amp; 0xaaa &#x3D; 0xaaa   </p></blockquote><p>所以得使得 <code>a = !x + 0xffffffff</code> , <code>b = !!x + 0xffffffff</code> ，这样 <code>a</code> <code>b</code> 就会要么是 <code>0x0</code> <code>0xffffffff</code>。  </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;  <span class="hljs-keyword">return</span> ((!x + <span class="hljs-number">0xffffffff</span>)&amp; y) | (z &amp; (!!x + <span class="hljs-number">0xffffffff</span>));&#125;</code></pre></div><h3 id="8-isLessOrEqual函数"><a href="#8-isLessOrEqual函数" class="headerlink" title="8. isLessOrEqual函数"></a>8. isLessOrEqual函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 24</span><span class="hljs-comment"> *   Rating: 3</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：若 <code>x &lt;= y</code> ，则返回 <code>1</code> ，反之返回 <code>0</code>。<br>思路：直接用 <code>y-x</code> 可能会超出 <code>int</code> 的表示范围，故而：</p><blockquote><p>1.在x与y同号的情况下转换为p&#x3D;y-x&gt;&#x3D;0，然后对p符号位进行(p&gt;&gt;31)&amp;1操作，符号位为0则返回1，符号位1则返回0；<br>2.x，y异号时，只要x&gt;&#x3D;0，就要返回0，否则返回1，由(x&gt;&gt;31)&amp;1能达到该效果；<br>3.c&#x3D;a+b可作为x，y同号异号的判断。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-type">int</span> sign_bit_x = x &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-type">int</span> sign_bit_y = y &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-type">int</span> sign_bit_xy = sign_bit_x + sign_bit_y;  <span class="hljs-type">int</span> sign_bit_subyx = ((y + ~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;  <span class="hljs-keyword">return</span> (sign_bit_xy &amp; (sign_bit_x &amp; <span class="hljs-number">1</span>)) | ((~sign_bit_xy) &amp; !sign_bit_subyx);&#125;</code></pre></div><h3 id="9-logicalNeg函数"><a href="#9-logicalNeg函数" class="headerlink" title="9. logicalNeg函数"></a>9. logicalNeg函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of </span><span class="hljs-comment"> *              the legal operators except !</span><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *   Max ops: 12</span><span class="hljs-comment"> *   Rating: 4 </span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：计算 <code>!x</code> ：当 <code>x = 0</code> 时返回 <code>1</code>；当 <code>x ≠ 0</code> 时返回 <code>0</code>。<br>思路：<code>0</code>和<code>Tmin</code>的补码都是其本身，而其他数的补码则是符号位相反。所以要区别<code>0</code>和<code>Tmin</code>的区别  </p><blockquote><p>0x0000 0000<br>0x8000 0000    </p></blockquote><p>即最高位不同，故用算数右移取符号位判断。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> ((~x &amp; ~(~x + <span class="hljs-number">1</span>)) &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="10-haoManyBits函数"><a href="#10-haoManyBits函数" class="headerlink" title="10. haoManyBits函数"></a>10. haoManyBits函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><span class="hljs-comment"> *             two&#x27;s complement</span><span class="hljs-comment"> *  Examples: howManyBits(12) = 5</span><span class="hljs-comment"> *            howManyBits(298) = 10</span><span class="hljs-comment"> *            howManyBits(-5) = 4</span><span class="hljs-comment"> *            howManyBits(0)  = 1</span><span class="hljs-comment"> *            howManyBits(-1) = 1</span><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><span class="hljs-comment"> *  Max ops: 90</span><span class="hljs-comment"> *  Rating: 4</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：  给一个数字x,求出要表示出x需要的最少的位数。  </p><p>思路：  使用二分法。  </p><p> 若<code>x</code>是负数，那么对其取反，因为所需要的位数是一样的。  </p><blockquote><p>即  x &#x3D; (((x &gt;&gt; 31) &amp; <del>x) | ((</del>!(x &gt;&gt; 31) + 1) &amp; x)) </p></blockquote><p>然后是用二分法，先向右位移16位，即<code>half_x = x &gt;&gt; 16</code>，再判断<code>half_x</code>是否为<code>0</code>，即<code>!!half_x</code>。若为<code>0</code>，则<code>x</code>的最高位数为<code>16</code>；反之，其最低位数为<code>16</code>。依此类推，继续对其右移<code>8</code>、<code>4</code>、<code>2</code>、<code>1</code>位，得到<code>bit8</code>, <code>bit4</code>, <code>bit2</code>, <code>bit1</code>,分别表示一分为二后其中的一半是否存在，而另一半继续循环直至1，这时还剩下<code>x</code>，最后还需要再加上符号位<code>0</code>。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  x = (((x &gt;&gt; <span class="hljs-number">31</span>) &amp; ~x) | ((~!(x &gt;&gt; <span class="hljs-number">31</span>) + <span class="hljs-number">1</span>) &amp; x));  <span class="hljs-type">int</span> bit16, bit8, bit4, bit2, bit1;  <span class="hljs-type">int</span> half_x;    half_x = x &gt;&gt; <span class="hljs-number">16</span>;  bit16 = !!half_x &lt;&lt; <span class="hljs-number">4</span>;  x = x &gt;&gt; bit16;  half_x = x &gt;&gt; <span class="hljs-number">8</span>;  bit8 = !!half_x &lt;&lt; <span class="hljs-number">3</span>;  x = x &gt;&gt; bit8;  half_x = x &gt;&gt; <span class="hljs-number">4</span>;  bit4 = !!half_x &lt;&lt; <span class="hljs-number">2</span>;  x = x &gt;&gt; bit4;  half_x = x &gt;&gt; <span class="hljs-number">2</span>;  bit2 = !!half_x &lt;&lt; <span class="hljs-number">1</span>;  x = x &gt;&gt; bit2;  half_x = x &gt;&gt; <span class="hljs-number">1</span>;  bit1 = !!half_x &lt;&lt; <span class="hljs-number">0</span>;  x = x &gt;&gt; bit1;    <span class="hljs-keyword">return</span> bit16 + bit8 + bit4 + bit2 + bit1 + <span class="hljs-number">1</span> + x;&#125;</code></pre></div><h3 id="11-floatScale2函数"><a href="#11-floatScale2函数" class="headerlink" title="11. floatScale2函数"></a>11. floatScale2函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//float</span><span class="hljs-comment">/* </span><span class="hljs-comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><span class="hljs-comment"> *   floating point argument f.</span><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><span class="hljs-comment"> *   single-precision floating point values.</span><span class="hljs-comment"> *   When argument is NaN, return argument</span><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><span class="hljs-comment"> *   Max ops: 30</span><span class="hljs-comment"> *   Rating: 4</span><span class="hljs-comment"> */</span><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatScale2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  &#125;</code></pre></div><p>题意：  给出一个无符号整数<code>x</code>，将其看作一个浮点数，返回此数的两倍<code>x*2</code>。<br>思路： 取出符号<code>s</code>、阶码<code>exp</code>、尾数<code>frac</code>   </p><blockquote><p>sgn &#x3D; uf &amp; 0x80000000<br>exp &#x3D; uf &amp; 0x7F800000<br>frac &#x3D; uf &amp; 0x007FFFFF  </p></blockquote><p>若<code>exp</code>为0，则是非规格，直接左移。<br>若<code>exp</code>不是<code>0x7F80 0000</code>，即有效，则直接阶码加一。 </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatScale2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;  <span class="hljs-type">unsigned</span> f = uf;  <span class="hljs-type">unsigned</span> sgn = uf &amp; <span class="hljs-number">0x80000000</span>;<span class="hljs-comment">//符号位</span>  <span class="hljs-type">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7F800000</span>;<span class="hljs-comment">//阶码</span>  <span class="hljs-type">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007FFFFF</span>;<span class="hljs-comment">//位数</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> == <span class="hljs-number">0</span>)      f = (frac &lt;&lt; <span class="hljs-number">1</span>) | sgn;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> != <span class="hljs-number">0x7F800000</span>)      f = f + <span class="hljs-number">0x00800000</span>;<span class="hljs-comment">//阶码+1</span>  <span class="hljs-keyword">return</span> f;   &#125;</code></pre></div><h3 id="12-floatFloat2Int函数"><a href="#12-floatFloat2Int函数" class="headerlink" title="12. floatFloat2Int函数"></a>12. floatFloat2Int函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><span class="hljs-comment"> *   for floating point argument f.</span><span class="hljs-comment"> *   Argument is passed as unsigned int, but</span><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><span class="hljs-comment"> *   single-precision floating point value.</span><span class="hljs-comment"> *   Anything out of range (including NaN and infinity) should return</span><span class="hljs-comment"> *   0x80000000u.</span><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><span class="hljs-comment"> *   Max ops: 30</span><span class="hljs-comment"> *   Rating: 4</span><span class="hljs-comment"> */</span><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：给出一个无符号整数x，将其看作一个浮点数，实现一个(int)x的功能。  </p><p>思路：</p><p>主要是思考上下界溢出的问题。</p><p>下界溢出的临界是<code>bin(x) = 0 0111 1111 0000 0000 0000 0000 0000 000</code>，此时<code>s = 0</code>，<code>exp = 127</code>，<code>frac = 0</code>。表示的数字刚好是<code>1.0</code>。小于这个数直接返回<code>0</code>。</p><p>上界溢出的条件是<code>bin(x) = 0 1001 1101 0000 0000 0000 0000 0000 000</code>，此时<code>s = 0</code>，<code>exp = 127 + 31</code>，<code>frac = 0</code>。表示的数是<code>1.0*2**32</code>，也就是<code>TMax</code>，大于这个数就直接返回<code>TMax</code>。</p><p>其他数字考虑<code>exp = 127 + 23</code>这个临界。如果大于这个数，需要将<code>frac</code>右移。如果小于这个数，需要将<code>frac</code>左移。   </p><p>法一：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span>&#123;  <span class="hljs-type">int</span> s = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;  <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = ((uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xFF</span>) - <span class="hljs-number">127</span>; <span class="hljs-comment">//exp的真实值</span>  <span class="hljs-type">int</span> frac = (uf &amp; <span class="hljs-number">0x007FFFFF</span>) | <span class="hljs-number">0x00800000</span>;  <span class="hljs-type">int</span> tar = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (s) s = <span class="hljs-number">-1</span>;  <span class="hljs-keyword">else</span> s = <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">31</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">23</span>)    tar = s * (frac &lt;&lt; (<span class="hljs-built_in">exp</span> - <span class="hljs-number">23</span>));  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">23</span>)    tar = s * (frac &gt;&gt; (<span class="hljs-number">23</span> - <span class="hljs-built_in">exp</span>));  <span class="hljs-keyword">return</span> tar;&#125;</code></pre></div><p>法二：  </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;    <span class="hljs-type">unsigned</span> INF = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;   <span class="hljs-comment">// INF = MaxInt+1</span>    <span class="hljs-type">int</span> e = (uf&gt;&gt;<span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>;<span class="hljs-comment">// 阶码</span>    <span class="hljs-type">int</span> s = (uf&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;   <span class="hljs-comment">// 符号位</span>    <span class="hljs-keyword">if</span> (uf == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    uf &lt;&lt;= <span class="hljs-number">8</span>;       <span class="hljs-comment">// 左移保留至阶码最后1位</span>    uf |= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;    <span class="hljs-comment">// 阶码最后一位设为1</span>    uf &gt;&gt;= <span class="hljs-number">8</span>;       <span class="hljs-comment">// 高八位全0</span>    e -= <span class="hljs-number">127</span>;       <span class="hljs-comment">// 阶数</span>    <span class="hljs-keyword">if</span> ((uf &amp; <span class="hljs-number">0x7f80000</span>) == <span class="hljs-number">0x7f80000</span> || e &gt;= <span class="hljs-number">32</span>)        <span class="hljs-keyword">return</span> INF; <span class="hljs-comment">// 超过int范围返回INF</span>    <span class="hljs-keyword">if</span> (e &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 小数返回0</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">22</span>) <span class="hljs-comment">// 位数小于等于22位，尾数位右移</span>        uf &gt;&gt;= <span class="hljs-number">23</span>-e;    <span class="hljs-keyword">else</span>         uf &lt;&lt;= e<span class="hljs-number">-23</span>; <span class="hljs-comment">// 尾数大于22位，尾数为左移</span>    <span class="hljs-keyword">if</span> (s)         uf = ~uf + <span class="hljs-number">1</span>;<span class="hljs-comment">// 若原uf为负数，则对此处的正数uf取反加1得其相反数</span>    <span class="hljs-keyword">return</span> uf;&#125;</code></pre></div><h3 id="13-floatPower2函数"><a href="#13-floatPower2函数" class="headerlink" title="13. floatPower2函数"></a>13. floatPower2函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><span class="hljs-comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *   The unsigned value that is returned should have the identical bit</span><span class="hljs-comment"> *   representation as the single-precision floating-point number 2.0^x.</span><span class="hljs-comment"> *   If the result is too small to be represented as a denorm, return</span><span class="hljs-comment"> *   0. If too large, return +INF.</span><span class="hljs-comment"> * </span><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span><span class="hljs-comment"> *   Max ops: 30 </span><span class="hljs-comment"> *   Rating: 4</span><span class="hljs-comment"> */</span><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;</code></pre></div><p>题意：  给出一个无符号整数x，将其看作一个浮点数，返回2**x。   </p><p>思路：  先得到阶码<code>exp = x + 127</code>，然后考虑临界值：  </p><p><code>bin(x) = 0 00000000 00000000000000000000001</code>，此数是<code>2**((-126)+(-23))</code>,<br>即<code>exp = 0</code>时情况；  </p><p><code>bin(x) = 0 00000001 00000000000000000000000</code>，此数是<code>2**(-126)</code>，<br>即<code>exp = 23</code>时情况；</p><p><code>bin(x) = 0 11111111 00000000000000000000000</code> ，此数是<code>2**(128)</code>，<br>即<code>exp = 255</code>时情况。</p><p>代码一：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;  <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = x + <span class="hljs-number">0x7f</span>;                          <span class="hljs-comment">// x + 127</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">0</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">0xff</span> ? <span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span> : <span class="hljs-number">0x7f800000</span>;  <span class="hljs-comment">//0xff = 255</span>&#125;</code></pre></div><p>代码二：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;    <span class="hljs-type">unsigned</span> INF = <span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">23</span>; <span class="hljs-comment">// 阶码全1</span>    <span class="hljs-type">int</span> e = <span class="hljs-number">127</span> + x;    <span class="hljs-comment">// 得到阶码</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 阶数小于0直接返回0</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (e &gt;= <span class="hljs-number">255</span>) <span class="hljs-comment">// 阶码&gt;=255直接返回INF</span>        <span class="hljs-keyword">return</span> INF;    <span class="hljs-keyword">return</span> e &lt;&lt; <span class="hljs-number">23</span>;    <span class="hljs-comment">// 直接将阶码左移23位，尾数全0，规格化时尾数隐藏有1个1作为底数</span>&#125;</code></pre></div><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><a href="https://imgtu.com/i/qvVsYD"><img src="https://s1.ax1x.com/2022/04/06/qvVsYD.png" alt="qvVsYD.png"></a></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>不愧是计算机系统的实验，实验内容和系统基础知识紧密联系，所接触到的不再是10进制数的计算，而是二进制及其反码补码，十六进制的计算，也不再仅仅是算术运算而更多的是逻辑、位的运算。由于知识储备的限制，一开始进行试验的时候实在是无从下手，思路上也受到了极大的限制，加之对于反码补码、有符号数无符号数、逻辑运算符、位运算符等等之类掌握的不深切，就觉得实验真的很难，当然本次实验的难度确实很大，实验内容也仅是datalab-handout的一部分，对其研究个八九不离十，十分有利与我对计算机系统学习，同时也要做好学习记录，以便日后回忆。  </p><p>tip：<br>  这篇博客会在后续继续完善（在自己更加明白时），目前内容仅供参考。</p>]]></content>
    
    
    <categories>
      
      <category>实验记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Csapp</tag>
      
      <tag>计算机系统</tag>
      
      <tag>位计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
